
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>5. Track Generation &mdash; OpenMOC Documentation</title>
    
    <link rel="stylesheet" href="../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/breathe.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.1.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="OpenMOC Documentation" href="../index.html" />
    <link rel="up" title="Theory and Methodology" href="index.html" />
    <link rel="next" title="6. Parallelization" href="parallelization.html" />
    <link rel="prev" title="4. Constructive Solid Geometry" href="constructive_solid_geometry.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="parallelization.html" title="6. Parallelization"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="constructive_solid_geometry.html" title="4. Constructive Solid Geometry"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">OpenMOC Documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Theory and Methodology</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="track-generation">
<span id="id1"></span><h1>5. Track Generation<a class="headerlink" href="#track-generation" title="Permalink to this headline">¶</a></h1>
<p>The method of characteristics uses tracks across the geometry to discretize the azimuthal and polar angle domains as well as the spatial domain. The way in which an MOC code generates tracks affects the quadrature weights <img class="math" src="../_images/math/44131370d33f693fa292ebf4657594f54d5b4c8f.png" alt="w_{p}"/>, <img class="math" src="../_images/math/f4823beacbe7805f3bf3ef4947845335d6c3bdc8.png" alt="w_{m}"/>, and <img class="math" src="../_images/math/7c3221d5a0451b9b7652a9a94113ed5303811411.png" alt="w_{k}"/> used to compute the angular and spatial integrals in the transport equation. This section describes the methodology used to generate tracks in OpenMOC and the corresponding angular and spatial quadrature weights.</p>
<div class="section" id="cylic-tracks">
<span id="cyclic-tracks"></span><h2>5.1. Cylic Tracks<a class="headerlink" href="#cylic-tracks" title="Permalink to this headline">¶</a></h2>
<p>OpenMOC uses <em>global tracking</em> such that each track spans the entire extent of the simulation domain. By symmetry, tracks only need to be represented for azimuthal angles in the range <img class="math" src="../_images/math/fc3c98542777b7cc0eec8a411e237cabce1ea620.png" alt="\phi \in [0, \pi]"/> since a track with angle <img class="math" src="../_images/math/2c175f60eecef1de7560c3bdea495d69f26f719d.png" alt="\phi"/> will have the same start and end points as a track with angle <img class="math" src="../_images/math/923e047709c81317314edb78d6bf9092ba27e86f.png" alt="\phi + \pi"/>. <em>Complementary angles</em> are pairs of angles <img class="math" src="../_images/math/518f2ccbb50680e316e47eb59485fd70f3745298.png" alt="(\phi, \alpha)"/> in the azimuthal quadrature where <img class="math" src="../_images/math/8c370b45e5aca4e48f48f7a75a582f07fbd1ddb8.png" alt="\alpha = \pi - \phi"/>. Tracks for complementary angles have a <em>track spacing</em> such that they intersect at the boundaries of the geometry and form closed cycles. An illustration of OpenMOC&#8217;s track layout for eight azimuthal angles is given in <a class="reference internal" href="#figure-cyclic-tracks"><em>Figure 1</em></a>.</p>
<div class="align-center figure align-center" id="figure-cyclic-tracks">
<img alt="../_images/cyclic-tracks.png" src="../_images/cyclic-tracks.png" style="width: 300px;" />
<p class="caption"><strong>Figure 1</strong>: Global cylic tracks across a square.</p>
</div>
<p>Cyclic tracking is important since it allows for a simple treatment of reflective boundary conditions. Boundary conditions must be respected for the track outgoing fluxes at each iteration. Vacuum boundary conditions on a surface can be implemented for the MOC formulation by ensuring that each track originating along that surface has zero incoming flux, while tallying outgoing flux as leakage. Reflective boundary conditions are easily implemented since complementary angles guarantee that tracks wrap around the geometry in closed cycles. No approximations need to be made for each track&#8217;s incoming flux since it is exactly the outgoing flux of another track in the cycle.</p>
<p>The key parameters necessary for track generation in an OpenMOC simulation are the number of azimuthal angles <img class="math" src="../_images/math/8bb1137e80763c1cd53cf937e79d1df18a1c5bee.png" alt="n_{a}"/>, the spacing between tracks <img class="math" src="../_images/math/6b8ccf6d4ca78c0fa36df58da884aec06d424da2.png" alt="t_{s}"/>, and the total width and height of the geometry, <img class="math" src="../_images/math/9ee4b825a2e36ae093ed7be5e4851ef453b34914.png" alt="w"/> and <img class="math" src="../_images/math/8189a5b5a0917b8c93350827be4038af1839139d.png" alt="h"/>, respectively. OpenMOC computes the appropriate azimuthal angles to form cyclic tracks prior to track generation and ray tracing. The algorithm used by OpenMOC attempts to divide up the azimuthal space <img class="math" src="../_images/math/b739084cba94bd9614c7ada9c3de4f0828457719.png" alt="\phi \in [0, 2\pi]"/> as evenly as possible. In particular, for index <img class="math" src="../_images/math/0e970252162b7a0e0918c7e8c1f56aba0a73fbbe.png" alt="m \in \{1, 2, ..., M\}"/>, the desired azimuthal angle <img class="math" src="../_images/math/29365021db28430a651f9a5b0d1d7bacc85ddd6c.png" alt="\phi_{m}"/> is the following:</p>
<div class="math" id="equation-desired-azim-angle">
<p><span class="eqno">(1)</span><img src="../_images/math/a4240b6d2ff49e266067e931829ed1cbfb6a70a8.png" alt="\phi_{m} = \frac{2\pi}{n_{a}}(m - 0.5)"/></p>
</div><p>This angle is then used to compute the number of tracks <img class="math" src="../_images/math/aaf2e127627081099a7f7447dc24033bbc18e838.png" alt="n_{y}"/> and <img class="math" src="../_images/math/643194206f0c0946ddbf5599f07fe8d320934575.png" alt="n_{x}"/> for angle <img class="math" src="../_images/math/f5047d1e0cbb50ec208923a22cd517c55100fa7b.png" alt="m"/> originating from the left and bottom boundaries of the geometry using the floor function:</p>
<div class="math" id="equation-num-tracks-bottom">
<p><span class="eqno">(2)</span><img src="../_images/math/22ba8c0bce4cbb9524dd1cbb57261ad0a1a0da5c.png" alt="n_{y} = \left\lfloor\frac{w}{t_{s}}|\sin\phi_{m}|\right\rfloor + 1"/></p>
</div><div class="math" id="equation-num-tracks-left">
<p><span class="eqno">(3)</span><img src="../_images/math/5ec3d3f6029756ef7911998159f170dc5f017cb9.png" alt="n_{x} = \left\lfloor{\frac{h}{t_{s}}|\cos\phi_{m}|}\right\rfloor + 1"/></p>
</div><p>Given <img class="math" src="../_images/math/aaf2e127627081099a7f7447dc24033bbc18e838.png" alt="n_{y}"/> and <img class="math" src="../_images/math/643194206f0c0946ddbf5599f07fe8d320934575.png" alt="n_{x}"/>, an <em>effective angle</em> <img class="math" src="../_images/math/449e6d12be2a51b4e6f766154a675b7ac1da93ec.png" alt="\phi_{m,eff}"/> is computed as a correction to the desired azimuthal angle <img class="math" src="../_images/math/29365021db28430a651f9a5b0d1d7bacc85ddd6c.png" alt="\phi_{m}"/> to ensure cyclic track wrapping:</p>
<div class="math" id="equation-effective-azim-angle">
<p><span class="eqno">(4)</span><img src="../_images/math/48c42151aaeab868d5acef3fb0a3dd68c0bcbff8.png" alt="\phi_{m,eff} = \tan^{-1}\left(\frac{hn_{x}}{wn_{y}}\right)"/></p>
</div><p>Although OpenMOC will abide by a user&#8217;s request for the number of azimuthal angles, an <em>effective spacing</em> <img class="math" src="../_images/math/06b30db4e06d3d283e461bcbb27bccc8e0142827.png" alt="t_{s,m,eff}"/> must be computed and used instead of that specified by the user in order for the tracks wrap around the geometry. The effective spacing is unique for each azimuthal angle <img class="math" src="../_images/math/f5047d1e0cbb50ec208923a22cd517c55100fa7b.png" alt="m"/>, and is computed as follows:</p>
<div class="math" id="equation-effective-spacing">
<p><span class="eqno">(5)</span><img src="../_images/math/b479f9e36bb406e86b425a99b5008fcee614a450.png" alt="t_{s,m,eff} = \frac{w}{n_{x}}\sin\phi_{m,eff}"/></p>
</div><p>The reader should note that this method for computing the effective track spacing in OpenMOC ensures that the following condition is always true:</p>
<div class="math" id="equation-effective-spacing-criterion">
<p><span class="eqno">(6)</span><img src="../_images/math/1674602e33d56909b985a4d16697c2aaa4541abe.png" alt="t_{s,m,eff} \;\;\; \le \;\;\; t_{s}"/></p>
</div></div>
<div class="section" id="azimuthal-and-polar-angle-quadrature">
<span id="azimuthal-polar-angle-quadrature"></span><h2>5.2. Azimuthal and Polar Angle Quadrature<a class="headerlink" href="#azimuthal-and-polar-angle-quadrature" title="Permalink to this headline">¶</a></h2>
<p>The azimuthal angle quadrature set is computed based on the fraction of azimuthal angular space &#8220;owned&#8221; by each azimuthal angle. In this section, the variable transformation <img class="math" src="../_images/math/701cf34bdc348f0ae96a6e66f0b34dec2eb311e6.png" alt="\phi_{m} \gets \phi_{m,eff}"/> has been made such that the effective azimuthal angle is used throughout. The azimuthal angle quadrature weight specification is given in <a href="#equation-azimuthal-quadrature-1">(7)</a>, <a href="#equation-azimuthal-quadrature-2">(8)</a>, and <a href="#equation-azimuthal-quadrature-3">(9)</a>.</p>
<div class="math" id="equation-azimuthal-quadrature-1">
<p><span class="eqno">(7)</span><img src="../_images/math/ab2d33423d78247f22eada8194b9b23de2aa470a.png" alt="w_{m} = \frac{1}{2\pi}\left[\frac{\phi_{m+1} - \phi_{m}}{2} + \phi_{m}\right] &amp; \;\; \text{if} \;\;\; m = 1"/></p>
</div><div class="math" id="equation-azimuthal-quadrature-2">
<p><span class="eqno">(8)</span><img src="../_images/math/39e248c9f3ab366783a955d431a0e0c77f01f8b8.png" alt="w_{m} = \frac{1}{2\pi}\left[\frac{\phi_{m+1} - \phi_{m}}{2} + \frac{\phi_{m} - \phi_{m-1}}{2}\right] &amp; \;\; \text{if} \;\;\; 1 &lt; m &lt; M"/></p>
</div><div class="math" id="equation-azimuthal-quadrature-3">
<p><span class="eqno">(9)</span><img src="../_images/math/2cfc7ff5a6c5a5fa524748af96a453706242c42b.png" alt="w_{m} = \frac{1}{2\pi}\left[2\pi - \phi_{m} + \frac{\phi_{m} - \phi_{m-1}}{2}\right] &amp; \;\; \text{if} \;\;\; m = M"/></p>
</div><p>The quadrature recommended by Yamamoto <a class="footnote-reference" href="#id8" id="id2">[1]</a> is used by default for the polar angles and weights in OpenMOC.</p>
</div>
<div class="section" id="spatial-quadrature">
<span id="id3"></span><h2>5.3. Spatial Quadrature<a class="headerlink" href="#spatial-quadrature" title="Permalink to this headline">¶</a></h2>
<p>Track segments are used to approximate the area integral across each flat source region. In particular, the effective track spacing <img class="math" src="../_images/math/06b30db4e06d3d283e461bcbb27bccc8e0142827.png" alt="t_{s,m,eff}"/> defines the quadrature weights used in the spatial integral in the transport equation.</p>
<div class="math">
<p><span class="eqno">(10)</span><img src="../_images/math/8b9c2ed007b9782cef6b15dc1fc12d117679df05.png" alt="\forall \; m \in \{1, ..., M\} \;\;,\;\; \forall \; k \in K(m) \;\;\;\; w_{k} = t_{s,m,eff}"/></p>
</div></div>
<div class="section" id="ray-tracing">
<span id="id4"></span><h2>5.4. Ray Tracing<a class="headerlink" href="#ray-tracing" title="Permalink to this headline">¶</a></h2>
<p>Ray tracing is a technique for computing the intersection points of trajectories with surfaces. The image processing and graphics communities have been the primary users and developers of ray tracing techniques over the years, and a subset of these algorithms have been applied to neutron transport. In the case of the method of characteristics, ray tracing is used to intersect characteristic tracks with the surfaces used to make up a model. In particular, ray tracing is used to compute the length <img class="math" src="../_images/math/a7dd07e5817272fd952051ccc98733b87dbdfa7f.png" alt="l_{k,i}"/> of a segment for track <img class="math" src="../_images/math/8c325612684d41304b9751c175df7bcc0f61f64f.png" alt="k"/> across each flat source region <img class="math" src="../_images/math/34857b3ba74ce5cd8607f3ebd23e9015908ada71.png" alt="i"/>.</p>
<p>The primary computation in ray tracing for MOC is to take a track segment&#8217;s starting location <img class="math" src="../_images/math/e53b1fe25be1c679117fb44a6a886fe1247d189a.png" alt="(x,y)"/> and direction vector <img class="math" src="../_images/math/f9eb89b1268b1e4fd25622e4e3cfbd748abe5826.png" alt="\hat{u}"/> and compute the distance that the track spans across a given cell. The <em>track segmentation</em> process repeatedly performs this computation for each track from its start to end point on the boundaries of the geometry. There are four primary operations that one must be able to perform to ray trace a track across the geometry:</p>
<ul class="simple">
<li>Determine which universe the starting point <img class="math" src="../_images/math/e53b1fe25be1c679117fb44a6a886fe1247d189a.png" alt="(x,y)"/> resides in</li>
<li>Determine which cell the starting point <img class="math" src="../_images/math/e53b1fe25be1c679117fb44a6a886fe1247d189a.png" alt="(x,y)"/> resides in</li>
<li>Determine the distance to the nearest surface in the cell</li>
<li>Determine the intersection point with the nearest surface</li>
</ul>
<p>The following four sections describe each of the algorithms used to perform each of these four ray tracing operations in OpenMOC.</p>
<div class="section" id="universe-finding-algorithm">
<span id="id5"></span><h3>5.4.1. Universe-Finding Algorithm<a class="headerlink" href="#universe-finding-algorithm" title="Permalink to this headline">¶</a></h3>
<p>The first algorithm needed for track segmentation is the ability to find the universe corresponding to a given location <img class="math" src="../_images/math/e53b1fe25be1c679117fb44a6a886fe1247d189a.png" alt="(x,y)"/>. The universe-finding algorithm used in OpenMOC is described in <a class="reference internal" href="#algorithm-find-universe"><em>Algorithm 1</em></a>. This algorithm requires the location <img class="math" src="../_images/math/e53b1fe25be1c679117fb44a6a886fe1247d189a.png" alt="(x,y)"/> input along with the outermost lattice <img class="math" src="../_images/math/859ccf4cd60c7bc6b8fa1afc9a42dc811a826d6f.png" alt="L"/> in the model. The algorithm computes the lattice cell in which <img class="math" src="../_images/math/e53b1fe25be1c679117fb44a6a886fe1247d189a.png" alt="(x,y)"/> resides and either returns the universe filling that lattice cell, or recursively calls itself using the lattice filling the lattice cell. In the latter case, the coordinates of the location <img class="math" src="../_images/math/e53b1fe25be1c679117fb44a6a886fe1247d189a.png" alt="(x,y)"/> must first be translated to the <em>local coordinate system</em> within the lattice cell, as reflected in <a class="reference internal" href="#algorithm-find-universe"><em>Algorithm 1</em></a>. The algorithm completes by returning the universe along with the coordinates of the location within the universe&#8217;s local coordinate system.</p>
<div class="align-center figure align-center" id="algorithm-find-universe">
<img alt="../_images/find-universe-algorithm.png" src="../_images/find-universe-algorithm.png" style="width: 900px;" />
<p class="caption"><strong>Algorithm 1</strong>: Universe-finding algorithm.</p>
</div>
<p><a class="reference internal" href="#figure-nested-lattice-coordinates"><em>Figure 2</em></a> illustrates one possible model with two <em>nested lattices</em> and the local coordinate transformations made using this algorithm. Here, <img class="math" src="../_images/math/643194206f0c0946ddbf5599f07fe8d320934575.png" alt="n_{x}"/> and <img class="math" src="../_images/math/aaf2e127627081099a7f7447dc24033bbc18e838.png" alt="n_{y}"/> represent the number of lattice cells along the <img class="math" src="../_images/math/26eeb5258ca5099acf8fe96b2a1049c48c89a5e6.png" alt="x"/> and <img class="math" src="../_images/math/092e364e1d9d19ad5fffb0b46ef4cc7f2da02c1c.png" alt="y"/> axes, while <img class="math" src="../_images/math/8189a5b5a0917b8c93350827be4038af1839139d.png" alt="h"/> and <img class="math" src="../_images/math/9ee4b825a2e36ae093ed7be5e4851ef453b34914.png" alt="w"/> represent the total height and width of the lattice, respectively. Numerical subscripts are used to identify the appropriate lattice level.</p>
<div class="align-center figure align-center" id="figure-nested-lattice-coordinates">
<img alt="../_images/nested-coordinates.png" src="../_images/nested-coordinates.png" style="width: 400px;" />
<p class="caption"><strong>Figure 2</strong>: Local coordinates within nested lattices.</p>
</div>
<p>The reader should note that this algorithm assumes that <img class="math" src="../_images/math/e53b1fe25be1c679117fb44a6a886fe1247d189a.png" alt="(x,y)"/> is within the bounds of the lattice. In practice, a significant amount of error checking is involved to ensure that this algorithm is robust to user input as well as floating point roundoff errors from the coordinate transformations at each recursive call.</p>
</div>
<div class="section" id="cell-finding-algorithm">
<span id="id6"></span><h3>5.4.2. Cell-Finding Algorithm<a class="headerlink" href="#cell-finding-algorithm" title="Permalink to this headline">¶</a></h3>
<p>The second algorithm needed for track segmentation is the ability to find the cell corresponding to a given location <img class="math" src="../_images/math/e53b1fe25be1c679117fb44a6a886fe1247d189a.png" alt="(x,y)"/>. The cell-finding algorithm is described in <a class="reference internal" href="#algorithm-find-cell"><em>Algorithm 2</em></a>. The algorithm first finds the universe <img class="math" src="../_images/math/9ad99798ec4c38e165cf517cb9e02b1c9e824103.png" alt="u"/> in which <img class="math" src="../_images/math/e53b1fe25be1c679117fb44a6a886fe1247d189a.png" alt="(x,y)"/> resides using <a class="reference internal" href="#algorithm-find-universe"><em>Algorithm 1</em></a>. Next, the algorithm loops over all cells in the universe <img class="math" src="../_images/math/28d5f10eadf1b85cc094edd092de84ea83c29e3a.png" alt="c \in u"/>. For each cell <img class="math" src="../_images/math/3372c1cb6d68cf97c2d231acc0b47b95a9ed04cc.png" alt="c"/>, the algorithm iterates over each surface <img class="math" src="../_images/math/6c3a08798893880c214e198db2497cd19d909e88.png" alt="s \in c"/> and multiplies the halfspace of the surface in the cell <img class="math" src="../_images/math/98a058f8b284c71b082cb94608992d140e788dfd.png" alt="Hf(c,s) = \pm 1"/> with the potential function evaluated at the point of interest <img class="math" src="../_images/math/500a880f8b2209ced4f88a6d5d45d24530b066ae.png" alt="f_{s}(x,y)"/>. There are three possible outcomes from this computation:</p>
<div class="math" id="equation-halfspace-evaluation-1">
<p><span class="eqno">(11)</span><img src="../_images/math/76c5d8ddc04e922d57ae6121c31fb5558e6a4fab.png" alt="sgn(Hf(c,s) \times f_{s}(x,y)) = +1 &amp; \; \Rightarrow \;\; \text{$(x,y)$ is in the halfspace}"/></p>
</div><div class="math" id="equation-halfspace-evaluation-2">
<p><span class="eqno">(12)</span><img src="../_images/math/c9fb256abb2dda6dc28b87449c76b08f0956b339.png" alt="sgn(Hf(c,s) \times f_{s}(x,y)) = 0 &amp; \; \Rightarrow \;\; \text{$(x,y)$ is on the surface}"/></p>
</div><div class="math" id="equation-halfspace-evaluation-3">
<p><span class="eqno">(13)</span><img src="../_images/math/939ffa5a2b2d6c211e99f4b50b29104a4476ed9c.png" alt="sgn(Hf(c,s) \times f_{s}(x,y)) = -1 &amp; \; \Rightarrow \;\; \text{$(x,y)$ is in the opposite halfspace}"/></p>
</div><p>For simplicity, the assumption is made that the point <img class="math" src="../_images/math/e53b1fe25be1c679117fb44a6a886fe1247d189a.png" alt="(x,y)"/> is not on any surface in the geometry, or more formally, <img class="math" src="../_images/math/08453348dc11102925c46eed035639b5ab4ec4b0.png" alt="\forall \; s \;\; f_{s}(x,y) \neq 0"/>. If any cell is found in which the potential evaluated at <img class="math" src="../_images/math/e53b1fe25be1c679117fb44a6a886fe1247d189a.png" alt="(x,y)"/> and the halfspace of the corresponding surface each have the same sign for all surfaces in the cell, then the point <img class="math" src="../_images/math/e53b1fe25be1c679117fb44a6a886fe1247d189a.png" alt="(x,y)"/> uniquely resides in the cell and it is returned by the algorithm.</p>
<p>The reader should note that <img class="math" src="../_images/math/3e4664115346690c76cc08b2d3cd6905c6f2aa3d.png" alt="L_{base}"/> in the following algorithm refers to the base lattice or universe that is used to encapsulate the outermost level of the geometry.</p>
<div class="align-center figure align-center" id="algorithm-find-cell">
<img alt="../_images/find-cell-algorithm.png" src="../_images/find-cell-algorithm.png" style="width: 900px;" />
<p class="caption"><strong>Algorithm 2</strong>: Cell-finding algorithm.</p>
</div>
</div>
<div class="section" id="distance-to-nearest-surface-algorithm">
<span id="surface-distance-algorithm"></span><h3>5.4.3. Distance-to-Nearest Surface Algorithm<a class="headerlink" href="#distance-to-nearest-surface-algorithm" title="Permalink to this headline">¶</a></h3>
<p>The third algorithm that is needed for ray tracing is used to find the distance to the nearest surface to <img class="math" src="../_images/math/e53b1fe25be1c679117fb44a6a886fe1247d189a.png" alt="(x,y)"/> along the trajectory vector <img class="math" src="../_images/math/e30a370354cf9f53e8b5219dbc856f54d52c5a04.png" alt="\hat{n}"/>. This algorithm builds upon each of the previous two as it only evaluates surfaces bounding the cell in which <img class="math" src="../_images/math/e53b1fe25be1c679117fb44a6a886fe1247d189a.png" alt="(x,y)"/> resides.</p>
<p>The distance-to-nearest surface algorithm is described in <a class="reference internal" href="#algorithm-minimum-surface-distance"><em>Algorithm 3</em></a>. The algorithm simply iterates over each surface <img class="math" src="../_images/math/f37bba504894945c07a32f5496d74299a37aa51c.png" alt="s"/> in the cell <img class="math" src="../_images/math/3372c1cb6d68cf97c2d231acc0b47b95a9ed04cc.png" alt="c"/> and solves for the distance(s) to the surface. The algorithm keeps track of the minimum distance <img class="math" src="../_images/math/3bf67af3365f4a79643a8f83ccb546ab0465f8c6.png" alt="d_{min}"/> it has evaluated to a surface at each step and returns the final value after iterating through all of the surfaces.</p>
<div class="align-center figure align-center" id="algorithm-minimum-surface-distance">
<img alt="../_images/min-surf-dist-algorithm.png" src="../_images/min-surf-dist-algorithm.png" style="width: 900px;" />
<p class="caption"><strong>Algorithm 3</strong>: Minimum surface distance algorithm.</p>
</div>
</div>
<div class="section" id="next-intersection-point-algorithm">
<span id="id7"></span><h3>5.4.4. Next Intersection Point Algorithm<a class="headerlink" href="#next-intersection-point-algorithm" title="Permalink to this headline">¶</a></h3>
<p>The final algorithm needed for ray tracing is to compute the intersection point of a point <img class="math" src="../_images/math/e53b1fe25be1c679117fb44a6a886fe1247d189a.png" alt="(x,y)"/> along a trajectory vector <img class="math" src="../_images/math/f9eb89b1268b1e4fd25622e4e3cfbd748abe5826.png" alt="\hat{u}"/> with the nearest surface. The preceding algorithm is used to compute the parametrized distance to the intersection. This algorithm simply adds the parametrized distance multiplied by the trajectory vector to <img class="math" src="../_images/math/e53b1fe25be1c679117fb44a6a886fe1247d189a.png" alt="(x,y)"/> as described in <a class="reference internal" href="#algorithm-next-intersection-point"><em>Algorithm 4</em></a>.</p>
<div class="align-center figure align-center" id="algorithm-next-intersection-point">
<img alt="../_images/next-intersection-point-algorithm.png" src="../_images/next-intersection-point-algorithm.png" style="width: 900px;" />
<p class="caption"><strong>Algorithm 4</strong>: Find nearest surface intersection point algorithm.</p>
</div>
</div>
<div class="section" id="track-segmentation-algorithm">
<span id="track-segmentation"></span><h3>5.4.5. Track Segmentation Algorithm<a class="headerlink" href="#track-segmentation-algorithm" title="Permalink to this headline">¶</a></h3>
<p>Each of the preceding algorithms collectively define all of the logic that is necessary for ray tracing in the constructive solid geometry formulation. <a class="reference internal" href="#algorithm-ray-tracing"><em>Algorithm 5</em></a> defines the complete process of track segmentation for each track in the geometry. The algorithm defines a nested loop over all azimuthal angles <img class="math" src="../_images/math/f5047d1e0cbb50ec208923a22cd517c55100fa7b.png" alt="m"/> and tracks <img class="math" src="../_images/math/8c325612684d41304b9751c175df7bcc0f61f64f.png" alt="k"/>. For each track, the algorithm begins with the track starting location and trajectory vector and ray traces across the geometry by computing intersection points with each surface along the trajectory&#8217;s path. At each step, the length of each track segment in each cell (FSR) is computed and a pair of the segment length <img class="math" src="../_images/math/a7dd07e5817272fd952051ccc98733b87dbdfa7f.png" alt="l_{k,i}"/> and flat source region index <img class="math" src="../_images/math/34857b3ba74ce5cd8607f3ebd23e9015908ada71.png" alt="i"/> is appended to an ordered list of track segments within the track.</p>
<p>This algorithm relies upon the use of a small numerical parameter <img class="math" src="../_images/math/eaf4418fbe935c15a606516d8f55dc380cd8e822.png" alt="\epsilon"/> which is typically chosen to be <img class="math" src="../_images/math/c61c5a1e7ecb8844cc11069bcbc3d592295c69f6.png" alt="10^{-6}"/> for single precision and <img class="math" src="../_images/math/6336cd9b79f2499e10784c0214c316dc2641adf9.png" alt="10^{-12}"/> for double precision floating point numbers. This parameter allows the end point for each track segment to be perturbed slightly to force it to lie within the adjacent cell in order to meet the assumption that no point lies directly on a surface (declared in order for <a class="reference internal" href="#algorithm-find-cell"><em>Algorithm 5</em></a> to perform properly).</p>
<div class="align-center figure align-center" id="algorithm-ray-tracing">
<img alt="../_images/ray-tracing-algorithm.png" src="../_images/ray-tracing-algorithm.png" style="width: 900px;" />
<p class="caption"><strong>Algorithm 5</strong>: Track segmentation algorithm.</p>
</div>
</div>
</div>
<div class="section" id="references">
<h2>5.5. References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[1]</a></td><td><ol class="first last upperalpha simple">
<li>Yamamoto, M. Tabuchi, N. Sugimura, T. Ushio and M. Mori, &#8220;Derivation of Optimum Polar Angle Quadrature Set for the Method of Characteristics Based on Approximation Error for the Bickley Function.&#8221; <em>Journal of Nuclear Science and Engineering</em>, <strong>44(2)</strong>, pp. 129-136 (2007).</li>
</ol>
</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/openmoc-logo-api.png" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">5. Track Generation</a><ul>
<li><a class="reference internal" href="#cylic-tracks">5.1. Cylic Tracks</a></li>
<li><a class="reference internal" href="#azimuthal-and-polar-angle-quadrature">5.2. Azimuthal and Polar Angle Quadrature</a></li>
<li><a class="reference internal" href="#spatial-quadrature">5.3. Spatial Quadrature</a></li>
<li><a class="reference internal" href="#ray-tracing">5.4. Ray Tracing</a><ul>
<li><a class="reference internal" href="#universe-finding-algorithm">5.4.1. Universe-Finding Algorithm</a></li>
<li><a class="reference internal" href="#cell-finding-algorithm">5.4.2. Cell-Finding Algorithm</a></li>
<li><a class="reference internal" href="#distance-to-nearest-surface-algorithm">5.4.3. Distance-to-Nearest Surface Algorithm</a></li>
<li><a class="reference internal" href="#next-intersection-point-algorithm">5.4.4. Next Intersection Point Algorithm</a></li>
<li><a class="reference internal" href="#track-segmentation-algorithm">5.4.5. Track Segmentation Algorithm</a></li>
</ul>
</li>
<li><a class="reference internal" href="#references">5.5. References</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="constructive_solid_geometry.html"
                        title="previous chapter">4. Constructive Solid Geometry</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="parallelization.html"
                        title="next chapter">6. Parallelization</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/methods/track_generation.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="parallelization.html" title="6. Parallelization"
             >next</a> |</li>
        <li class="right" >
          <a href="constructive_solid_geometry.html" title="4. Constructive Solid Geometry"
             >previous</a> |</li>
        <li><a href="../index.html">OpenMOC Documentation</a> &raquo;</li>
          <li><a href="index.html" >Theory and Methodology</a> &raquo;</li> 
      </ul>
    </div>

    <div class="footer">
        &copy; Copyright 2012-2013, Massachusetts Institute of Technology.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-30411614-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

  </body>
</html>