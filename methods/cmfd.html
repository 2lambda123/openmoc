<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>6. Coarse Mesh Finite Difference Acceleration &mdash; OpenMOC Documentation</title>
    
    <link rel="stylesheet" href="../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.1.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="OpenMOC Documentation" href="../index.html" />
    <link rel="up" title="Theory and Methodology" href="index.html" />
    <link rel="next" title="User’s Guide" href="../usersguide/index.html" />
    <link rel="prev" title="5. Track Generation" href="track_generation.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../usersguide/index.html" title="User’s Guide"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="track_generation.html" title="5. Track Generation"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">OpenMOC Documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Theory and Methodology</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="coarse-mesh-finite-difference-acceleration">
<span id="cmfd"></span><h1>6. Coarse Mesh Finite Difference Acceleration<a class="headerlink" href="#coarse-mesh-finite-difference-acceleration" title="Permalink to this headline">¶</a></h1>
<p>While MOC offers many benefits including treatment of complex geometries and amenability to parallelization, it suffers from slow convergence which necessitates the use of acceleration methods. Numerous acceleration schemes have been proposed for MOC such as CMFD <a class="reference internal" href="#smith-1983" id="id1">[Smith-1983]</a>, coarse mesh rebalance (CMR) <a class="reference internal" href="#yamamoto-2002" id="id2">[Yamamoto-2002]</a>, <a class="reference internal" href="#yamamoto-2005" id="id3">[Yamamoto-2005]</a>, <a class="reference internal" href="#yamamoto-2008" id="id4">[Yamamoto-2008]</a>, <a class="reference internal" href="#lewis" id="id5">[Lewis]</a>, and low order transport operator acceleration <a class="reference internal" href="#li" id="id6">[Li]</a> with CMFD being the most widely adopted due to its simplicity and acceleration performance. OpenMOC uses the CMFD nonlinear diffusion acceleration (NDA) scheme to reduce the number of iterations required for convergence. Acceleration schemes, such as NDA, are necessary when solving full-core problems which require thousands of power iterations in LWR problems that tend to have high dominance ratios. CMFD was first proposed by Smith <a href="#id22"><span class="problematic" id="id23"><span id="id7"></span>[1]_</span></a> and has been widely used in accelerating neutron diffusion and transport problems for many years. In particular, it has been shown that CMFD acceleration gives <img class="math" src="../_images/math/78ebd4cdaabc38007623a06192e4af8b92432fc5.png" alt="&gt;"/> 100x speedups on large LWR problems <a class="reference internal" href="#smith-2002" id="id8">[Smith-2002]</a>.</p>
<p>CMFD acceleration functions by using the solution of a coarse mesh diffusion problem to accelerate the convergence of a fine mesh transport problem. It is implemented by overlaying a 2D cartesian mesh over an FSR mesh. <a class="reference internal" href="#figure-fsr-mesh-regions"><span>Figure 1</span></a> gives an illustration of the FSR mesh layout and coarse mesh layout used for solving a 17 x 17 PWR assembly problem.</p>
<p>CMFD acceleration functions by using the solution of a coarse mesh diffusion problem to accelerate the convergence of a fine mesh transport problem. It is implemented by overlaying a 2D cartesian mesh over an unstructured FSR mesh. <a class="reference internal" href="#figure-fsr-mesh-regions"><span>Figure 1</span></a> gives an illustration of the FSR mesh layout and coarse mesh layout used for solving a 17 x 17 PWR assembly problem.</p>
<div class="align-center figure" id="id10">
<span id="figure-fsr-mesh-regions"></span><a class="reference internal image-reference" href="../_images/fig-fsr-mesh-regions.png"><img alt="../_images/fig-fsr-mesh-regions.png" src="../_images/fig-fsr-mesh-regions.png" style="width: 700px;" /></a>
<p class="caption"><span class="caption-text"><strong>Figure 1</strong>: Flat source region (left) and CMFD (right) mesh layout for a 17 x 17 PWR assembly where each colored cell denotes a different region.</span></p>
</div>
<p>To derive the CMFD equations, we begin with the 2D, steady state multi-group neutron diffusion equation:</p>
<div class="math" id="equation-dif-eqn">
<p><span class="eqno">(1)</span><img src="../_images/math/6d1b6e84c668ead6a5cffa823de756e760204a18.png" alt="- \nabla \cdot D_{\mathbf{g}} (x,y) \nabla \phi_{\mathbf{g}} (x,y) + \varSigma^A_{\mathbf{g}} (x,y) \phi_{\mathbf{g}} (x,y) + \sum_{\substack{{\mathbf{g}} \prime = 1 \\ {\mathbf{g}} \prime \neq {\mathbf{g}}}}^{\mathbf{G}} \varSigma^S_{{\mathbf{g}} \rightarrow {\mathbf{g}} \prime} (x,y) \phi_{\mathbf{g}} (x,y) = \frac{\chi_{\mathbf{g}} (x,y)}{k_{eff}} \sum_{{\mathbf{g}} \prime = 1}^{\mathbf{G}} \nu \varSigma^F_{{\mathbf{g}} \prime} (x,y) \phi_{{\mathbf{g}} \prime} (x,y) + \sum_{\substack{{\mathbf{g}} \prime = 1 \\ {\mathbf{g}} \prime \neq {\mathbf{g}}}}^{\mathbf{G}} \varSigma^S_{{\mathbf{g}} \prime \rightarrow {\mathbf{g}}} (x,y) \phi_{{\mathbf{g}} \prime} (x,y)"/></p>
</div><p>Where the terms in equation <a href="#equation-dif-eqn">(1)</a> are defined as:</p>
<table border="1" class="docutils" id="table-dif-eqn-terms">
<colgroup>
<col width="35%" />
<col width="25%" />
<col width="16%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Variable</th>
<th class="head">Description</th>
<th class="head">Variable</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><img class="math" src="../_images/math/9dfa31437b58c0473299320aa638151cd88cf61b.png" alt="D"/></td>
<td>Diffusion coefficient</td>
<td><img class="math" src="../_images/math/10e009bdb83f96c5f47c58b34d5d4b12ef268d5b.png" alt="\phi"/></td>
<td>Scalar flux on coarse mesh</td>
</tr>
<tr class="row-odd"><td><img class="math" src="../_images/math/bd9112158ef2f3a6f94c69c418c681591c40a3f7.png" alt="\varSigma^A"/></td>
<td>Coarse mesh absorption XS</td>
<td><img class="math" src="../_images/math/f632c791f693410fc1bf07ad7cb02c6fcfef9aed.png" alt="\chi"/></td>
<td>Fission spectrum</td>
</tr>
<tr class="row-even"><td><img class="math" src="../_images/math/f0c3ec77792d1240ac94e42e7ca3ec67c1770efa.png" alt="\varSigma^S"/></td>
<td>Coarse mesh scattering XS</td>
<td><img class="math" src="../_images/math/e45162800d593c2dee55555d800d84157e75ae00.png" alt="k_{eff}"/></td>
<td>Neutron multiplication factor</td>
</tr>
<tr class="row-odd"><td><img class="math" src="../_images/math/438fa0e26ae0c692474c4b83c923fdf4d9947038.png" alt="\varSigma^F"/></td>
<td>Coarse mesh fission XS</td>
<td><img class="math" src="../_images/math/d67fb61cfffca2cc069e083d76cb6220b4ca14c8.png" alt="\nu"/></td>
<td>Neutrons per fission</td>
</tr>
<tr class="row-even"><td><img class="math" src="../_images/math/bf8f5c7607a367b9d605eb4ecb4df717762e627e.png" alt="{\mathbf{g}}, {\mathbf{g}} \prime"/></td>
<td>Energy group index</td>
<td><img class="math" src="../_images/math/4bee6c8143f58f4fe181c0845298f4bd28cc61e1.png" alt="x, y"/></td>
<td>Position variable</td>
</tr>
</tbody>
</table>
<div class="section" id="cross-section-generation">
<h2>6.1. Cross Section Generation<a class="headerlink" href="#cross-section-generation" title="Permalink to this headline">¶</a></h2>
<p>The cross sections for the CMFD diffusion equation are generated by energy-condensation and area-averaging of the cross sections from the fine mesh as shown in <a href="#equation-xs-condensation">(2)</a>. The diffusion coefficient is computed by spatially condensing the flux-volume weighted transport cross section for an MOC group and then energy-condensing the diffusion coefficient for the CMFD cell. The energy group structure of the CMFD diffusion equation does not have to be the same as the energy group structure used in MOC. For example, <a class="reference internal" href="#figure-coarse-group-cmfd"><span>Figure 2</span></a> shows the various ways to formulate the CMFD group structure to accelerate a three group MOC problem.</p>
<p>The cross sections for the CMFD diffusion equation are generated by energy-condensation and area-averaging of the cross sections from the fine mesh as shown in equation <a href="#equation-xs-condensation">(2)</a>. The energy group structure of the CMFD diffusion equations does not have to be the same as the energy group structure used in MOC. For example, <a class="reference internal" href="#figure-coarse-group-cmfd"><span>Figure 2</span></a> shows the various ways to formulate the CMFD group structure to accelerate a three group MOC problem.</p>
<div class="align-center figure" id="id11">
<span id="figure-coarse-group-cmfd"></span><a class="reference internal image-reference" href="../_images/cmfd-gs.png"><img alt="../_images/cmfd-gs.png" src="../_images/cmfd-gs.png" style="width: 700px;" /></a>
<p class="caption"><span class="caption-text"><strong>Figure 2</strong>: Illustration of possible CMFD energy group structures for a three group MOC calculation.</span></p>
</div>
<p>where energy groups in MOC are denoted with <img class="math" src="../_images/math/67f4714f065d485540ad40829e0717bf75e9dd85.png" alt="g"/> and energy groups in CMFD are denoted with <img class="math" src="../_images/math/44cfef0a87943444f7d88fe77a9df36ba6986b11.png" alt="\mathbf{g}"/>. The generalized equations for computing cross sections on the coarse mesh are then described by <a href="#equation-xs-condensation">(2)</a>.</p>
<p><strong>Cross section condensation equations</strong></p>
<div class="math" id="equation-xs-condensation">
<p><span class="eqno">(2)</span><img src="../_images/math/181f05a4260167e582216efb267b0429b73d6536.png" alt="\varSigma^{A,i,j}_{\mathbf{g}} = \frac{\displaystyle\sum\limits_{g \in \mathbf{g}} \displaystyle\sum\limits_{r \in (i,j)} \Sigma^{A}_{r,g} \Phi_{r,g} A_r}{\displaystyle\sum\limits_{g \in \mathbf{g}} \displaystyle\sum\limits_{r \in (i,j)} \Phi_{r,g} A_r}"/></p>
</div><div class="math">
<p><img src="../_images/math/68f8c141fd87a49b34e6da0d1fa4774b2573dd36.png" alt="\varSigma^{F,i,j}_{\mathbf{g}} = \frac{\displaystyle\sum\limits_{g \in \mathbf{g}} \displaystyle\sum\limits_{r \in (i,j)} \Sigma^{F}_{r,g} \Phi_{r,g} A_r}{\displaystyle\sum\limits_{g \in \mathbf{g}} \displaystyle\sum\limits_{r \in (i,j)} \Phi_{r,g} A_r}"/></p>
</div><div class="math">
<p><img src="../_images/math/3762f6f6e66080ece2fb1fd4c584076885328481.png" alt="\nu \varSigma^{F,i,j}_{\mathbf{g}} = \frac{\displaystyle\sum\limits_{g \in \mathbf{g}} \displaystyle\sum\limits_{r \in (i,j)} \nu \Sigma^{F}_{r,g} \Phi_{r,g} A_r}{\displaystyle\sum\limits_{g \in \mathbf{g}} \displaystyle\sum\limits_{r \in (i,j)} \Phi_{r,g} A_r}"/></p>
</div><div class="math">
<p><img src="../_images/math/ff0e383d2d764cf1c42e3076b2b8a1b8446e6880.png" alt="\varSigma^{S,i,j}_{\mathbf{g} \rightarrow \mathbf{g} \prime} = \frac{\displaystyle\sum\limits_{g \in \mathbf{g}} \displaystyle\sum\limits_{g \prime \in \mathbf{g} \prime} \displaystyle\sum\limits_{r \in (i,j)} \Sigma^S_{r,g \rightarrow g \prime} \Phi_{r,g} A_r}{\displaystyle\sum\limits_{g \in \mathbf{g}} \displaystyle\sum\limits_{r \in (i,j)} \Phi_{r,g} A_r}"/></p>
</div><div class="math">
<p><img src="../_images/math/173ae7b82700ef64a8dd329cf1639ee63510e61a.png" alt="\varSigma^{tr,i,j}_{g} = \frac{\displaystyle\sum\limits_{r \in (i,j)} \Sigma^{tr}_{r,g} \Phi_{r,g} A_r}{\displaystyle\sum\limits_{r \in (i,j)} \Phi_{r,g} A_r}"/></p>
</div><div class="math">
<p><img src="../_images/math/30e5b3d81d0aed6b13f903bf7a66b2145b8e8693.png" alt="D_{\mathbf{g}}^{i,j} = \frac{\displaystyle\sum\limits_{g \in \mathbf{g}} \frac{1}{3 \Sigma^{tr,i,j}_{g}} \phi^{i,j}_{g}}{\phi^{i,j}_{\mathbf{g}}}"/></p>
</div><div class="math">
<p><img src="../_images/math/14a3cabce46bba27f36c649635949af28105f328.png" alt="\chi_{\mathbf{g}}^{i,j} = \frac{\displaystyle\sum\limits_{g \in \mathbf{g}} \displaystyle\sum\limits_{r \in (i,j)} \displaystyle\sum\limits_{g \prime = 1}^G \chi_{r,g} \nu \Sigma^F_{r,g \prime} \Phi_{r,g \prime} A_r}{\displaystyle\sum\limits_{r \in (i,j)} \displaystyle\sum\limits_{g \prime = 1}^G \displaystyle\sum\limits_{g \prime \prime = 1}^G \chi_{r,g \prime \prime} \nu \Sigma^{F}_{r,g \prime} \Phi_{r,g \prime} A_r}"/></p>
</div><div class="math">
<p><img src="../_images/math/24202b6f95767470e7c816a03e85191b2b57546a.png" alt="\phi_{g}^{i,j} = \frac{\displaystyle\sum\limits_{r \in (i,j)} \Phi_{r,g} A_r}{\displaystyle\sum\limits_{r \in (i,j)} A_r}"/></p>
</div><div class="math">
<p><img src="../_images/math/4363619cce2f21841c9be899cb090d330582a264.png" alt="\phi_{\mathbf{g}}^{i,j} = \displaystyle\sum\limits_{g \in \mathbf{g}} \phi_{g}^{i,j}"/></p>
</div><p>where <img class="math" src="../_images/math/a581f053bbfa5115f42c13094857cdd12a37ec49.png" alt="i"/> and <img class="math" src="../_images/math/d32c78b759903e3f4bd4fd2ce0b86358f7500c5d.png" alt="j"/> denote the mesh cell indices in the x and y directions, respectively.</p>
</div>
<div class="section" id="applying-the-finite-difference-approximation">
<h2>6.2. Applying the Finite Difference Approximation<a class="headerlink" href="#applying-the-finite-difference-approximation" title="Permalink to this headline">¶</a></h2>
<p>The diffusion operator in <a href="#equation-dif-eqn">(1)</a> can be expanded to yield:</p>
<div class="math" id="equation-dif-eqn-expand-1">
<p><span class="eqno">(3)</span><img src="../_images/math/1488858eee99a5c1214169f1f648e49cce540037.png" alt="- \frac{\partial}{\partial x} D_{\mathbf{g}} (x,y) \frac{\partial}{\partial x} \phi_{\mathbf{g}} (x,y) - \frac{\partial}{\partial y} D_{\mathbf{g}} (x,y) \frac{\partial}{\partial y} \phi_{\mathbf{g}} (x,y) + \varSigma^R_{\mathbf{g}} (x,y) \phi_{\mathbf{g}} (x,y) = \frac{\chi_{\mathbf{g}} (x,y)}{k_{eff}} \sum_{\mathbf{g} \prime = 1}^{\mathbf{G}} \nu \varSigma^F_{\mathbf{g} \prime} (x,y) \phi_{\mathbf{g} \prime} (x,y) + \sum_{\substack{\mathbf{g} \prime = 1 \\ \mathbf{g} \prime \neq \mathbf{g}}}^{\mathbf{G}} \varSigma^S_{\mathbf{g} \prime \rightarrow \mathbf{g}} (x,y) \phi_{\mathbf{g} \prime} (x,y)"/></p>
</div><p>where the removal cross section, <img class="math" src="../_images/math/bb90b2a18ccf22a15684cdecdba439548e36d8d8.png" alt="\varSigma^R_{\mathbf{g}}"/> is defined as:</p>
<div class="math" id="equation-emoval-xs">
<p><span class="eqno">(4)</span><img src="../_images/math/c4f01dd79d20c917f928a841abdc5be83a5e662f.png" alt="\varSigma^R_{\mathbf{g}} \equiv \varSigma^A_{\mathbf{g}} + \sum_{\substack{\mathbf{g} \prime = 1 \\ \mathbf{g} \prime \neq \mathbf{g}}}^{\mathbf{G}} \varSigma^S_{\mathbf{g} \rightarrow \mathbf{g} \prime}"/></p>
</div><p>In cases where axial buckling is specified the removal cross section takes the following form:</p>
<div class="math" id="equation-removal-xs-2">
<p><span class="eqno">(5)</span><img src="../_images/math/62628091375e64876df26acf602476ae2ee391a8.png" alt="\varSigma^R_{\mathbf{g}} \equiv D_{\mathbf{g}} B_z^2 + \varSigma^A_{\mathbf{g}} + \sum_{\substack{\mathbf{g} \prime = 1 \\ \mathbf{g} \prime \neq \mathbf{g}}}^{\mathbf{G}} \varSigma^S_{\mathbf{g} \rightarrow \mathbf{g} \prime}"/></p>
</div><p>We can integrate <a href="#equation-dif-eqn-expand-1">(3)</a> over a mesh cell to get the neutron balance in that cell. Performing the integration on cell <img class="math" src="../_images/math/0de78069ab15c688f6d8c6f59d5c5805bc969595.png" alt="(i,j)"/> and simplifying we get:</p>
<div class="math">
<p><img src="../_images/math/cc3c29764c592d6bb167621f682c23d0cbdd0c5b.png" alt="- \int_{i-\frac{1}{2}}^{i+\frac{1}{2}} \int_{j-\frac{1}{2}}^{j+\frac{1}{2}} \frac{\partial}{\partial x} D_{\mathbf{g}}^{i,j} \frac{\partial}{\partial x} \phi_{\mathbf{g}}^{i,j} dx dy - \int_{i-\frac{1}{2}}^{i+\frac{1}{2}} \int_{j-\frac{1}{2}}^{j+\frac{1}{2}} \frac{\partial}{\partial y} D_{\mathbf{g}}^{i,j} \frac{\partial}{\partial y} \phi_{\mathbf{g}}^{i,j} dx dy + \Delta x^{i,j} \Delta y^{i,j} \varSigma_{{\mathbf{g}}}^{R,i,j} \phi_{\mathbf{g}}^{i,j} = \Delta x^{i,j} \Delta y^{i,j} \frac{\chi_{\mathbf{g}}^{i,j}}{k_{eff}} \sum_{{\mathbf{g}} \prime = 1}^{\mathbf{G}} \nu \varSigma_{{\mathbf{g}} \prime}^{F,i,j} \phi_{{\mathbf{g}} \prime}^{i,j} + \Delta x^{i,j} \Delta y^{i,j} \sum_{\substack{{\mathbf{g}} \prime = 1 \\ {\mathbf{g}} \prime \neq {\mathbf{g}}}}^{\mathbf{G}} \varSigma_{{\mathbf{g}} \prime \rightarrow {\mathbf{g}}}^{S,i,j} \phi_{{\mathbf{g}} \prime}^{i,j}"/></p>
</div><p>Where <img class="math" src="../_images/math/d93d931755f8b8a8cd9535c1052422412b741fa3.png" alt="\Delta x^{i,j}"/> and <img class="math" src="../_images/math/e8db0b47139b43380e6d002f4eac0f38ec80da32.png" alt="\Delta y^{i,j}"/> denote the width and height of cell (i,j), respectively. Using the Divergence Theorem, we can reduce the volume integrals of the streaming terms to surface integrals over the bounding surfaces of a cell. The surface integrals will then represent currents across the surfaces of a cell. Using streaming in the x-direction as an example, we can rewrite the volume integral of the streaming term in the x-direction as:</p>
<div class="math">
<p><img src="../_images/math/f2bb99442fdde11e5de258fedd5f198d57a749ce.png" alt="- \int_{i-\frac{1}{2}}^{i+\frac{1}{2}} \int_{j-\frac{1}{2}}^{j+\frac{1}{2}} \frac{\partial}{\partial x} D_{\mathbf{g}}^{i,j} \frac{\partial}{\partial x} \phi_{\mathbf{g}}^{i,j} dx dy = \Delta y^{i,j} (J_{\mathbf{g}}^{i+\frac{1}{2},j} - J_{\mathbf{g}}^{i-\frac{1}{2},j})"/></p>
</div><p>Where <img class="math" src="../_images/math/8e8b79c790ce1bf4a61d5e511cbab3d9a2cc95cd.png" alt="J_{\mathbf{g}}^{i+\frac{1}{2},j}"/> and <img class="math" src="../_images/math/d983852c246172b42c82e6e21e7f4613381f9721.png" alt="J_{\mathbf{g}}^{i-\frac{1}{2},j}"/> represent the surface-averaged net current across the right surface and across the left surface, respectively. An analogous equation can be written for streaming in the y direction.</p>
<p>As an example, we will now solve for the currents on the right surface of a cell <img class="math" src="../_images/math/0de78069ab15c688f6d8c6f59d5c5805bc969595.png" alt="(i,j)"/> with neighboring cell <img class="math" src="../_images/math/aba4df335809e30b07e2fd080b75de86ba61ae4a.png" alt="(i + 1, j)"/> as illustrated in <a class="reference internal" href="#figure-cmfd-example"><span>Figure 3</span></a>.</p>
<div class="align-center figure" id="id12">
<span id="figure-cmfd-example"></span><a class="reference internal image-reference" href="../_images/cmfd-example.png"><img alt="../_images/cmfd-example.png" src="../_images/cmfd-example.png" style="width: 400px;" /></a>
<p class="caption"><span class="caption-text"><strong>Figure 3</strong>: Illustration of terms required to solve for streaming of neutrons from cell <img class="math" src="../_images/math/0de78069ab15c688f6d8c6f59d5c5805bc969595.png" alt="(i,j)"/> to <img class="math" src="../_images/math/5c499abe720985595fb76028f9130ee1b944e0c4.png" alt="(i+1,j)"/> in CMFD diffusion.</span></p>
</div>
<p>To solve for the current at cell boundaries, we can perform finite difference approximations of the flux at a surface using the flux in the adjacent cells:</p>
<div class="math">
<p><img src="../_images/math/b9c6d51f53e248fd75fb7f9b1703904196ff7a01.png" alt="J_{\mathbf{g}}^{i+\frac{1}{2},j,+} = \left. - D_{\mathbf{g}}^{i+1,j} \frac{d \phi_{\mathbf{g}}^{i+\frac{1}{2},j}}{d x} \right|_{x^{i+\frac{1}{2},j,+}} = - D_{\mathbf{g}}^{i+1,j} \frac{\phi_{\mathbf{g}}^{i+1,j} - \phi_{\mathbf{g}}^{i+\frac{1}{2},j}}{\frac{\Delta x^{i+1,j}}{2}}\\ \nonumber
J_{\mathbf{g}}^{i+\frac{1}{2},j,-} = \left. - D_{\mathbf{g}}^{i,j} \frac{d \phi_{\mathbf{g}}^{i+\frac{1}{2},j}}{d x} \right|_{x^{i+\frac{1}{2},j,-}} = - D_{\mathbf{g}}^{i,j} \frac{\phi_{\mathbf{g}}^{i+\frac{1}{2},j} - \phi_{\mathbf{g}}^{i,j}}{\frac{\Delta x^{i,j}}{2}}"/></p>
</div><p>Where <img class="math" src="../_images/math/75597ca13911c4d0e160d21c95a62de0495cfb65.png" alt="J_{\mathbf{g}}^{i+\frac{1}{2},j,+}"/> and <img class="math" src="../_images/math/67df6b481005cf2b42bf118eb8b11e40427ed149.png" alt="J_{\mathbf{g}}^{i+\frac{1}{2},j,-}"/> are the surface-averaged partial currents as approximated using a backward difference approximation from the cell at <img class="math" src="../_images/math/0de78069ab15c688f6d8c6f59d5c5805bc969595.png" alt="(i,j)"/> and a forward difference approximation from the cell at <img class="math" src="../_images/math/5c499abe720985595fb76028f9130ee1b944e0c4.png" alt="(i+1,j)"/>, respectively. Equating these representations of the current we can solve for the flux at the surface:</p>
<div class="math">
<p><img src="../_images/math/0a3c5cfbdb2c4562ef51af1048c006fea7a07bd9.png" alt="\phi_{\mathbf{g}}^{i+\frac{1}{2},j} = \frac{D_{\mathbf{g}}^{i,j} \phi_{\mathbf{g}}^{i,j} \Delta x^{i+1,j} + D_{\mathbf{g}}^{i+1,j} \phi_{\mathbf{g}}^{i+1,j} \Delta x^{i,j}}{D_{\mathbf{g}}^{i,j}\Delta x^{i+1,j} + D_{\mathbf{g}}^{i+1,j} \Delta x^{i,j}}"/></p>
</div><p>The net current across the surface at <img class="math" src="../_images/math/d7117315315c369332791ae00b5697f78695e6e7.png" alt="(i+\frac{1}{2},j)"/> is then:</p>
<div class="math" id="equation-eqn-alg-net-current">
<p><span class="eqno">(6)</span><img src="../_images/math/2c5546296d43cc5831b80e56ebc903cfd5c571d0.png" alt="J_{\mathbf{g}}^{i+\frac{1}{2},j} = - \hat{D}_{\mathbf{g}}^{i+\frac{1}{2},j} (\phi_{\mathbf{g}}^{i+1,j} - \phi_{\mathbf{g}}^{i,j})"/></p>
</div><p>Where:</p>
<div class="math" id="equation-eqn-surf-dif-coef">
<p><span class="eqno">(7)</span><img src="../_images/math/45c0caaa8277556767bf7c54a6200d27eff7696e.png" alt="\hat{D}_{\mathbf{g}}^{i+\frac{1}{2},j} = \frac{2 D_{\mathbf{g}}^{i,j} D_{\mathbf{g}}^{i+1,j}}{D_{\mathbf{g}}^{i,j} \Delta x^{i+1,j} + D_{\mathbf{g}}^{i+1,j} \Delta x^{i,j}}"/></p>
</div><p>The neutron balance equation in a cell then becomes:</p>
<div class="math" id="equation-eqn-dif-eqn-simple">
<p><span class="eqno">(8)</span><img src="../_images/math/831685a3b7345419ad2094a93ac6fd3442ff32e9.png" alt="\Delta y^{i,j} (J_{\mathbf{g}}^{i+\frac{1}{2},j} - J_{\mathbf{g}}^{i-\frac{1}{2},j}) + \Delta
 x^{i,j} (J_{\mathbf{g}}^{i,j+\frac{1}{2}} - J_{\mathbf{g}}^{i,j-\frac{1}{2}}) + \Delta x^{i,j}
 \Delta y^{i,j} \varSigma_{\mathbf{g}}^{R,i,j} \phi_{\mathbf{g}}^{i,j} = \Delta x^{i,j} \Delta y^{i,j} \frac{\chi_{\mathbf{g}}^{i,j}}{k_{eff}} \sum_{{\mathbf{g}} \prime = 1}^{\mathbf{G}} \nu \varSigma_{{\mathbf{g}} \prime}^{F,i,j} \phi_{{\mathbf{g}} \prime}^{i,j} + \Delta x^{i,j} \Delta y^{i,j} \sum_{\substack{{\mathbf{g}} \prime = 1 \\ {\mathbf{g}} \prime \neq {\mathbf{g}}}}^{\mathbf{G}} \varSigma_{{\mathbf{g}} \prime \rightarrow {\mathbf{g}}}^{S,i,j} \phi_{{\mathbf{g}} \prime}^{i,j}"/></p>
</div><p>Note that <a href="#equation-eqn-alg-net-current">(6)</a> is the algebraic net current based on the finite difference approximation being applied across the surface of two neighboring cells and not the actual net current in the MOC problem. The actual current from the MOC problem is computed by accumulating the current contribution from every segment that crosses a surface as will be shown in the <span class="xref std std-ref">Section 7.3</span>.</p>
</div>
<div class="section" id="introduction-to-nonlinear-diffusion-correction-factors">
<h2>6.3. Introduction to nonlinear diffusion correction factors<a class="headerlink" href="#introduction-to-nonlinear-diffusion-correction-factors" title="Permalink to this headline">¶</a></h2>
<p>In order to conserve neutron balance between the CMFD and MOC problems, the net currents across the coarse mesh cell surfaces must be equal. The surface diffusion coefficient expression in <a href="#equation-eqn-surf-dif-coef">(7)</a> results in a neutron current close to the actual current produced via the MOC solve, but there is no guarantee the currents will be equal. To compute the currents from MOC, the net currents are tallied during a transport sweep by summing the current contributions from each track that intersects a surface. For example, <a href="#equation-eqn-surf-avg-tallied-current">(9)</a> represents the net current tally expression for surface <img class="math" src="../_images/math/5bc814abd4e538491b79d9ce6c673bdd43c98ea3.png" alt="(i + \frac{1}{2}, j)"/>.</p>
<div class="math" id="equation-eqn-surf-avg-tallied-current">
<p><span class="eqno">(9)</span><img src="../_images/math/8df4ff6cfb75df45a84facabc9df720251bd7674.png" alt="\tilde{J}_{\mathbf{g}}^{i + \frac{1}{2}, j} = \sum_{k \cap (i+\frac{1}{2},j)} \sum_{g \in \mathbf{g}} 2 \pi \omega_{m(k)} \tilde{\omega}_k \omega_p \sin \theta_p \Psi_{k,g,p} \cdot \hat{n}"/></p>
</div><p>Where <img class="math" src="../_images/math/976c654a0f1ab8febd8371ae77e428960e8b4506.png" alt="\hat{n}"/> is the unit surface normal and <img class="math" src="../_images/math/9821160ac96e2802ee6011ed5b20462d5a4d7b5c.png" alt="\tilde{\omega}_k"/> is the length of surface crossed by the track, as illustrated in <a class="reference internal" href="#figure-current-tally"><span>Figure 4</span></a>. The first sum in <a href="#equation-eqn-surf-avg-tallied-current">(9)</a> is over all tracks that cross the surface between mesh cells <img class="math" src="../_images/math/0de78069ab15c688f6d8c6f59d5c5805bc969595.png" alt="(i,j)"/> and <img class="math" src="../_images/math/5c499abe720985595fb76028f9130ee1b944e0c4.png" alt="(i+1,j)"/>.</p>
<div class="align-center figure" id="id13">
<span id="figure-current-tally"></span><a class="reference internal image-reference" href="../_images/current-tally.png"><img alt="../_images/current-tally.png" src="../_images/current-tally.png" style="width: 400px;" /></a>
<p class="caption"><span class="caption-text"><strong>Figure 4</strong>: Angular flux from track <img class="math" src="../_images/math/e9203da50e1059455123460d4e716c9c7f440cc3.png" alt="k"/> with energy group <img class="math" src="../_images/math/67f4714f065d485540ad40829e0717bf75e9dd85.png" alt="g"/> and polar angle <img class="math" src="../_images/math/3eca8557203e86160952e1c0f735f7417f3285b1.png" alt="p"/> crossing surface <img class="math" src="../_images/math/bf9b1af4e59cb134363f04db675709ea357c2d69.png" alt="(i+\frac{1}{2}, j)"/>.</span></p>
</div>
<p>The length of surface crossed by the track is defined as:</p>
<div class="math" id="equation-eqn-surf-len-track">
<p><span class="eqno">(10)</span><img src="../_images/math/181daa53627472bfa95888f9d3923da97328e293.png" alt="\tilde{\omega}_k = \frac{\omega_k}{\cos \theta_k}"/></p>
</div><p>Inserting <a href="#equation-eqn-surf-len-track">(10)</a> into <a href="#equation-eqn-surf-avg-tallied-current">(9)</a> gives us:</p>
<div class="math" id="equation-eqn-surf-avg-tallied-current-2">
<p><span class="eqno">(11)</span><img src="../_images/math/af7ef16f8776c9d690f9f311866cdd768283b773.png" alt="\tilde{J}_{\mathbf{g}}^{i + \frac{1}{2}, j} = \sum_{k \cap (i+\frac{1}{2},j)} \sum_{g \in \mathbf{g}} 2 \pi \omega_{m(k)} \frac{\omega_k}{\cos \theta_k} \omega_p \sin \theta_p \Psi_{k,g,p} \cdot \hat{n}"/></p>
</div><p>When we apply the scalar product between the track azimuthal angle with the unit surface normal of the track, we get <img class="math" src="../_images/math/7377c92a8a44fc33492f92ff79389af59ece2a14.png" alt="\cos \theta_k"/>, which reduces <a href="#equation-eqn-surf-avg-tallied-current-2">(11)</a> to:</p>
<div class="math" id="equation-eqn-surf-avg-tallied-current-3">
<p><span class="eqno">(12)</span><img src="../_images/math/a12e96cdd1f22e0cf79d495f764e4190c377d9fc.png" alt="\tilde{J}_{\mathbf{g}}^{i + \frac{1}{2}, j} = \sum_{k \cap (i+\frac{1}{2},j)} \sum_{g \in \mathbf{g}} 2 \pi \omega_{m(k)} \omega_k \omega_p \sin \theta_p \Psi_{k,g,p}"/></p>
</div><p>In order for the tallied net currents to equal the net current expression, a nonlinear diffusion coefficient term is added to <a href="#equation-eqn-alg-net-current">(6)</a>:</p>
<div class="math" id="equation-eqn-alg-net-current-cor">
<p><span class="eqno">(13)</span><img src="../_images/math/693ce32fa215ec642d8ae9ffb00f16504add7fa3.png" alt="\frac{\tilde{J}_{\mathbf{g}}^{i+\frac{1}{2},j}}{\Delta y^{i,j}} = - \hat{D}_{\mathbf{g}}^{i+\frac{1}{2},j} (\phi_{\mathbf{g}}^{i+1,j} - \phi_{\mathbf{g}}^{i,j}) - \tilde{D}_{\mathbf{g}}^{i+\frac{1}{2},j} (\phi_{\mathbf{g}}^{i+1,j} + \phi_{\mathbf{g}}^{i,j})"/></p>
</div><p>Where <img class="math" src="../_images/math/a3d4cc4582dd91209821872a6202bdc448c2b21a.png" alt="\tilde{D}"/> is the nonlinear diffusion coefficient correction factor. Note that current expression on the right hand side of <a href="#equation-qn-alg-net-current-cor">(?)</a> computes the surface-averaged net current whereas the current tallied from MOC has not been averaged over the surface; therefore, in <a href="#equation-eqn-alg-net-current-cor">(13)</a> the net current tallied from MOC has been divided by the length of the surface that is being crossed. <img class="math" src="../_images/math/a3d4cc4582dd91209821872a6202bdc448c2b21a.png" alt="\tilde{D}"/> is computed to make <a href="#equation-eqn-alg-net-current-cor">(13)</a> valid for the tallied net surface current in MOC for the most recent transport sweep:</p>
<div class="math" id="equation-eqn-dif-cor-factor">
<p><span class="eqno">(14)</span><img src="../_images/math/863b7b8954e5958c147e847c33b1ab2da2b7f80f.png" alt="\tilde{D}_{\mathbf{g}}^{i+\frac{1}{2},j} = \frac{- \hat{D}_{\mathbf{g}}^{i+\frac{1}{2},j} (\phi_{\mathbf{g}}^{i+1,j} - \phi_{\mathbf{g}}^{i,j}) - \frac{\tilde{J}_{\mathbf{g}}^{i+\frac{1}{2},j}}{\Delta y^{i,j}}}{(\phi_{\mathbf{g}}^{i+1,j} + \phi_{\mathbf{g}}^{i,j})}"/></p>
</div></div>
<div class="section" id="treatment-of-optically-thick-regions">
<span id="optically-thick"></span><h2>6.4. Treatment of optically thick regions<a class="headerlink" href="#treatment-of-optically-thick-regions" title="Permalink to this headline">¶</a></h2>
<p>As shown in <a class="reference internal" href="#figure-fsr-mesh-regions"><span>Figure 1</span></a> the CMFD mesh is often applied at the pin cell level with cells on the order of 1-2 cm. By conserving reaction and leakage rates within cells, CMFD guarantees preservation of area-averaged scalar fluxes and net surface currents from the MOC fixed source iteration if the CMFD equations can be converged. However, when the fine mesh cell size becomes significantly larger than the neutron mean free path in that cell, the step characteristics no longer preserve the linear infinite medium solution to the transport equation <a class="reference internal" href="#larsen" id="id9">[Larsen]</a>. While the nonlinear diffusion correction term in CMFD is guaranteed to preserve reaction rates and surface net currents for any choice of diffusion coefficient, convergence (and convergence rate) of the nonlinear iteration acceleration of CMFD is affected by the choice of diffusion coefficient. All flat source methods, when applied for thick optical meshes, artificially distribute neutrons in space. This is the reason that Larsen&#8217;s effective diffusion coefficient is useful in assuring that the CMFD acceleration equations have a diffusion coefficient (on the flux gradient term) that is consistent, not with the physical transport problem, but with the transport problem that is being accelerated by the CMFD equations. Larsen&#8217;s effective diffusion coefficient is precisely this term in the one-dimensional limit. The effective diffusion coefficient in the x-direction for cell <img class="math" src="../_images/math/0de78069ab15c688f6d8c6f59d5c5805bc969595.png" alt="(i,j)"/> can be expressed as:</p>
<div class="math" id="equation-eqn-optic-thick-d">
<p><span class="eqno">(15)</span><img src="../_images/math/e01076042641e93504180ac735fea5760beeaebe.png" alt="D_{\mathbf{g}}^{i,j,eff,x} = D_{\mathbf{g}}^{i,j} \bigg(1 + \frac{\Delta x^{i,j} \rho_{\mathbf{g}}^{i,j,x}}{2 D_{\mathbf{g}}^{i,j}} \bigg) \\
 \rho_{\mathbf{g}}^{i,j,x} = \frac{\displaystyle\sum\limits_{p = 1}^P \cos (\theta_p) \omega_p \alpha_{{\mathbf{g}},p}^{i,j,x}}{\displaystyle\sum\limits_{p = 1}^{P} \omega_p} \\
 \alpha_{{\mathbf{g}},p}^{i,j,x} = \left( \frac{1 + exp[-\gamma^{i,j,x}_{\mathbf{g},p}]}{1 - exp[-\gamma^{i,j,x}_{\mathbf{g},p}]} \right) - \frac{2}{\gamma^{i,j,x}_{\mathbf{g},p}} \\
 \gamma^{i,j,x}_{\mathbf{g},p} = \frac{\Delta x^{i,j}}{3 D_{\mathbf{g}}^{i,j} \cos (\theta_p)}"/></p>
</div><p>Note that the effective diffusion coefficient depends on the width of the cell and is therefore directional in a 2D mesh. <a href="#equation-eqn-optic-thick-d">(15)</a> can also be used to compute the effective diffusion coefficient in the y-direction, which will differ from the effective diffusion coefficient in the x-direction if the cell is not square. As the size of the cell approaches zero and the optical thickness of the cell approaches the optically thin limit, the effective diffusion coefficient will approach the material diffusion coefficient. For simplicity, we continue to use the surface diffusion coefficient terms in the rest of this thesis without the &#8220;eff&#8221; superscript.</p>
</div>
<div class="section" id="treatment-of-coarse-mesh-cell-corner-crossings">
<h2>6.5. Treatment of coarse mesh cell corner crossings<a class="headerlink" href="#treatment-of-coarse-mesh-cell-corner-crossings" title="Permalink to this headline">¶</a></h2>
<p>In the CMFD formalism introduced in the previous sections, we only treat transport to adjacent cells. However, MOC produces tracks that directly and indirectly intersect mesh cell corners. A direct crossing is defined as a crossing where the centerline of a track directly intersects a mesh cell corner. An indirect crossing is defined as a crossing where the track sweeps through a corner but the track centerline does not directly cross through it. Illustrations of these two crossing types are shown in <a class="reference internal" href="#figure-corner-crossing"><span>Figure 5</span></a>.</p>
<div class="align-center figure" id="id14">
<span id="figure-corner-crossing"></span><a class="reference internal image-reference" href="../_images/corner-crossing.png"><img alt="../_images/corner-crossing.png" src="../_images/corner-crossing.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><strong>Figure 5</strong>: Illustration of direct (1) and indirect (2) track corner crossings.</span></p>
</div>
<p>There are three main approximations to treat corner crossings:</p>
<ol class="arabic simple">
<li>Consistently tallying the current from direct corner crossings to only one of the surfaces. This approximation effectively moves the tracks that directly cross through a corner far enough to one side such that the entire segment crosses a single surface. In order to maintain neutron balance, tracks must be consistently moved to the same side for tracking forward and backwards along a track. Indirect crossings are ignored.</li>
<li>Split the current from direct corner crossings to each of the neighboring surfaces. This approximation effectively splits the track into two half-weighted segments and moves them to either side of the corner such that each new half-weighted track only sweeps across one surface. Indirect crossings are ignored. This is essentially a special case of approximation 3 where only direct crossings are treated.</li>
<li>Split the current from direct and indirect corner crossings to each of the neighboring surfaces and weight the current contribution to each surface based on the length of surfaces swept through by the track.</li>
</ol>
<p>Note that tracks are not physically moved in any of these cases; rather, we make the assumption that they are moved when we tally the surface currents. In OpenMOC we have implemented approximation 2 where only direct corner crossings are treated; indirect crossings are tallied only on the surface that is directly crossed by a track. While applying approximation 3 would be more accurate, this would incur additional storage requirements as each segment that crosses a surface needs to know which surface(s) it crosses and a weight for splitting the current contribution to each surface crossed. Illustrations of the approximations applied to direct and indirect surface crossings are illustrated in <a class="reference internal" href="#figure-corner-crossing-2"><span>Figure 6</span></a>.</p>
<div class="align-center figure" id="id15">
<span id="figure-corner-crossing-2"></span><a class="reference internal image-reference" href="../_images/corner-crossing-2.png"><img alt="../_images/corner-crossing-2.png" src="../_images/corner-crossing-2.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><strong>Figure 6</strong>: Illustration of approximations applied to direct (above) and indirect (below) corner crossings. The approximation applied is denoted by the number in the circle. The blue dashed lines bound the track sweeping area and the red dashed lines separate partially weighted tracks.</span></p>
</div>
<p>The tallies for a track that crosses from cell <img class="math" src="../_images/math/0de78069ab15c688f6d8c6f59d5c5805bc969595.png" alt="(i,j)"/> to <img class="math" src="../_images/math/90c8f351a989246ad7aaf6359ae26115467a3983.png" alt="(i+1,j+1)"/> with approximation 1 include a tally on the surface between cell <img class="math" src="../_images/math/0de78069ab15c688f6d8c6f59d5c5805bc969595.png" alt="(i,j)"/> to <img class="math" src="../_images/math/5c499abe720985595fb76028f9130ee1b944e0c4.png" alt="(i+1,j)"/> and on the surface between cells <img class="math" src="../_images/math/5c499abe720985595fb76028f9130ee1b944e0c4.png" alt="(i+1,j)"/> to <img class="math" src="../_images/math/90c8f351a989246ad7aaf6359ae26115467a3983.png" alt="(i+1,j+1)"/>. The current must be tallied on the second surface in order to preserve neutron balance ensure that neutrons traveling on the track get transferred from cell <img class="math" src="../_images/math/0de78069ab15c688f6d8c6f59d5c5805bc969595.png" alt="(i,j)"/> to <img class="math" src="../_images/math/90c8f351a989246ad7aaf6359ae26115467a3983.png" alt="(i+1,j+1)"/>. It is also important that the track be assigned to the same surface for both forward and reverse tracking.</p>
<p>The tallies with approximation 2 are simply half-weighted tallies for tracks that pass on either side of the corner:</p>
<div class="math" id="equation-eqn-corner-crossing">
<p><span class="eqno">(16)</span><img src="../_images/math/dcae623c6256c4a4b17929184a06bf8f74c8c886.png" alt="\tilde{J}_{\mathbf{g}}^{i + \frac{1}{2},j} += \frac{1}{2} \sum_{k \cap (i+\frac{1}{2},j+\frac{1}{2})} \sum_{g \in \mathbf{g}} \epsilon_{k,g,p} \\
 \tilde{J}_{\mathbf{g}}^{i,j + \frac{1}{2}} += \frac{1}{2} \sum_{k \cap (i+\frac{1}{2},j+\frac{1}{2})} \sum_{g \in \mathbf{g}} \epsilon_{k,g,p} \\
 \tilde{J}_{\mathbf{g}}^{i + 1, j + \frac{1}{2}} += \frac{1}{2} \sum_{k \cap (i+\frac{1}{2},j+\frac{1}{2})} \sum_{g \in \mathbf{g}} \epsilon_{k,g,p} \\
 \tilde{J}_{\mathbf{g}}^{i + \frac{1}{2}, j + 1} += \frac{1}{2} \sum_{k \cap (i+\frac{1}{2},j+\frac{1}{2})} \sum_{g \in \mathbf{g}} \epsilon_{k,g,p}"/></p>
</div><p>where:</p>
<div class="math" id="equation-eqn-corner-tally-flux">
<p><span class="eqno">(17)</span><img src="../_images/math/f1229dcc11988683b8850729d13449c13dbd8373.png" alt="\epsilon_{k,g,p} = 2 \pi \omega_{m(k)} \omega_k \omega_p \sin \theta_p \Psi_{k,g,p}"/></p>
</div><p>The first summation in <a href="#equation-eqn-corner-crossing">(16)</a> is over the tracks that directly cross through corner <img class="math" src="../_images/math/0b06a8ac9d3b33c9347f2f29542e54e9914bc192.png" alt="(i+\frac{1}{2},j+\frac{1}{2})"/>. Like the tallies in approximation 1, the tallies used in approximation 2 include tallies for the surface of the adjacent cell to the diagonal cell. The tallies with approximation 3 are slightly more complicated as they include the position at which the track crosses the surface and the position of the corner. Let&#8217;s assume that a track crosses the surface between cells <img class="math" src="../_images/math/0de78069ab15c688f6d8c6f59d5c5805bc969595.png" alt="(i,j)"/> and cell <img class="math" src="../_images/math/5c499abe720985595fb76028f9130ee1b944e0c4.png" alt="(i+1,j)"/> at point <img class="math" src="../_images/math/8b116f726883281383d266751cf40e6dc82f49a1.png" alt="(x_k, y_k)"/> and the corner of interest is at point <img class="math" src="../_images/math/f0ca8089d329fa120d5bad175531e981c17461a6.png" alt="(x_{i+\frac{1}{2}}, y_{j+\frac{1}{2}})"/> as shown in <a class="reference internal" href="#figure-corner-crossing-3"><span>Figure 7</span></a>.</p>
<div class="align-center figure" id="id16">
<span id="figure-corner-crossing-3"></span><a class="reference internal image-reference" href="../_images/corner-crossing-3.png"><img alt="../_images/corner-crossing-3.png" src="../_images/corner-crossing-3.png" style="width: 500px;" /></a>
<p class="caption"><span class="caption-text"><strong>Figure 7</strong>: Illustration of an indirect corner crossing with labeled surface intersections and corner point.</span></p>
</div>
<p>The tallies for tracks that directly or indirectly intersect the corner illustrated in <a class="reference internal" href="#figure-corner-crossing-3"><span>Figure 7</span></a> and described in <a href="#equation-eqn-corner-crossing-3">(18)</a>.</p>
<div class="math" id="equation-eqn-corner-crossing-3">
<p><span class="eqno">(18)</span><img src="../_images/math/7a8939f738551d1fce74653bd48198f24f091c5a.png" alt="\tilde{J}_{\mathbf{g}}^{i + \frac{1}{2},j} += \sum_{k \cap (i+\frac{1}{2},j+\frac{1}{2})} \sum_{g \in \mathbf{g}} \bigg(0.5 - \frac{\sqrt{(x_{k} - x_{i+\frac{1}{2}})^2}}{\tilde{\omega_k}} + \frac{\sqrt{(y_{k} - y_{j+\frac{1}{2}})^2}}{\tilde{\omega_k}}\bigg) \epsilon_{k,g,p} \\
 \tilde{J}_{\mathbf{g}}^{i,j + \frac{1}{2}} += \sum_{k \cap (i+\frac{1}{2},j+\frac{1}{2})} \sum_{g \in \mathbf{g}} \bigg(0.5 + \frac{\sqrt{(x_{k} - x_{i+\frac{1}{2}})^2}}{\tilde{\omega_k}} - \frac{\sqrt{(y_{k} - y_{j+\frac{1}{2}})^2}}{\tilde{\omega_k}}\bigg) \epsilon_{k,g,p} \\
 \tilde{J}_{\mathbf{g}}^{i + 1, j + \frac{1}{2}} += \sum_{k \cap (i+\frac{1}{2},j+\frac{1}{2})} \sum_{g \in \mathbf{g}} \bigg(0.5 - \frac{\sqrt{(x_{k} - x_{i+\frac{1}{2}})^2}}{\tilde{\omega_k}} + \frac{\sqrt{(y_{k} - y_{j+\frac{1}{2}})^2}}{\tilde{\omega_k}}\bigg) \epsilon_{k,g,p} \\
 \tilde{J}_{\mathbf{g}}^{i + \frac{1}{2}, j + 1} += \sum_{k \cap (i+\frac{1}{2},j+\frac{1}{2})} \sum_{g \in \mathbf{g}} \bigg(0.5 + \frac{\sqrt{(x_{k} - x_{i+\frac{1}{2}})^2}}{\tilde{\omega_k}} - \frac{\sqrt{(y_{k} - y_{j+\frac{1}{2}})^2}}{\tilde{\omega_k}}\bigg) \epsilon_{k,g,p}"/></p>
</div><p>where the summation is over the tracks that directly and indirectly cross through corner <img class="math" src="../_images/math/0b06a8ac9d3b33c9347f2f29542e54e9914bc192.png" alt="(i+\frac{1}{2},j+\frac{1}{2})"/>. All other surface crossings are treated with <a href="#equation-eqn-surf-avg-tallied-current-3">(12)</a>.</p>
</div>
<div class="section" id="matrix-form-of-cmfd-method">
<span id="cmfd-matrix-form"></span><h2>6.6. Matrix form of CMFD method<a class="headerlink" href="#matrix-form-of-cmfd-method" title="Permalink to this headline">¶</a></h2>
<p>Going back to <a href="#equation-eqn-dif-eqn-simple">(8)</a> and inserting the nonlinear diffusion coefficients from <a href="#equation-eqn-dif-cor-factor">(14)</a>, the finite difference form of the diffusion equation over a mesh cell becomes:</p>
<div class="math" id="equation-eqn-dif-matrix-1">
<p><span class="eqno">(19)</span><img src="../_images/math/4bb687c04330fd739ffd7d5f3c2ae8920aaa85c5.png" alt="\Delta y^{i,j} (\hat{D}_{\mathbf{g}}^{i-\frac{1}{2},j} [\phi_{\mathbf{g}}^{i,j} - \phi_{\mathbf{g}}^{i-1,j}] + \tilde{D}_{\mathbf{g}}^{i-\frac{1}{2},j} [\phi_{\mathbf{g}}^{i,j} + \phi_{\mathbf{g}}^{i-1,j}]) - \Delta y^{i,j} (\hat{D}_{\mathbf{g}}^{i+\frac{1}{2},j} [\phi_{\mathbf{g}}^{i+1,j} - \phi_{\mathbf{g}}^{i,j}] + \tilde{D}_{\mathbf{g}}^{i+\frac{1}{2},j} [\phi_{\mathbf{g}}^{i+1,j} + \phi_{\mathbf{g}}^{i,j}]) + \Delta x^{i,j} (\hat{D}_{\mathbf{g}}^{i,j-\frac{1}{2}} [\phi_{\mathbf{g}}^{i,j} - \phi_{\mathbf{g}}^{i,j-1}] + \tilde{D}_{\mathbf{g}}^{i,j-\frac{1}{2}} [\phi_{\mathbf{g}}^{i,j} + \phi_{\mathbf{g}}^{i,j-1}]) - \\
 \Delta x^{i,j} (\hat{D}_{\mathbf{g}}^{i,j+\frac{1}{2}} [\phi_{\mathbf{g}}^{i,j+1} - \phi_{\mathbf{g}}^{i,j}] + \tilde{D}_{\mathbf{g}}^{i,j+\frac{1}{2}} [\phi_{\mathbf{g}}^{i,j+1} + \phi_{\mathbf{g}}^{i,j}]) + \Delta x^{i,j} \Delta y^{i,j} \varSigma_{\mathbf{g}}^{R,i,j} \phi_{\mathbf{g}}^{i,j} = \Delta x^{i,j} \Delta y^{i,j} \frac{\chi_{\mathbf{g}}^{i,j}}{k_{eff}} \sum_{{\mathbf{g}} \prime = 1}^{\mathbf{G}} \nu \varSigma_{{\mathbf{g}} \prime}^{F,i,j} \phi_{{\mathbf{g}} \prime}^{i,j} + \Delta x^{i,j} \Delta y^{i,j} \sum_{\substack{{\mathbf{g}} \prime = 1 \\ {\mathbf{g}} \prime \neq {\mathbf{g}}}}^{\mathbf{G}} \varSigma_{{\mathbf{g}} \prime \rightarrow {\mathbf{g}}}^{S,i,j} \phi_{{\mathbf{g}} \prime}^{i,j}"/></p>
</div><p>We can condense the CMFD diffusion equations down to matrix form to get the following generalized non-hermitian eigenvalue problem:</p>
<div class="math" id="equation-eqn-dif-matrix-1">
<p><span class="eqno">(20)</span><img src="../_images/math/ce3759cd9e839a2a1b9320917f2449cd0768a976.png" alt="A \phi = \frac{1}{k_{eff}} M \phi"/></p>
</div><p>The matrices can be arranged in either a group-wise or cell-wise ordering. The CMFD implementation in OpenMOC uses a cell-wise order where the A matrix is composed of a block diagonal with blocks of size G x G and four off-diagonals for transport to neighboring cells as shown in <a class="reference internal" href="#figure-cmfd-matrix"><span>Figure 8</span></a>.</p>
<div class="align-center figure" id="id17">
<span id="figure-cmfd-matrix"></span><a class="reference internal image-reference" href="../_images/cmfd-matrix.png"><img alt="../_images/cmfd-matrix.png" src="../_images/cmfd-matrix.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><strong>Figure 8</strong>: CMFD mesh layout (left) and spy of CMFD A matrix (right) for a 4 x 4 infinite lattice pin-cell problem with 7 energy group cross sections.</span></p>
</div>
<p>In <a class="reference internal" href="#cmfd-accel-moc"><span>Section 7.7</span></a> we discuss how this matrix equation will be solved and used to accelerate the solution of the MOC solve.</p>
</div>
<div class="section" id="cmfd-accelerated-moc-algorithm">
<span id="cmfd-accel-moc"></span><h2>6.7. CMFD Accelerated MOC Algorithm<a class="headerlink" href="#cmfd-accelerated-moc-algorithm" title="Permalink to this headline">¶</a></h2>
<p>The general flowchart for MOC algorithm and CMFD acceleration are shown in <a class="reference internal" href="#figure-cmfd-accel-moc"><span>Figure 6</span></a>.</p>
<div class="align-center figure" id="id18">
<span id="figure-cmfd-accel-moc"></span><a class="reference internal image-reference" href="../_images/cmfd-accel-moc.png"><img alt="../_images/cmfd-accel-moc.png" src="../_images/cmfd-accel-moc.png" style="width: 600px;" /></a>
<p class="caption"><span class="caption-text"><strong>Figure 6</strong>: The solution procedure for CMFD accelerated MOC.</span></p>
</div>
<p>CMFD acceleration is implemented in OpenMOC by overlaying a regular grid on top of the unstructured flat source region mesh as shown in <a class="reference internal" href="#figure-fsr-mesh-regions"><span>Figure 1</span></a>. During an MOC fixed source iteration, OpenMOC tallies the net currents across the surfaces of each mesh cell. The fixed source iteration algorithm then becomes <a class="reference internal" href="#alg-transport-sweep-cmfd"><span>Algorithm 1</span></a>.</p>
<div class="align-center figure" id="id19">
<span id="alg-transport-sweep-cmfd"></span><a class="reference internal image-reference" href="../_images/cmfd-accel-alg-2.png"><img alt="../_images/cmfd-accel-alg-2.png" src="../_images/cmfd-accel-alg-2.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><strong>Algorithm 1</strong>: Fixed source iteration for CMFD accelerated OpenMOC.</span></p>
</div>
<p>At the end of the fixed source iteration, OpenMOC proceeds to condense the cross sections, flux, and diffusion coefficients according to <a href="#equation-xs-condensation">(2)</a>. The diffusion coefficient coupling terms that link neighboring cells, <img class="math" src="../_images/math/c94b09a31653be0f157d4c79bc366d78cbf39c0b.png" alt="\hat{D}"/> and <img class="math" src="../_images/math/a3d4cc4582dd91209821872a6202bdc448c2b21a.png" alt="\tilde{D}"/>, are then computed using <a href="#equation-eqn-surf-dif-coef">(7)</a> and <a href="#equation-eqn-dif-cor-factor">(14)</a>. There are two subtle points in computing the nonlinear coupling coefficients <img class="math" src="../_images/math/a3d4cc4582dd91209821872a6202bdc448c2b21a.png" alt="\tilde{D}"/>. First, the condition <img class="math" src="../_images/math/35f948ef723530b30d8568ee978a2b816f7ee610.png" alt="|\tilde{D}| &lt; |\hat{D}|"/> must be met in order to guarantee the diagonal dominance in the destruction matrix, A. If this condition is not met, the surface diffusion coefficients will be re-computed such that they are equal in magnitude and satisfy <a href="#equation-eqn-alg-net-current-cor">(13)</a>. Secondly, under-relaxation of the nonlinear correction factor is used to accelerate and maintain stability of the eigenvalue convergence rate for large, heterogeneous geometries. OpenMOC does so by applying a fixed damping factor on the <img class="math" src="../_images/math/a3d4cc4582dd91209821872a6202bdc448c2b21a.png" alt="\tilde{D}"/> terms. The nonlinear diffusion coefficients are initially set to zero and modified according to <a href="#equation-eqn-nldif-damp">(21)</a>.</p>
<div class="math" id="equation-eqn-nldif-damp">
<p><span class="eqno">(21)</span><img src="../_images/math/097b65c08158260ff24e4ce9870bbab20e4d3b93.png" alt="\tilde{D}^{i+\frac{1}{2},j,(n)}_{\mathbf{g}} = (1 - \omega_d) \tilde{D}^{i+\frac{1}{2},j,(n-1)}_{\mathbf{g}} + \omega_d \frac{- \hat{D}^{i+\frac{1}{2},j,(n)}_{\mathbf{g}} (\phi^{i+1,j,(n)}_{\mathbf{g}} - \phi^{i,j,(n)}_{\mathbf{g}}) - \frac{\tilde{J}_{\mathbf{g}}^{i+\frac{1}{2},j,(n)}}{\Delta y^{i,j}}}{(\phi_{\mathbf{g}}^{i+1,j,(n)} + \phi^{i,j,(n)}_{\mathbf{g}})}"/></p>
</div><p>Where <img class="math" src="../_images/math/4a6ac24dcdc06a617f0c4c875f4e56743b97c9aa.png" alt="\omega_d"/> is the under-relaxation dampening factor and <img class="math" src="../_images/math/e677529e38c70ecf5282bd82ea06669c913e8a5a.png" alt="(n)"/> is the fixed source iteration. OpenMOC uses power iterations to solve the generalized non-Hermitian eigenvalue problem as shown in <a class="reference internal" href="#alg-cmfd-solve"><span>Algorithm 2</span></a>. In each power iteration, the linear system is solved using a parallel (red-black) implementation of the successive over-relaxation method as shown in <a class="reference internal" href="#alg-sor-solve"><span>Figure 9</span></a>. Upon convergence of the CMFD diffusion problem, OpenMOC performs prolongation by multiplying each FSR&#8217;s scalar flux by the ratio of the converged coarse mesh scalar flux to the initial coarse mesh scalar flux in the acceleration step:</p>
<div class="math" id="equation-eqn-cmfd-prolongation">
<p><span class="eqno">(22)</span><img src="../_images/math/1adf05943a8510039addfccb429bde54d2965b2f.png" alt="\Phi_{r,g} = \Phi_{r,g} \frac{\phi^{i,j,new}_{\mathbf{g}}}{\phi^{i,j,old}_{\mathbf{g}}}  \qquad \forall \quad r \in (i,j)"/></p>
</div><p>where <img class="math" src="../_images/math/4d6df7b912395d5ddac09db5a76e0ff893bcbd81.png" alt="\phi^{i,j,old}_{\mathbf{g}}"/> is the coarse mesh scalar flux computed using equation <a href="#equation-xs-condensation">(2)</a> and <img class="math" src="../_images/math/f8cc3d9da978dc18596d60df64bb927ccd9f3210.png" alt="\phi^{i,j,new}_{\mathbf{g}}"/> is the converged CMFD coarse mesh scalar flux.</p>
<div class="align-center figure" id="id20">
<span id="alg-cmfd-solve"></span><a class="reference internal image-reference" href="../_images/cmfd-solve-alg.png"><img alt="../_images/cmfd-solve-alg.png" src="../_images/cmfd-solve-alg.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><strong>Algorithm 2</strong>: Power Iteration Outer Loop Source Iteration.</span></p>
</div>
<p>Instead of splitting the corner currents during the MOC fixed source iteration, OpenMOC tallies the corner currents as independent surfaces and then splits the corner currents between their neighboring surfaces in step 2 of <a class="reference internal" href="#alg-cmfd-solve"><span>Figure 8</span></a>. With the corner currents accounted for, the surface diffusion coefficients are then computed just prior to the power method eigenvalue solve. The first step in the power method inner loop iteration is to solve a linear fixed fission source problem. The SOR method is used to solve the linear system with the SOR relaxation factor denoted as <img class="math" src="../_images/math/2a06d898b7c944be04bb32b7dc3a6ca1fb1473e4.png" alt="\omega_r"/> as described by <a class="reference internal" href="#alg-sor-solve"><span>Figure 9</span></a>. While more computationally efficient methods exist for solving generalized non-Hermitian eigenvalue problems like Krylov-subspace methods, we chose the power method for its simplicity and stability. Additionally, more computationally efficient methods exist for solving the linear system like Generalized Minimum Residual (GMRES) and stabilized biconjugate gradient (BiCGStab), but these methods are conceptually more challenging and difficult to implement. In our analysis we found the power method with SOR performs sufficiently well for most problems that will be studied.</p>
<div class="align-center figure" id="id21">
<span id="alg-sor-solve"></span><a class="reference internal image-reference" href="../_images/cmfd-SOR-solve.png"><img alt="../_images/cmfd-SOR-solve.png" src="../_images/cmfd-SOR-solve.png" style="width: 800px;" /></a>
<p class="caption"><span class="caption-text"><strong>Figure 9</strong>: Successive over-relaxation numerical flux inversion.</span></p>
</div>
</div>
<div class="section" id="references">
<h2>6.8. References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<table class="docutils citation" frame="void" id="smith-1983" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[Smith-1983]</a></td><td><ol class="first last upperalpha simple" start="11">
<li>Smith, &#8220;Nodal Method Storage Reduction by Non-linear Iteration.&#8221; <em>Transactions of the American Nuclear Society</em>, <strong>44</strong>, (1983).</li>
</ol>
</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="yamamoto-2002" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[Yamamoto-2002]</a></td><td><ol class="first last upperalpha simple">
<li>Yamamoto, &#8220;Cell Based CMFD Formulation for Acceleration of Whole-Core Method of Characteristics Calculations.&#8221; <em>Journal of the Korean Nuclear Society</em>, <strong>34</strong>, pp. 250-258 (2002).</li>
</ol>
</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="yamamoto-2005" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[Yamamoto-2005]</a></td><td><ol class="first last upperalpha simple">
<li>Yamamoto, &#8220;Generalized Coarse-Mesh Rebalance Method for Acceleration of Neutron Transport Calculations.&#8221; <em>Journal of Nuclear Science and Engineering</em>, <strong>151</strong>, pp. 274-281 (2005).</li>
</ol>
</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="yamamoto-2008" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[Yamamoto-2008]</a></td><td><ol class="first last upperalpha simple">
<li>Yamamoto, &#8220;Implementation of Two-Level Coarse Mesh Finite Difference Acceleration in an Arbitrary Geometry, Two-Dimensional Discrete Ordinates Transport Method.&#8221; <em>Journal of Nuclear Science and Engineering</em>, <strong>158</strong>, pp. 289-298 (2008).</li>
</ol>
</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="lewis" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[Lewis]</a></td><td><ol class="first last upperalpha simple" start="5">
<li>Lewis and W. Miller, Jr., &#8220;Computational Methods of Neutron Transport.&#8221; <em>John Wiley &amp; Sons</em> (1984).</li>
</ol>
</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="li" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[Li]</a></td><td><ol class="first last upperalpha simple" start="12">
<li>Li, &#8220;A Low Order Acceleration Scheme for Solving the Neutron Transport Equation.&#8221; M.S. Thesis, Massachusetts Institute of Technology (2013).</li>
</ol>
</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="smith-2002" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[Smith-2002]</a></td><td><ol class="first last upperalpha simple" start="11">
<li>Smith and J. D. Rhodes, &#8220;Full-Core, 2-D, LWR Core Calculations with CASMO-4E.&#8221; <em>Proceedings of PHYSOR</em>, Seoul, South Korea (2002).</li>
</ol>
</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="larsen" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[Larsen]</a></td><td><ol class="first last upperalpha simple" start="5">
<li>Larsen, &#8220;Infinite Medium Solutions to the Transport Equation, <img class="math" src="../_images/math/f39351eac08bf9287632cba622eedb8e7e8c56ad.png" alt="S_n"/> Discretization Schemes, and the Diffusion Approximation. &#8221; <em>Proceedings of the Joint International Topical Meeting on Mathematics and Computation and Supercomputing in Nuclear Applications</em>, Salt Lake City, UT, USA (2001).</li>
</ol>
</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/openmoc-logo-sphinx-small.png" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">6. Coarse Mesh Finite Difference Acceleration</a><ul>
<li><a class="reference internal" href="#cross-section-generation">6.1. Cross Section Generation</a></li>
<li><a class="reference internal" href="#applying-the-finite-difference-approximation">6.2. Applying the Finite Difference Approximation</a></li>
<li><a class="reference internal" href="#introduction-to-nonlinear-diffusion-correction-factors">6.3. Introduction to nonlinear diffusion correction factors</a></li>
<li><a class="reference internal" href="#treatment-of-optically-thick-regions">6.4. Treatment of optically thick regions</a></li>
<li><a class="reference internal" href="#treatment-of-coarse-mesh-cell-corner-crossings">6.5. Treatment of coarse mesh cell corner crossings</a></li>
<li><a class="reference internal" href="#matrix-form-of-cmfd-method">6.6. Matrix form of CMFD method</a></li>
<li><a class="reference internal" href="#cmfd-accelerated-moc-algorithm">6.7. CMFD Accelerated MOC Algorithm</a></li>
<li><a class="reference internal" href="#references">6.8. References</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="track_generation.html"
                        title="previous chapter">5. Track Generation</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="../usersguide/index.html"
                        title="next chapter">User&#8217;s Guide</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/methods/cmfd.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../usersguide/index.html" title="User’s Guide"
             >next</a> |</li>
        <li class="right" >
          <a href="track_generation.html" title="5. Track Generation"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">OpenMOC Documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >Theory and Methodology</a> &raquo;</li> 
      </ul>
    </div>

    <div class="footer" role="contentinfo">
        &copy; Copyright 2012-2014, Massachusetts Institute of Technology.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.3.
    </div>
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-30411614-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

  </body>
</html>