
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>2. Geometry &mdash; OpenMOC Documentation</title>
    
    <link rel="stylesheet" href="../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/breathe.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.1.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="OpenMOC Documentation" href="../index.html" />
    <link rel="up" title="Theory and Methodology" href="index.html" />
    <link rel="next" title="3. Ray Tracing" href="ray_tracing.html" />
    <link rel="prev" title="1. Introduction" href="introduction.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="ray_tracing.html" title="3. Ray Tracing"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="introduction.html" title="1. Introduction"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">OpenMOC Documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Theory and Methodology</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="geometry">
<span id="methods-geometry"></span><h1>2. Geometry<a class="headerlink" href="#geometry" title="Permalink to this headline">¶</a></h1>
<div class="section" id="constructive-solid-geometry">
<h2>2.1. Constructive Solid Geometry<a class="headerlink" href="#constructive-solid-geometry" title="Permalink to this headline">¶</a></h2>
<p>OpenMOC uses a technique known as <a class="reference external" href="http://en.wikipedia.org/wiki/Constructive_solid_geometry">constructive solid geometry</a> (CSG) to build
arbitrarily complex three-dimensional models in Euclidean space. In a CSG model,
every unique object is described as the union, intersection, or difference of
<em>half-spaces</em> created by bounding <a class="reference external" href="http://en.wikipedia.org/wiki/Surface">surfaces</a>. Every surface divides all of
space into exactly two half-spaces. We can mathematically define a surface as a
collection of points that satisfy an equation of the form <span class="math">f(x,y,z) = 0</span>
where <span class="math">f(x,y,z)</span> is a given function. All coordinates for which
<span class="math">f(x,y,z) &lt; 0</span> are referred to as the negative half-space (or simply the
<em>negative side</em>) and coordinates for which <span class="math">f(x,y,z) &gt; 0</span> are referred to
as the positive half-space.</p>
<p>Let us take the example of a sphere centered at the point <span class="math">(x_0,y_0,z_0)</span>
with radius <span class="math">R</span>. One would normally write the equation of the sphere as</p>
<div class="math" id="equation-sphere-equation">
<p><span class="eqno">(1)</span><span class="math">(x - x_0)^2 + (y - y_0)^2 + (z - z_0)^2 = R^2</span></p>
</div><p>By subtracting the right-hand term from both sides of equation
<a href="#equation-sphere-equation">(1)</a>, we can then write the surface equation for the sphere:</p>
<div class="math" id="equation-surface-equation-sphere">
<p><span class="eqno">(2)</span><span class="math">f(x,y,z) = (x - x_0)^2 + (y - y_0)^2 + (z - z_0)^2 - R^2 = 0</span></p>
</div><p>One can confirm that any point inside this sphere will correspond to
<span class="math">f(x,y,z) &lt; 0</span> and any point outside the sphere will correspond to
<span class="math">f(x,y,z) &gt; 0</span>.</p>
<p>In OpenMOC, every surface defined by the user is assigned an integer to uniquely
identify it. We can then refer to either of the two half-spaces created by a
surface by a combination of the unique ID of the surface and a positive/negative
sign. The following illustration shows an example of an ellipse with unique ID 1
dividing space into two half-spaces.</p>
<div class="align-center figure align-center">
<img alt="../_images/halfspace.png" src="../_images/halfspace.png" />
<p class="caption">Example of an ellipse and its associated half-spaces.</p>
</div>
<p>References to half-spaces created by surfaces are used to define regions of
space of uniform composition, known as <em>cells</em>. While some codes allow regions
to be defined by intersections, unions, and differences or half-spaces, OpenMOC
is currently limited to cells defined only as intersections of
half-spaces. Thus, the specification of the cell must include a list of
half-space references whose intersection defines the region. The region is then
assigned a material defined elsewhere. The following illustration shows an
example of a cell defined as the intersection of an ellipse and two planes.</p>
<div class="align-center figure align-center">
<img alt="../_images/union.png" src="../_images/union.png" />
<p class="caption">The shaded region represents a cell bounded by three surfaces.</p>
</div>
<p>The ability to form regions based on bounding quadratic surfaces enables OpenMOC
to model arbitrarily complex three-dimensional objects. In practice, one is
limited only by the different surface types available in OpenMOC. The following
table lists the available surface types, the identifier used to specify them in
input files, the corresponding surface equation, and the input parameters needed
to fully define the surface.</p>
<table border="1" class="docutils">
<caption>Surface types available in OpenMOC.</caption>
<colgroup>
<col width="25%" />
<col width="13%" />
<col width="34%" />
<col width="28%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Surface</th>
<th class="head">Identifier</th>
<th class="head">Equation</th>
<th class="head">Parameters</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Plane perpendicular
to <span class="math">x</span>-axis</td>
<td>x-plane</td>
<td><span class="math">x - x_0 = 0</span></td>
<td><span class="math">x_0</span></td>
</tr>
<tr class="row-odd"><td>Plane perpendicular
to <span class="math">y</span>-axis</td>
<td>y-plane</td>
<td><span class="math">x - x_0 = 0</span></td>
<td><span class="math">y_0</span></td>
</tr>
<tr class="row-even"><td>Plane perpendicular
to <span class="math">z</span>-axis</td>
<td>z-plane</td>
<td><span class="math">x - x_0 = 0</span></td>
<td><span class="math">z_0</span></td>
</tr>
<tr class="row-odd"><td>Arbitrary plane</td>
<td>plane</td>
<td><span class="math">Ax + By + Cz = D</span></td>
<td><span class="math">A\;B\;C\;D</span></td>
</tr>
<tr class="row-even"><td>Infinite cylinder
parallel to
<span class="math">x</span>-axis</td>
<td>x-cylinder</td>
<td><span class="math">(y-y_0)^2 + (z-z_0)^2
= R^2</span></td>
<td><span class="math">y_0\;z_0\;R</span></td>
</tr>
<tr class="row-odd"><td>Infinite cylinder
parallel to
<span class="math">y</span>-axis</td>
<td>y-cylinder</td>
<td><span class="math">(x-x_0)^2 + (z-z_0)^2
= R^2</span></td>
<td><span class="math">x_0\;z_0\;R</span></td>
</tr>
<tr class="row-even"><td>Infinite cylinder
parallel to
<span class="math">z</span>-axis</td>
<td>z-cylinder</td>
<td><span class="math">(x-x_0)^2 + (y-y_0)^2
= R^2</span></td>
<td><span class="math">x_0\;y_0\;R</span></td>
</tr>
<tr class="row-odd"><td>Sphere</td>
<td>sphere</td>
<td><span class="math">(x-x_0)^2 + (y-y_0)^2
+ (z-z_0)^2 = R^2</span></td>
<td><span class="math">x_0 \; y_0 \;
z_0 \; R</span></td>
</tr>
<tr class="row-even"><td>Cone parallel to the
<span class="math">x</span>-axis</td>
<td>x-cone</td>
<td><span class="math">(y-y_0)^2 + (z-z_0)^2
= R^2(x-x_0)^2</span></td>
<td><span class="math">x_0 \; y_0 \;
z_0 \; R^2</span></td>
</tr>
<tr class="row-odd"><td>Cone parallel to the
<span class="math">y</span>-axis</td>
<td>y-cone</td>
<td><span class="math">(x-x_0)^2 + (z-z_0)^2
= R^2(y-y_0)^2</span></td>
<td><span class="math">x_0 \; y_0 \;
z_0 \; R^2</span></td>
</tr>
<tr class="row-even"><td>Cone parallel to the
<span class="math">z</span>-axis</td>
<td>z-cone</td>
<td><span class="math">(x-x_0)^2 + (y-y_0)^2
= R^2(z-z_0)^2</span></td>
<td><span class="math">x_0 \; y_0 \;
z_0 \; R^2</span></td>
</tr>
</tbody>
</table>
<div class="section" id="universes">
<span id="id1"></span><h3>2.1.1. Universes<a class="headerlink" href="#universes" title="Permalink to this headline">¶</a></h3>
<p>OpenMOC supports universe-based geometry similar to the likes of <a class="reference external" href="http://mcnp.lanl.gov">MCNP</a> and
<a class="reference external" href="http://montecarlo.vtt.fi">Serpent</a>. This capability enables user to model any identical repeated
structures once and then fill them in various spots in the geometry. A
prototypical example of a repeated structure would be a fuel pin within a fuel
assembly or a fuel assembly within a core.</p>
<p>Each cell in OpenMOC can either be filled with a normal material or with a
universe. If the cell is filled with a universe, only the region of the universe
that is within the defined boundaries of the parent cell will be present in the
geometry. That is to say, even though a collection of cells in a universe may
extend to infinity, not all of the universe will be &#8220;visible&#8221; in the geometry
since it will be truncated by the boundaries of the cell that contains it.</p>
<p>When a cell is filled with a universe, it is possible to specify that the
universe filling the cell should be rotated and translated. This is done through
the <tt class="docutils literal"><span class="pre">rotation</span></tt> and <tt class="docutils literal"><span class="pre">translation</span></tt> attributes on a cell (note though that
these can only be specified on a cell that is filled with another universe, not
a material).</p>
<p>It is not necessary to use or assign universes in a geometry if there are no
repeated structures. Any cell in the geometry that is not assigned to a
specified universe is automatically part of the <em>base universe</em> whose
coordinates are just the normal coordinates in Euclidean space.</p>
</div>
<div class="section" id="lattices">
<h3>2.1.2. Lattices<a class="headerlink" href="#lattices" title="Permalink to this headline">¶</a></h3>
<p>Often times, repeated structures in a geometry occur in a regular pattern such
as a rectangular or hexagonal lattice. In such a case, it would be cumbersome
for a user to have to define the boundaries of each of the cells to be filled
with a universe. Thus, OpenMOC provides a lattice capability similar to that used
in <a class="reference external" href="http://mcnp.lanl.gov">MCNP</a> and <a class="reference external" href="http://montecarlo.vtt.fi">Serpent</a>.</p>
<p>The implementation of lattices is similar in principle to universes &#8212; instead
of a cell being filled with a universe, the user can specify that it is filled
with a finite lattice. The lattice is then defined by a two-dimensional array of
universes that are to fill each position in the lattice. A good example of the
use of lattices and universes can be seen in the OpenMOC model for the <a class="reference external" href="https://github.com/paulromano/benchmarks/tree/master/mc-performance/openmc">Monte
Carlo Performance benchmark</a>.</p>
</div>
</div>
<div class="section" id="computing-the-distance-to-nearest-boundary">
<h2>2.2. Computing the Distance to Nearest Boundary<a class="headerlink" href="#computing-the-distance-to-nearest-boundary" title="Permalink to this headline">¶</a></h2>
<p>One of the most basic algorithms in any Monte Carlo code is determining the
distance to the nearest surface within a cell. Since each cell is defined by
the surfaces that bound it, if we compute the distance to all surfaces bounding
a cell, we can determine the nearest one.</p>
<p>With the possibility of a particle having coordinates on multiple levels
(universes) in a geometry, we must exercise care when calculating the distance
to the nearest surface. Each different level of geometry has a set of boundaries
with which the particle&#8217;s direction of travel may intersect. Thus, it is
necessary to check the distance to the surfaces bounding the cell in each
level. This should be done starting the highest (most global) level going down
to the lowest (most local) level. That ensures that if two surfaces on different
levels are coincident, by default the one on the higher level will be selected
as the nearest surface. Although they are not explicitly defined, it is also
necessary to check the distance to surfaces representing lattice boundaries if a
lattice exists on a given level.</p>
<p>The following procedure is used to calculate the distance to each bounding
surface. Suppose we have a particle at <span class="math">(x_0,y_0,z_0)</span> traveling in the
direction <span class="math">u_0,v_0,w_0</span>. To find the distance <span class="math">d</span> to a surface
<span class="math">f(x,y,z) = 0</span>, we need to solve the equation:</p>
<div class="math" id="equation-dist-to-boundary-1">
<p><span class="eqno">(3)</span><span class="math">f(x_0 + du_0, y_0 + dv_0, z_0 + dw_0) = 0</span></p>
</div><p>If no solutions to equation <a href="#equation-dist-to-boundary-1">(3)</a> exist or the only solutions
are complex, then the particle&#8217;s direction of travel will not intersect the
surface. If the solution to equation <a href="#equation-dist-to-boundary-1">(3)</a> is negative, this
means that the surface is &#8220;behind&#8221; the particle, i.e. if the particle continues
traveling in its current direction, it will not hit the surface. The complete
derivation for different types of surfaces used in OpenMOC will be presented in
the following sections.</p>
<p>Since :math:f(x,y,z)` in general is quadratic in <span class="math">x</span>, <span class="math">y</span>, and
<span class="math">z</span>, this implies that <span class="math">f(x_0 + du_0, y + dv_0, z + dw_0)</span> is
quadratic in <span class="math">d</span>. Thus we expect at most two real solutions to
<a href="#equation-dist-to-boundary-1">(3)</a>. If no solutions to <a href="#equation-dist-to-boundary-1">(3)</a> exist or
the only solutions are complex, then the particle&#8217;s direction of travel will not
intersect the surface. If the solution to <a href="#equation-dist-to-boundary-1">(3)</a> is negative,
this means that the surface is &#8220;behind&#8221; the particle, i.e. if the particle
continues traveling in its current direction, it will not hit the surface.</p>
<p>Once a distance has been computed to a surface, we need to check if it is closer
than previously-computed distances to surfaces. Unfortunately, we cannot just
use the minimum function because some of the calculated distances, which should
be the same in theory (e.g. coincident surfaces), may be slightly different due
to the use of floating-point arithmetic. Consequently, we should first check for
floating-point equality of the current distance calculated and the minimum found
thus far. This is done by checking if</p>
<div class="math" id="equation-fp-distance">
<p><span class="eqno">(4)</span><span class="math">\frac{| d - d_{min} |}{d_{min}} &lt; \epsilon</span></p>
</div><p>where <span class="math">d</span> is the distance to a surface just calculated, <span class="math">d_{min}</span> is
the minimum distance found thus far, and <span class="math">\epsilon</span> is a small number. In
OpenMOC, this parameter is set to <span class="math">\epsilon = 10^{-14}</span> since all floating
calculations are done on 8-byte floating point numbers.</p>
<div class="section" id="plane-perpendicular-to-an-axis">
<h3>2.2.1. Plane Perpendicular to an Axis<a class="headerlink" href="#plane-perpendicular-to-an-axis" title="Permalink to this headline">¶</a></h3>
<p>The equation for a plane perpendicular to, for example, the x-axis is simply
<span class="math">x - x_0 = 0</span>. As such, we need to solve <span class="math">x + du - x_0 = 0</span>. The
solution for the distance is</p>
<div class="math" id="equation-dist-xplane">
<p><span class="eqno">(5)</span><span class="math">d = \frac{x_0 - x}{u}</span></p>
</div><p>Note that if the particle&#8217;s direction of flight is parallel to the x-axis,
i.e. <span class="math">u = 0</span>, the distance to the surface will be infinity. While the
example here was for a plane perpendicular to the x-axis, the same formula can
be applied for the surfaces <span class="math">y = y_0</span> and <span class="math">z = z_0</span>.</p>
</div>
<div class="section" id="generic-plane">
<h3>2.2.2. Generic Plane<a class="headerlink" href="#generic-plane" title="Permalink to this headline">¶</a></h3>
<p>The equation for a generic plane is <span class="math">Ax + By + Cz = D</span>. Thus, we need to
solve the equation <span class="math">A(x + du) + B(y + dv) + C(z + dw) = D</span>. The solution
to this equation for the distance is</p>
<div class="math" id="equation-dist-plane">
<p><span class="eqno">(6)</span><span class="math">d = \frac{D - Ax - By - Cz}{Au + Bv + Cw}</span></p>
</div><p>Again, we need to check whether the denominator is zero. If so, this means that
the particle&#8217;s direction of flight is parallel to the plane and it will
therefore never hit the plane.</p>
</div>
<div class="section" id="cylinder-parallel-to-an-axis">
<h3>2.2.3. Cylinder Parallel to an Axis<a class="headerlink" href="#cylinder-parallel-to-an-axis" title="Permalink to this headline">¶</a></h3>
<p>The equation for a cylinder parallel to, for example, the x-axis is <span class="math">(y -
y_0)^2 + (z - z_0)^2 = R^2</span>. Thus, we need to solve <span class="math">(y + dv - y_0)^2 +
(z + dw - z_0)^2 = R^2</span>. Let us define <span class="math">\bar{y} = y - y_0</span> and
<span class="math">\bar{z} = z - z_0</span>. We then have</p>
<div class="math" id="equation-dist-xcylinder-1">
<p><span class="eqno">(7)</span><span class="math">(\bar{y} + dv)^2 + (\bar{z} + dw)^2 = R^2</span></p>
</div><p>Expanding equation <a href="#equation-dist-xcylinder-1">(7)</a> and rearranging terms, we obtain</p>
<div class="math" id="equation-dist-xcylinder-2">
<p><span class="eqno">(8)</span><span class="math">(v^2 + w^2) d^2 + 2 (\bar{y}v + \bar{z}w) d + (\bar{y}^2 + \bar{z}^2 - R^2)
= 0</span></p>
</div><p>This is a quadratic equation for <span class="math">d</span>. To simplify notation, let us define
<span class="math">a = v^2 + w^2</span>, <span class="math">k = \bar{y}v + \bar{z}w</span>, and <span class="math">c =
\bar{y}^2 + \bar{z}^2 - R^2</span>. Thus, the distance is just the solution to
<span class="math">ad^2 + 2kd + c = 0</span>:</p>
<div class="math" id="equation-dist-xcylinder-3">
<p><span class="eqno">(9)</span><span class="math">d = \frac{-k \pm \sqrt{k^2 - ac}}{a}</span></p>
</div><p>A few conditions must be checked for. If <span class="math">a = 0</span>, this means the particle
is parallel to the cylinder and will thus never intersect it. Also, if
<span class="math">k^2 - ac &lt; 0</span>, this means that both solutions to the quadratic are
complex. In physical terms, this means that the ray along which the particle is
traveling does not make any intersections with the cylinder.</p>
<p>If we do have intersections and <span class="math">c &lt; 0</span>, this means that the particle is
inside the cylinder. Thus, one solution should be positive and one should be
negative. Clearly, the positive distance will occur when the sign on the
square root of the discriminant is positive since <span class="math">a &gt; 0</span>.</p>
<p>If we have intersections and <span class="math">c &gt; 0</span> this means that the particle is
outside the cylinder. Thus, the solutions to the quadratic are either both
positive or both negative. If they are both positive, the smaller (closer) one
will be the solution with a negative sign on the square root of the
discriminant.</p>
<p>The same equations and logic here can be used for cylinders that are parallel to
the y- or z-axis with appropriate substitution of constants.</p>
</div>
<div class="section" id="sphere">
<h3>2.2.4. Sphere<a class="headerlink" href="#sphere" title="Permalink to this headline">¶</a></h3>
<p>The equation for a sphere is <span class="math">(x - x_0)^2 + (y - y_0)^2 + (z - z_0)^2 =
R^2</span>. Thus, we need to solve the equation</p>
<div class="math" id="equation-dist-sphere-1">
<p><span class="eqno">(10)</span><span class="math">(x + du - x_0)^2 + (y + dv - y_0)^2 + (z + dw - z_0)^2 = R^2</span></p>
</div><p>Let us define <span class="math">\bar{x} = x - x_0</span>, <span class="math">\bar{y} = y - y_0</span>, and
<span class="math">\bar{z} = z - z_0</span>. We then have</p>
<div class="math" id="equation-dist-sphere-2">
<p><span class="eqno">(11)</span><span class="math">(\bar{x} + du)^2 + (\bar{y} + dv)^2 + (\bar{z} - dw)^2 = R^2</span></p>
</div><p>Expanding equation <a href="#equation-dist-sphere-2">(11)</a> and rearranging terms, we obtain</p>
<div class="math" id="equation-dist-sphere-3">
<p><span class="eqno">(12)</span><span class="math">d^2 + 2 (\bar{x}u + \bar{y}v + \bar{z}w) d + (\bar{x}^2 + \bar{y}^2 +
\bar{z}^2 - R^2) = 0</span></p>
</div><p>This is a quadratic equation for <span class="math">d</span>. To simplify notation, let us define
<span class="math">k = \bar{x}u + \bar{y}v + \bar{z}w</span> and <span class="math">c = \bar{x}^2 +
\bar{y}^2 + \bar{z}^2 - R^2</span>. Thus, the distance is just the solution to
<span class="math">d^2 + 2kd + c = 0</span>:</p>
<div class="math" id="equation-dist-sphere-4">
<p><span class="eqno">(13)</span><span class="math">d = -k \pm \sqrt{k^2 - c}</span></p>
</div><p>If the discriminant <span class="math">k^2 - c &lt; 0</span>, this means that both solutions to the
quadratic are complex. In physical terms, this means that the ray along which
the particle is traveling does not make any intersections with the sphere.</p>
<p>If we do have intersections and <span class="math">c &lt; 0</span>, this means that the particle is
inside the sphere. Thus, one solution should be positive and one should be
negative. The positive distance will occur when the sign on the square root of
the discriminant is positive. If we have intersections but <span class="math">c &gt; 0</span> this
means that the particle is outside the sphere. The solutions to the quadratic
will then be either both positive or both negative. If they are both positive,
the smaller (closer) one will be the solution with a negative sign on the square
root of the discriminant.</p>
</div>
</div>
<div class="section" id="finding-a-cell-given-a-point">
<span id="find-cell"></span><h2>2.3. Finding a Cell Given a Point<a class="headerlink" href="#finding-a-cell-given-a-point" title="Permalink to this headline">¶</a></h2>
<p>Another basic algorithm is to determine which cell contains a given point in the
global coordinate system, i.e. if the particle&#8217;s position is <span class="math">(x,y,z)</span>,
what cell is it currently in. This is done in the following manner in
OpenMOC. With the possibility of multiple levels of coordinates, we must perform
a recursive search for the cell. First, we start in the highest (most global)
universe, which we call the base universe, and loop over each cell within
that universe. For each cell, we check whether the specified point is inside the
cell using the algorithm described in <a class="reference internal" href="#cell-contains"><em>Determining if a Coordinate is in a Cell</em></a>. If the cell is
filled with a normal material, the search is done and we have identified the
cell containing the point. If the cell is filled with another universe, we then
search all cells within that universe to see if any of them contain the
specified point. If the cell is filled with a lattice, the position within the
lattice is determined, and then whatever universe fills that lattice position is
recursively searched. The search ends once a cell containing a normal material
is found that contains the specified point.</p>
</div>
<div class="section" id="determining-if-a-coordinate-is-in-a-cell">
<span id="cell-contains"></span><h2>2.4. Determining if a Coordinate is in a Cell<a class="headerlink" href="#determining-if-a-coordinate-is-in-a-cell" title="Permalink to this headline">¶</a></h2>
<p>To determine which cell a particle is in given its coordinates, we need to be
able to check whether a given cell contains a point. The algorithm for
determining if a cell contains a point is as follows. For each surface that
bounds a cell, we determine the particle&#8217;s sense with respect to the surface. As
explained earlier, if we have a point <span class="math">(x_0,y_0,z_0)</span> and a surface
<span class="math">f(x,y,z) = 0</span>, the point is said to have negative sense if
<span class="math">f(x_0,y_0,z_0) &lt; 0</span> and positive sense if <span class="math">f(x_0,y_0,z_0) &gt; 0</span>. If
for all surfaces, the sense of the particle with respect to the surface matches
the specified sense that defines the half-space within the cell, then the point
is inside the cell. Note that this algorithm works only for <em>simple cells</em>
defined as intersections of half-spaces.</p>
<p>It may help to illustrate this algorithm using a simple example. Let&#8217;s say we
have a cell defined as</p>
<div class="highlight-xml"><div class="highlight"><pre><span class="nt">&lt;surface</span> <span class="na">id=</span><span class="s">&quot;1&quot;</span> <span class="na">type=</span><span class="s">&quot;sphere&quot;</span>  <span class="na">coeffs=</span><span class="s">&quot;0 0 0 10&quot;</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;surface</span> <span class="na">id=</span><span class="s">&quot;2&quot;</span> <span class="na">type=</span><span class="s">&quot;x-plane&quot;</span> <span class="na">coeffs=</span><span class="s">&quot;-3&quot;</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;surface</span> <span class="na">id=</span><span class="s">&quot;3&quot;</span> <span class="na">type=</span><span class="s">&quot;y-plane&quot;</span> <span class="na">coeffs=</span><span class="s">&quot;2&quot;</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;cell</span> <span class="na">id=</span><span class="s">&quot;1&quot;</span> <span class="na">surfaces=</span><span class="s">&quot;-1 2 -3&quot;</span> <span class="nt">/&gt;</span>
</pre></div>
</div>
<p>This means that the cell is defined as the intersection of the negative half
space of a sphere, the positive half-space of an x-plane, and the negative
half-space of a y-plane. Said another way, any point inside this cell must
satisfy the following equations</p>
<div class="math" id="equation-cell-contains-example">
<p><span class="eqno">(14)</span><span class="math">x^2 + y^2 + z^2 - 10^2 &lt; 0 \\
x - (-3) &gt; 0 \\
x - 2 &lt; 0</span></p>
</div><p>In order to determine if a point is inside the cell, we would substitute its
coordinates into equation <a href="#equation-cell-contains-example">(14)</a>. If the inequalities are
satisfied, than the point is indeed inside the cell.</p>
</div>
<div class="section" id="handling-surface-crossings">
<h2>2.5. Handling Surface Crossings<a class="headerlink" href="#handling-surface-crossings" title="Permalink to this headline">¶</a></h2>
<p>A particle will cross a surface if the distance to the nearest surface is closer
than the distance sampled to the next collision. A number of things happen when
a particle hits a surface. First, we need to check if a non-transmissive
boundary condition has been applied to the surface. If a vacuum boundary
condition has been applied, the particle is killed and any surface current
tallies are scored to as needed. If a reflective boundary condition has been
applied to the surface, surface current tallies are scored to and then the
particle&#8217;s direction is changed according to the procedure in <a class="reference internal" href="#reflection"><em>Reflective Boundary Conditions</em></a>.</p>
<p>Next, we need to determine what cell is beyond the surface in the direction of
travel of the particle so that we can evaluate cross sections based on its
material properties. At initialization, a list of neighboring cells is created
for each surface in the problem as described in <a class="reference internal" href="#neighbor-lists"><em>Building Neighbor Lists</em></a>. The
algorithm outlined in <a class="reference internal" href="#find-cell"><em>Finding a Cell Given a Point</em></a> is used to find a cell containing the
particle with one minor modification; rather than searching all cells in the
base universe, only the list of neighboring cells is searched. If this search is
unsuccessful, then a search is done over every cell in the base universe.</p>
</div>
<div class="section" id="building-neighbor-lists">
<span id="neighbor-lists"></span><h2>2.6. Building Neighbor Lists<a class="headerlink" href="#building-neighbor-lists" title="Permalink to this headline">¶</a></h2>
<p>After the geometry has been loaded and stored in memory from an input file,
OpenMOC builds a list for each surface containing any cells that are bounded by
that surface in order to speed up processing of surface crossings. The algorithm
to build these lists is as follows. First, we loop over all cells in the
geometry and count up how many times each surface appears in a specification as
bounding a negative half-space and bounding a positive half-space. Two arrays
are then allocated for each surface, one that lists each cell that contains the
negative half-space of the surface and one that lists each cell that contains
the positive half-space of the surface. Another loop is performed over all cells
and the neighbor lists are populated for each surface.</p>
</div>
<div class="section" id="reflective-boundary-conditions">
<span id="reflection"></span><h2>2.7. Reflective Boundary Conditions<a class="headerlink" href="#reflective-boundary-conditions" title="Permalink to this headline">¶</a></h2>
<p>If the velocity of a particle is <span class="math">\mathbf{v}</span> and it crosses a surface of
the form <span class="math">f(x,y,z) = 0</span> with a reflective boundary condition, it can be
shown based on geometric arguments that the velocity vector will then become</p>
<div class="math" id="equation-reflection-v">
<p><span class="eqno">(15)</span><span class="math">\mathbf{v'} = \mathbf{v} - 2 (\mathbf{v} \cdot \hat{\mathbf{n}})
\hat{\mathbf{n}}</span></p>
</div><p>where <span class="math">\hat{\mathbf{n}}</span> is a unit vector normal to the surface at the
point of the surface crossing. The rationale for this can be understood by
noting that <span class="math">(\mathbf{v} \cdot \hat{\mathbf{n}}) \hat{\mathbf{n}}</span> is the
projection of the velocity vector onto the normal vector. By subtracting two
times this projection, the velocity is reflected with respect to the surface
normal. Since the magnitude of the velocity of the particle will not change as
it undergoes reflection, we can work with the direction of the particle instead,
simplifying equation <a href="#equation-reflection-v">(15)</a> to</p>
<div class="math" id="equation-reflection-omega">
<p><span class="eqno">(16)</span><span class="math">\mathbf{\Omega'} = \mathbf{\Omega} - 2 (\mathbf{\Omega} \cdot
\hat{\mathbf{n}}) \hat{\mathbf{n}}</span></p>
</div><p>where <span class="math">\mathbf{v} = || \mathbf{v} || \mathbf{\Omega}</span>. The direction of
the surface normal will be the gradient of the surface at the point of crossing,
i.e. <span class="math">\mathbf{n} = \nabla f(x,y,z)</span>. Substituting this into equation
<a href="#equation-reflection-omega">(16)</a>, we get</p>
<div class="math" id="equation-reflection-omega-2">
<p><span class="eqno">(17)</span><span class="math">\mathbf{\Omega'} = \mathbf{\Omega} - \frac{2 ( \mathbf{\Omega} \cdot \nabla
f )}{|| \nabla f ||^2} \nabla f</span></p>
</div><p>If we write the initial and final directions in terms of their vector
components, <span class="math">\mathbf{\Omega} = (u,v,w)</span> and <span class="math">\mathbf{\Omega'} = (u',
v', w')</span>, this allows us to represent equation <a href="#equation-reflection-omega">(16)</a> as a
series of equations:</p>
<div class="math" id="equation-reflection-system">
<p><span class="eqno">(18)</span><span class="math">u' = u - \frac{2 ( \mathbf{\Omega} \cdot \nabla f )}{|| \nabla f ||^2}
\frac{\partial f}{\partial x} \\

v' = v - \frac{2 ( \mathbf{\Omega} \cdot \nabla f )}{|| \nabla f ||^2}
\frac{\partial f}{\partial y} \\

w' = w - \frac{2 ( \mathbf{\Omega} \cdot \nabla f )}{|| \nabla f ||^2}
\frac{\partial f}{\partial z}</span></p>
</div><p>One can then use equation <a href="#equation-reflection-system">(18)</a> to develop equations for
transforming a particle&#8217;s direction given the equation of the surface.</p>
<div class="section" id="id2">
<h3>2.7.1. Plane Perpendicular to an Axis<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h3>
<p>For a plane that is perpendicular to an axis, the rule for reflection is almost
so simple that no derivation is needed at all. Nevertheless, we will proceed
with the derivation to confirm that the rules of geometry agree with our
intuition. The gradient of the surface <span class="math">f(x,y,z) = x - x_0 = 0</span> is simply
<span class="math">\nabla f = (1, 0, 0)</span>. Note that this vector is already normalized,
i.e. <span class="math">|| \nabla f || = 1</span>. The second two equations in
<a href="#equation-reflection-system">(18)</a> tell us that <span class="math">v</span> and <span class="math">w</span> do not change and
the first tell us that</p>
<div class="math" id="equation-reflection-xplane">
<p><span class="eqno">(19)</span><span class="math">u' = u - 2u = -u</span></p>
</div><p>We see that reflection for a plane perpendicular to an axis only entails
negating the directional cosine for that axis.</p>
</div>
<div class="section" id="id3">
<h3>2.7.2. Generic Plane<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<p>A generic plane has the form <span class="math">f(x,y,z) = Ax + By + Cz - D = 0</span>. Thus, the
gradient to the surface is simply <span class="math">\nabla f = (A,B,C)</span> whose norm squared
is <span class="math">A^2 + B^2 + C^2</span>. This implies that</p>
<div class="math" id="equation-reflection-plane-constant">
<p><span class="eqno">(20)</span><span class="math">\frac{2 (\mathbf{\Omega} \cdot \nabla f)}{|| \nabla f ||^2} = \frac{2(Au +
Bv + Cw)}{A^2 + B^2 + C^2}</span></p>
</div><p>Substituting equation <a href="#equation-reflection-plane-constant">(20)</a> into equation
<a href="#equation-reflection-system">(18)</a> gives us the form of the solution. For example, the
x-component of the reflected direction will be</p>
<div class="math" id="equation-reflection-plane">
<p><span class="eqno">(21)</span><span class="math">u' = u - \frac{2A(Au + Bv + Cw)}{A^2 + B^2 + C^2}</span></p>
</div></div>
<div class="section" id="id4">
<h3>2.7.3. Cylinder Parallel to an Axis<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<p>A cylinder parallel to, for example, the x-axis has the form <span class="math">f(x,y,z) =
(y - y_0)^2 + (z - z_0)^2 - R^2 = 0</span>. Thus, the gradient to the surface is</p>
<div class="math" id="equation-reflection-cylinder-grad">
<p><span class="eqno">(22)</span><span class="math">\nabla f = 2 \left ( \begin{array}{c} 0 \\ y - y_0 \\ z - z_0 \end{array}
\right ) = 2 \left ( \begin{array}{c} 0 \\ \bar{y} \\ \bar{z} \end{array}
\right )</span></p>
</div><p>where we have introduced the constants <span class="math">\bar{y}</span> and
<span class="math">\bar{z}</span>. Taking the square of the norm of the gradient, we find that</p>
<div class="math" id="equation-reflection-cylinder-norm">
<p><span class="eqno">(23)</span><span class="math">|| \nabla f ||^2 = 4 \bar{y}^2 + 4 \bar{z}^2 = 4 R^2</span></p>
</div><p>This implies that</p>
<div class="math" id="equation-reflection-cylinder-constant">
<p><span class="eqno">(24)</span><span class="math">\frac{2 (\mathbf{\Omega} \cdot \nabla f)}{|| \nabla f ||^2} =
\frac{\bar{y}v + \bar{z}w}{R^2}</span></p>
</div><p>Substituting equations <a href="#equation-reflection-cylinder-constant">(24)</a> and
<a href="#equation-reflection-cylinder-grad">(22)</a> into equation <a href="#equation-reflection-system">(18)</a> gives us
the form of the solution. In this case, the x-component will not change. The y-
and z-components of the reflected direction will be</p>
<div class="math" id="equation-reflection-cylinder">
<p><span class="eqno">(25)</span><span class="math">v' = v - \frac{2 ( \bar{y}v + \bar{z}w ) \bar{y}}{R^2} \\

w' = w - \frac{2 ( \bar{y}v + \bar{z}w ) \bar{z}}{R^2}</span></p>
</div></div>
<div class="section" id="id5">
<h3>2.7.4. Sphere<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<p>The surface equation for a sphere has the form <span class="math">f(x,y,z) = (x - x_0)^2 +
(y - y_0)^2 + (z - z_0)^2 - R^2 = 0</span>. Thus, the gradient to the surface is</p>
<div class="math" id="equation-reflection-sphere-grad">
<p><span class="eqno">(26)</span><span class="math">\nabla f = 2 \left ( \begin{array}{c} x - x_0 \\ y - y_0 \\ z - z_0
\end{array} \right ) = 2 \left ( \begin{array}{c} \bar{x} \\ \bar{y} \\
\bar{z} \end{array} \right )</span></p>
</div><p>where we have introduced the constants <span class="math">\bar{x}, \bar{y}, \bar{z}</span>. Taking
the square of the norm of the gradient, we find that</p>
<div class="math" id="equation-reflection-sphere-norm">
<p><span class="eqno">(27)</span><span class="math">|| \nabla f ||^2 = 4 \bar{x}^2 + 4 \bar{y}^2 + 4 \bar{z}^2 = 4 R^2</span></p>
</div><p>This implies that</p>
<div class="math" id="equation-reflection-sphere-constant">
<p><span class="eqno">(28)</span><span class="math">\frac{2 (\mathbf{\Omega} \cdot \nabla f)}{|| \nabla f ||^2} =
\frac{\bar{x}u + \bar{y}v + \bar{z}w}{R^2}</span></p>
</div><p>Substituting equations <a href="#equation-reflection-sphere-constant">(28)</a> and
<a href="#equation-reflection-sphere-grad">(26)</a> into equation <a href="#equation-reflection-system">(18)</a> gives us the
form of the solution:</p>
<div class="math" id="equation-reflection-sphere">
<p><span class="eqno">(29)</span><span class="math">u' = u - \frac{2 ( \bar{x}u + \bar{y}v + \bar{z}w ) \bar{x} }{R^2} \\

v' = v - \frac{2 ( \bar{x}u + \bar{y}v + \bar{z}w ) \bar{y} }{R^2} \\

w' = w - \frac{2 ( \bar{x}u + \bar{y}v + \bar{z}w ) \bar{z} }{R^2}</span></p>
</div></div>
<div class="section" id="cone-parallel-to-an-axis">
<h3>2.7.5. Cone Parallel to an Axis<a class="headerlink" href="#cone-parallel-to-an-axis" title="Permalink to this headline">¶</a></h3>
<p>A cone parallel to, for example, the z-axis has the form <span class="math">f(x,y,z) = (x -
x_0)^2 + (y - y_0)^2 - R^2(z - z_0)^2 = 0</span>. Thus, the gradient to the surface is</p>
<div class="math" id="equation-reflection-cone-grad">
<p><span class="eqno">(30)</span><span class="math">\nabla f = 2 \left ( \begin{array}{c} x - x_0 \\ y - y_0 \\ -R^2(z - z_0)
\end{array} \right ) = 2 \left ( \begin{array}{c} \bar{x} \\ \bar{y} \\
-R^2\bar{z} \end{array} \right )</span></p>
</div><p>where we have introduced the constants <span class="math">\bar{x}</span>, <span class="math">\bar{y}</span>, and
<span class="math">\bar{z}</span>. Taking the square of the norm of the gradient, we find that</p>
<div class="math" id="equation-reflection-cone-norm">
<p><span class="eqno">(31)</span><span class="math">|| \nabla f ||^2 = 4 \bar{x}^2 + \bar{y}^2 + 4 R^4 \bar{z}^2 \\ = 4 R^2
   \bar{z}^2 + 4 R^4 \bar{z}^2 \\ = 4 R^2 (1 + R^2) \bar{z}^2</span></p>
</div><p>This implies that</p>
<div class="math" id="equation-reflection-cone-constant">
<p><span class="eqno">(32)</span><span class="math">\frac{2 (\mathbf{\Omega} \cdot \nabla f)}{|| \nabla f ||^2} =
\frac{\bar{x}u + \bar{y}v - R^2\bar{z}w}{R^2 (1 + R^2) \bar{z}^2}</span></p>
</div><p>Substituting equations <a href="#equation-reflection-cone-constant">(32)</a> and
<a href="#equation-reflection-cone-grad">(30)</a> into equation <a href="#equation-reflection-system">(18)</a> gives us the
form of the solution:</p>
<div class="math" id="equation-reflection-cone">
<p><span class="eqno">(33)</span><span class="math">u' = u - \frac{2 (\bar{x}u + \bar{y}v - R^2\bar{z}w) \bar{x}}{R^2 (1 + R^2)
\bar{z}^2}

v' = v - \frac{2 (\bar{x}u + \bar{y}v - R^2\bar{z}w) \bar{y}}{R^2 (1 + R^2)
\bar{z}^2}

w' = w + \frac{2 (\bar{x}u + \bar{y}v - R^2\bar{z}w)}{R^2 (1 + R^2) \bar{z}}</span></p>
</div></div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">2. Geometry</a><ul>
<li><a class="reference internal" href="#constructive-solid-geometry">2.1. Constructive Solid Geometry</a><ul>
<li><a class="reference internal" href="#universes">2.1.1. Universes</a></li>
<li><a class="reference internal" href="#lattices">2.1.2. Lattices</a></li>
</ul>
</li>
<li><a class="reference internal" href="#computing-the-distance-to-nearest-boundary">2.2. Computing the Distance to Nearest Boundary</a><ul>
<li><a class="reference internal" href="#plane-perpendicular-to-an-axis">2.2.1. Plane Perpendicular to an Axis</a></li>
<li><a class="reference internal" href="#generic-plane">2.2.2. Generic Plane</a></li>
<li><a class="reference internal" href="#cylinder-parallel-to-an-axis">2.2.3. Cylinder Parallel to an Axis</a></li>
<li><a class="reference internal" href="#sphere">2.2.4. Sphere</a></li>
</ul>
</li>
<li><a class="reference internal" href="#finding-a-cell-given-a-point">2.3. Finding a Cell Given a Point</a></li>
<li><a class="reference internal" href="#determining-if-a-coordinate-is-in-a-cell">2.4. Determining if a Coordinate is in a Cell</a></li>
<li><a class="reference internal" href="#handling-surface-crossings">2.5. Handling Surface Crossings</a></li>
<li><a class="reference internal" href="#building-neighbor-lists">2.6. Building Neighbor Lists</a></li>
<li><a class="reference internal" href="#reflective-boundary-conditions">2.7. Reflective Boundary Conditions</a><ul>
<li><a class="reference internal" href="#id2">2.7.1. Plane Perpendicular to an Axis</a></li>
<li><a class="reference internal" href="#id3">2.7.2. Generic Plane</a></li>
<li><a class="reference internal" href="#id4">2.7.3. Cylinder Parallel to an Axis</a></li>
<li><a class="reference internal" href="#id5">2.7.4. Sphere</a></li>
<li><a class="reference internal" href="#cone-parallel-to-an-axis">2.7.5. Cone Parallel to an Axis</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="introduction.html"
                        title="previous chapter">1. Introduction</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="ray_tracing.html"
                        title="next chapter">3. Ray Tracing</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/methods/geometry.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="ray_tracing.html" title="3. Ray Tracing"
             >next</a> |</li>
        <li class="right" >
          <a href="introduction.html" title="1. Introduction"
             >previous</a> |</li>
        <li><a href="../index.html">OpenMOC Documentation</a> &raquo;</li>
          <li><a href="index.html" >Theory and Methodology</a> &raquo;</li> 
      </ul>
    </div>

    <div class="footer">
        &copy; Copyright 2012-2013, Massachusetts Institute of Technology.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-30411614-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

  </body>
</html>