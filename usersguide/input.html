<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>3. Writing Python Input Files &mdash; OpenMOC Documentation</title>
    
    <link rel="stylesheet" href="../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.1.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="OpenMOC Documentation" href="../index.html" />
    <link rel="up" title="User’s Guide" href="index.html" />
    <link rel="next" title="4. Data Processing and Visualization" href="processing.html" />
    <link rel="prev" title="2. Installation and Configuration" href="install.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="processing.html" title="4. Data Processing and Visualization"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="install.html" title="2. Installation and Configuration"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">OpenMOC Documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">User&#8217;s Guide</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="writing-python-input-files">
<span id="usersguide-input"></span><h1>3. Writing Python Input Files<a class="headerlink" href="#writing-python-input-files" title="Permalink to this headline">¶</a></h1>
<p>OpenMOC is provided to users as a Python API. As a result, there are not strict constraints on how an input file is written for an OpenMOC simulation as there are in many other scientific simulation codes. Instead, users may write a Python script or program and import OpenMOC and simply use the classes or routines which are necessary for a particular simulation. The <tt class="file docutils literal"><span class="pre">OpenMOC/sample-input/</span></tt> directory in the OpenMOC folder includes many example scripts for simulations ranging in complexity from a simple <a class="reference external" href="https://github.com/mit-crpg/OpenMOC/tree/master/sample-input/pin-cell">pin cell</a> to the <a class="reference external" href="https://github.com/mit-crpg/OpenMOC/tree/master/sample-input/benchmarks/c5g7">C5G7 benchmark problem</a>.</p>
<p>The following sections describe the essential portions of the OpenMOC API needed for reactor eigenvalue calculations. For more detail on the full extent of OpenMOC capabilities, users should reference the <a class="reference internal" href="../doxygen/api.html#api"><em>OpenMOC API documentation</em></a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">It is highly suggested that users acquire a basic understanding of Python before developing OpenMOC simulations. For users familiar with basic programming constructs such as loops and conditionals, the official <a class="reference external" href="http://docs.python.org/2/tutorial/">Python Tutorial</a> is an excellent place to learn Python basics. For users new to programming, the <a class="reference external" href="http://www.codecademy.com/tracks/python">Code Academy Python Course</a> provides an introduction to both programming essentials and the Python language.</p>
</div>
<div class="section" id="simulation-parameters">
<span id="simulation-params"></span><h2>3.1. Simulation Parameters<a class="headerlink" href="#simulation-parameters" title="Permalink to this headline">¶</a></h2>
<p>The full power of Python is available to users designing OpenMOC simulations. As a result, simulation parameters may easily be defined and redefined in a Python script for one or more simulations at a user&#8217;s discretion. However, some simulation parameters are best defined at runtime, including the number of azimuthal angles, track spacing, number of threads, etc.</p>
<p>The <tt class="docutils literal"><span class="pre">openmoc.options</span></tt> module provides functionality to parse arguments defined on the command line at runtime. The full list of options available in OpenMOC are itemized and described in <a class="reference internal" href="running.html#runtime-options"><em>Runtime Options</em></a>. The following code snippet illutrates how to instantiate an <tt class="docutils literal"><span class="pre">Options</span></tt> object and extract data from command line arguments.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">openmoc.options</span>

<span class="c"># Instantiate and Options object</span>
<span class="n">options</span> <span class="o">=</span> <span class="n">openmoc</span><span class="o">.</span><span class="n">options</span><span class="o">.</span><span class="n">Options</span><span class="p">()</span>

<span class="c"># Retrieve runtime options parsed in by the Options object</span>
<span class="n">num_threads</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">num_omp_threads</span>
<span class="n">track_spacing</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">track_spacing</span>
<span class="n">num_azim</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">num_azim</span>
<span class="n">tolerance</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">tolerance</span>
<span class="n">max_iters</span> <span class="o">=</span> <span class="n">options</span><span class="o">.</span><span class="n">max_iters</span>
<span class="o">...</span>
</pre></div>
</div>
<p><a class="reference internal" href="#table-log-levels"><em>Table 1</em></a> below itemizes each of the runtime options and the corresponding command line arguments and Options class property attributes in the <tt class="docutils literal"><span class="pre">openmoc.options</span></tt> module.</p>
<table border="1" class="docutils" id="table-runtime-options">
<colgroup>
<col width="23%" />
<col width="35%" />
<col width="42%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Runtime Option</th>
<th class="head">Command Line Argument</th>
<th class="head">Options Class Property Attribute</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Help</td>
<td><a class="reference internal" href="running.html#cmdoption-h"><em class="xref std std-option">-h</em></a>, <a class="reference internal" href="running.html#cmdoption--help"><em class="xref std std-option">--help</em></a></td>
<td>N/A</td>
</tr>
<tr class="row-odd"><td>No. Azimuthal Angles</td>
<td><a class="reference internal" href="running.html#cmdoption-a"><em class="xref std std-option">-a</em></a>, <em class="xref std std-option">--num-azim=</em></td>
<td>num_azim</td>
</tr>
<tr class="row-even"><td>Track Spacing [cm]</td>
<td><a class="reference internal" href="running.html#cmdoption-s"><em class="xref std std-option">-s</em></a>, <em class="xref std std-option">--track-spacing=</em></td>
<td>track_spacing</td>
</tr>
<tr class="row-odd"><td>Max. No. Transport Sweeps</td>
<td><a class="reference internal" href="running.html#cmdoption-i"><em class="xref std std-option">-i</em></a>, <em class="xref std std-option">--max-iters=</em></td>
<td>max_iters</td>
</tr>
<tr class="row-even"><td>Convergence Tolerance</td>
<td><a class="reference internal" href="running.html#cmdoption-c"><em class="xref std std-option">-c</em></a>, <em class="xref std std-option">--tolerance=</em></td>
<td>tolerance</td>
</tr>
<tr class="row-odd"><td>No. OpenMP Threads</td>
<td><a class="reference internal" href="running.html#cmdoption-t"><em class="xref std std-option">-t</em></a>, <em class="xref std std-option">--num-omp-threads=</em></td>
<td>num_omp_threads</td>
</tr>
<tr class="row-even"><td>No. CUDA Thread Blocks</td>
<td><a class="reference internal" href="running.html#cmdoption-b"><em class="xref std std-option">-b</em></a>, <em class="xref std std-option">--num-thread-blocks=</em></td>
<td>num_thread_blocks</td>
</tr>
<tr class="row-odd"><td>No. CUDA Threads per Block</td>
<td><a class="reference internal" href="running.html#cmdoption-g"><em class="xref std std-option">-g</em></a>, <em class="xref std std-option">--num-gpu-threads=</em></td>
<td>num_threads_per_block</td>
</tr>
</tbody>
</table>
<p><strong>Table 1</strong>: Runtime options and command line arguments supported by the <tt class="docutils literal"><span class="pre">openmoc.options</span></tt> module.</p>
</div>
<div class="section" id="simulation-log-files">
<h2>3.2. Simulation Log Files<a class="headerlink" href="#simulation-log-files" title="Permalink to this headline">¶</a></h2>
<p>The <tt class="docutils literal"><span class="pre">openmoc.log</span></tt> module provides routines for printing output to the console as well as to log files. Output is reported in real-time to the console as well as stored in a persistent log file. By default, the log file name encapsulates a timestamp for the simulation starting time and is stored in the <tt class="docutils literal"><span class="pre">/OpenMOC/log</span></tt> directory (<em>e.g.</em>, <tt class="file docutils literal"><span class="pre">OpenMOC/log/openmoc-MM-DD-YYYY--HH:MM:SS.log</span></tt>).</p>
<p>The OpenMOC logging module uses <strong>verbosity throttling</strong> which allows for coarse-grained control of the type and amount of messages reported to the user at runtime. Each message is designated a <strong>log level</strong>, and each level is prioritized with respect to other levels. At runtime, a log level is specified for a simulation and only those messages designated at that log level or a higher priority log level are printed to the console and log file. The log levels available in OpenMOC are presented in <a class="reference internal" href="#table-log-levels"><em>Table 2</em></a>.</p>
<table border="1" class="docutils" id="table-log-levels">
<colgroup>
<col width="26%" />
<col width="74%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Log Level</th>
<th class="head">Note</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><span class="target" id="index-0"></span><tt class="xref std std-envvar docutils literal"><span class="pre">DEBUG</span></tt></td>
<td>A debugging message</td>
</tr>
<tr class="row-odd"><td><span class="target" id="index-1"></span><tt class="xref std std-envvar docutils literal"><span class="pre">INFO</span></tt></td>
<td>An informational but verbose message</td>
</tr>
<tr class="row-even"><td><span class="target" id="index-2"></span><tt class="xref std std-envvar docutils literal"><span class="pre">NORMAL</span></tt></td>
<td>A brief progress update on run progress</td>
</tr>
<tr class="row-odd"><td><span class="target" id="index-3"></span><tt class="xref std std-envvar docutils literal"><span class="pre">SEPARATOR</span></tt></td>
<td>A message of a single line of characters</td>
</tr>
<tr class="row-even"><td><span class="target" id="index-4"></span><tt class="xref std std-envvar docutils literal"><span class="pre">HEADER</span></tt></td>
<td>A message centered within a single line of characters</td>
</tr>
<tr class="row-odd"><td><span class="target" id="index-5"></span><tt class="xref std std-envvar docutils literal"><span class="pre">TITLE</span></tt></td>
<td>A message between two lines of characters</td>
</tr>
<tr class="row-even"><td><span class="target" id="index-6"></span><tt class="xref std std-envvar docutils literal"><span class="pre">WARNING</span></tt></td>
<td>A message to warn the user</td>
</tr>
<tr class="row-odd"><td><span class="target" id="index-7"></span><tt class="xref std std-envvar docutils literal"><span class="pre">CRITICAL</span></tt></td>
<td>A message to warn of critical program conditions</td>
</tr>
<tr class="row-even"><td><span class="target" id="index-8"></span><tt class="xref std std-envvar docutils literal"><span class="pre">RESULT</span></tt></td>
<td>A message containing program results</td>
</tr>
<tr class="row-odd"><td><span class="target" id="index-9"></span><tt class="xref std std-envvar docutils literal"><span class="pre">ERROR</span></tt></td>
<td>A message reporting error conditions</td>
</tr>
</tbody>
</table>
<p><strong>Table 2</strong>: Log levels in OpenMOC in order of increasing precedence.</p>
<p>Informative messages using the logging module are embedded into both the C/C++ and Python source code in OpenMOC. In addition, code users may add their own messages to the output stream in Python input files. The API documentation provides a detailed accounting of the routines available in the <a class="reference external" href="http://mit-crpg.github.io/OpenMOC/doxygen/html/log_8h.html">logging module</a>.</p>
<p>The following code snippet illustrates how to import the logging module into Python, set the lowest log level to <span class="target" id="index-10"></span><tt class="xref std std-envvar docutils literal"><span class="pre">DEBUG</span></tt>, and print messages for each level to the screen.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">openmoc.log</span> <span class="kn">as</span> <span class="nn">log</span>

<span class="c"># Set the lowest acceptable log level to DEBUG mode</span>
<span class="n">log</span><span class="o">.</span><span class="n">set_log_level</span><span class="p">(</span><span class="s">&#39;DEBUG&#39;</span><span class="p">)</span>

<span class="c"># Print some exaple messages to the console and log file</span>
<span class="n">log</span><span class="o">.</span><span class="n">py_printf</span><span class="p">(</span><span class="s">&#39;DEBUG&#39;</span><span class="p">,</span> <span class="s">&#39;This is a DEBUG message&#39;</span><span class="p">)</span>
<span class="n">log</span><span class="o">.</span><span class="n">py_printf</span><span class="p">(</span><span class="s">&#39;INFO&#39;</span><span class="p">,</span> <span class="s">&#39;This is an INFO message&#39;</span><span class="p">)</span>
<span class="n">log</span><span class="o">.</span><span class="n">py_printf</span><span class="p">(</span><span class="s">&#39;NORMAL&#39;</span><span class="p">,</span> <span class="s">&#39;This is a NORMAL message&#39;</span><span class="p">)</span>
<span class="n">log</span><span class="o">.</span><span class="n">py_printf</span><span class="p">(</span><span class="s">&#39;SEPARATOR&#39;</span><span class="p">,</span> <span class="s">&#39;This is a SEPARATOR message&#39;</span><span class="p">)</span>
<span class="n">log</span><span class="o">.</span><span class="n">py_printf</span><span class="p">(</span><span class="s">&#39;HEADER&#39;</span><span class="p">,</span> <span class="s">&#39;This is a HEADER message&#39;</span><span class="p">)</span>
<span class="n">log</span><span class="o">.</span><span class="n">py_printf</span><span class="p">(</span><span class="s">&#39;TITLE&#39;</span><span class="p">,</span> <span class="s">&#39;This is a TITLE message&#39;</span><span class="p">)</span>
<span class="n">log</span><span class="o">.</span><span class="n">py_printf</span><span class="p">(</span><span class="s">&#39;WARNING&#39;</span><span class="p">,</span> <span class="s">&#39;This is a WARNING message&#39;</span><span class="p">)</span>
<span class="n">log</span><span class="o">.</span><span class="n">py_printf</span><span class="p">(</span><span class="s">&#39;CRITICAL&#39;</span><span class="p">,</span> <span class="s">&#39;This is a CRITICAL message&#39;</span><span class="p">)</span>
<span class="n">log</span><span class="o">.</span><span class="n">py_printf</span><span class="p">(</span><span class="s">&#39;ERROR&#39;</span><span class="p">,</span> <span class="s">&#39;This is an ERROR message&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>And the following is the output displayed to the console and recorded in the log file:</p>
<div class="highlight-python"><div class="highlight"><pre>[  DEBUG  ]  This is a DEBUG message
[  INFO   ]  This is an INFO message
[  NORMAL ]  This is a NORMAL message
[SEPARATOR]  *******************************************************************
[  HEADER ]  *******************  This is a HEADER message  ********************
[  TITLE  ]  *******************************************************************
[  TITLE  ]                        This is a TITLE message
[  TITLE  ]  *******************************************************************
[ WARNING ]  This is a WARNING message
[ CRITICAL]  This is a CRITICAL message
[  ERROR  ]  This is an ERROR message
</pre></div>
</div>
<p>It should be noted that the <tt class="docutils literal"><span class="pre">py_printf(...)</span></tt> routine in the logging module is based on the <a class="reference external" href="http://www.cplusplus.com/reference/cstdio/printf/">printf</a> routine in C/C++ and accepts a variable number of arguments. In particular, this is intended to accept <a class="reference external" href="http://www.cplusplus.com/reference/cstdio/printf/">formatted data</a> to embed formatted integers, floats, strings, etc. in the output message. An example of this feature in use is given below:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">openmoc.log</span> <span class="kn">as</span> <span class="nn">log</span>

<span class="c"># Set the lowest acceptable log level to NORMAL mode</span>
<span class="n">log</span><span class="o">.</span><span class="n">set_log_level</span><span class="p">(</span><span class="s">&#39;NORMAL&#39;</span><span class="p">)</span>

<span class="c"># Initialize some string, integer and float variables</span>
<span class="n">name</span> <span class="o">=</span> <span class="s">&#39;Will Boyd&#39;</span>
<span class="n">age</span> <span class="o">=</span> <span class="mi">26</span>
<span class="n">pi</span> <span class="o">=</span> <span class="mf">3.141593</span>

<span class="c"># Print example messages using formatted output arguments</span>
<span class="c"># to the console and log file</span>
<span class="n">log</span><span class="o">.</span><span class="n">py_printf</span><span class="p">(</span><span class="s">&#39;NORMAL&#39;</span><span class="p">,</span> <span class="s">&#39;Hello World! My name is </span><span class="si">%s</span><span class="s">&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
<span class="n">log</span><span class="o">.</span><span class="n">py_printf</span><span class="p">(</span><span class="s">&#39;NORMAL&#39;</span><span class="p">,</span> <span class="s">&#39;I am </span><span class="si">%d</span><span class="s"> years old. My favorite # is </span><span class="si">%f</span><span class="s">&#39;</span><span class="p">,</span> <span class="n">age</span><span class="p">,</span> <span class="n">pi</span><span class="p">)</span>
</pre></div>
</div>
<p>This will result in the following output messages to be printed to the console and stored to the log file:</p>
<div class="highlight-python"><div class="highlight"><pre>[  NORMAL ]  Hello World! My name is Will Boyd
[  NORMAL ]  I am 26 years old. My favorite # is 3.141593
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">By default, the logging module will split log messages into multiple lines of 80 characters or less each. Users may alternatively set a custom maximum line length for log messages may at runtime using the <tt class="docutils literal"><span class="pre">set_line_length(...)</span></tt> routine.</p>
</div>
</div>
<div class="section" id="materials-specification">
<h2>3.3. Materials Specification<a class="headerlink" href="#materials-specification" title="Permalink to this headline">¶</a></h2>
<p>OpenMOC uses multi-group macroscopic nuclear cross sections, provided by the user. OpenMOC does not perform self-shielding or depletion calculations, so isotropic concentrations are not used. In OpenMOC, cross section data is encapsulated by the <tt class="docutils literal"><span class="pre">Material</span></tt> class in the main <tt class="docutils literal"><span class="pre">openmoc</span></tt> Python module. A <tt class="docutils literal"><span class="pre">Material</span></tt> class may be instantiated in Python and cross sections may be loaded into it using <a class="reference external" href="http://www.numpy.org/">NumPy</a> data arrays as illustrated by the following code snippet:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">openmoc</span>
<span class="kn">import</span> <span class="nn">numpy</span>

<span class="c"># Initialize material cross sections using NumPy data arrays</span>
<span class="n">num_groups</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">sigma_t</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.15</span><span class="p">,</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.25</span><span class="p">,</span><span class="mf">0.35</span><span class="p">,</span><span class="mf">0.4</span><span class="p">,</span><span class="mf">0.45</span><span class="p">,</span><span class="mf">0.5</span><span class="p">])</span>
<span class="n">sigma_f</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.05</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.15</span><span class="p">,</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.25</span><span class="p">,</span><span class="mf">0.3</span><span class="p">,</span><span class="mf">0.35</span><span class="p">,</span><span class="mf">0.4</span><span class="p">])</span>
<span class="o">...</span>

<span class="c"># Instantiate an OpenMOC Material class object with an optional string name</span>
<span class="n">material</span> <span class="o">=</span> <span class="n">openmoc</span><span class="o">.</span><span class="n">Material</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;test material&#39;</span><span class="p">)</span>

<span class="c"># Set the number of energy groups in the material</span>
<span class="n">material</span><span class="o">.</span><span class="n">setNumEnergyGroups</span><span class="p">(</span><span class="n">num_groups</span><span class="p">)</span>

<span class="c"># Load the cross section data into the material</span>
<span class="n">material</span><span class="o">.</span><span class="n">setSigmaT</span><span class="p">(</span><span class="n">sigma_t</span><span class="p">)</span>
<span class="n">material</span><span class="o">.</span><span class="n">setSigmaF</span><span class="p">(</span><span class="n">sigma_f</span><span class="p">)</span>
<span class="o">...</span>
</pre></div>
</div>
<p>For many simulations, defining the nuclear data cross sections by hand in a Python script is cumbersome and error-prone. As a result, OpenMOC includes the <tt class="docutils literal"><span class="pre">openmoc.materialize</span></tt> module for importing nuclear data cross sections from an <a class="reference external" href="http://www.hdfgroup.org/HDF5/">HDF5</a> binary file. The <tt class="docutils literal"><span class="pre">load_from_hdf5(...)</span></tt> routine is used to import data and instantiate <tt class="docutils literal"><span class="pre">Material</span></tt> objects returned via a Python <a class="reference external" href="http://docs.python.org/2/tutorial/datastructures.html#dictionaries">dictionary</a>. The use of the <tt class="docutils literal"><span class="pre">openmoc.materialize</span></tt> module to import HDF5 binary files is illustrated in the following snippet:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">openmoc</span>
<span class="kn">import</span> <span class="nn">openmoc.materialize</span> <span class="kn">as</span> <span class="nn">materialize</span>

<span class="c"># Import cross section data from an HDF5 file. This instantiates</span>
<span class="c"># objects for each material and returns them in a dictionary</span>
<span class="c"># indexed by a string name or integer ID</span>
<span class="n">hdf5_materials</span> <span class="o">=</span> <span class="n">materialize</span><span class="o">.</span><span class="n">load_from_hdf5</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s">&#39;materials-data.h5&#39;</span><span class="p">,</span>
                                            <span class="n">directory</span><span class="o">=</span><span class="s">&#39;/home/myuser&#39;</span><span class="p">)</span>

<span class="c"># Retrieve the material called &#39;moderator&#39; in the HDF5 file</span>
<span class="n">moderator</span> <span class="o">=</span> <span class="n">hdf5_materials</span><span class="p">[</span><span class="s">&#39;moderator&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">openmoc.materialize</span></tt> module defines a standard for cross section data stored in binary files. First, HDF5 files must include a <tt class="docutils literal"><span class="pre">'#</span> <span class="pre">groups'</span></tt> attribute with the integer number of groups in the top level of the file hierarchy. Second, the string domain type - <tt class="docutils literal"><span class="pre">'material'</span></tt> or <tt class="docutils literal"><span class="pre">'cell'</span></tt> - must be specified in the top level of the file hierarchy. This must match the <tt class="docutils literal"><span class="pre">domain_type</span></tt> keyword argument passed to <tt class="docutils literal"><span class="pre">load_from_hdf5(...)</span></tt> which can be either <tt class="docutils literal"><span class="pre">'material'</span></tt> (default) or <tt class="docutils literal"><span class="pre">'cell'</span></tt>. The <tt class="docutils literal"><span class="pre">domain_type</span></tt> keyword argument is discussed in more detail at the end of this section. Finally, multi-group cross sections to assign by material or cell must be defined as an <a class="reference external" href="http://docs.h5py.org/en/latest/high/group.html">HDF5 group</a> with a string name or integer ID to identify the material or cell. The material group must contain the following floating point <a class="reference external" href="http://docs.h5py.org/en/latest/high/dataset.html">HDF5 datasets</a> of multi-group cross section data:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">'transport'</span></tt> or <tt class="docutils literal"><span class="pre">'total'</span></tt></li>
<li><tt class="docutils literal"><span class="pre">'nu-scatter</span> <span class="pre">matrix'</span></tt> or <tt class="docutils literal"><span class="pre">'scatter</span> <span class="pre">matrix'</span></tt></li>
<li><tt class="docutils literal"><span class="pre">'chi'</span></tt></li>
<li><tt class="docutils literal"><span class="pre">'nu-fission'</span></tt></li>
<li><tt class="docutils literal"><span class="pre">'fission'</span></tt> (optional)</li>
</ul>
</div></blockquote>
<p>Each dataset should be a 1D array of floating point values ordered by increasing energy group (<em>i.e.</em>, from highest to lowest energies). This includes the scattering matrix which should be inner strided by outgoing energy group and outer strided by incoming energy group.</p>
<p>To better understand the necessary HDF file structure, it may be useful to visualize the <tt class="docutils literal"><span class="pre">OpenMOC/sample-input/c5g7-mgxs.h5</span></tt> HDF5 file using the <a class="reference external" href="http://www.hdfgroup.org/products/java/hdfview/">HDFView</a> graphical tool. The following code snippet illustrates the use of the <a class="reference external" href="http://www.h5py.org/">h5py</a> Python HDF5 interface to write an HDF5 file with material cross section data adhering to the standard expected by the <tt class="docutils literal"><span class="pre">openmoc.materialize</span></tt> module:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">h5py</span>

<span class="c"># Create an HDF5 file to store multi-groups cross sections</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="s">&#39;materials-data.h5&#39;</span><span class="p">)</span>

<span class="c"># Set the number of energy groups</span>
<span class="n">f</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s">&#39;# groups&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">8</span>

<span class="c"># Material 1</span>

<span class="c"># Create an HDF5 group for this material</span>
<span class="n">material_group</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s">&#39;Material 1&#39;</span><span class="p">)</span>

<span class="c"># Initialize cross sections as NumPy data arrays</span>
<span class="n">sigma_t</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.15</span><span class="p">,</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.25</span><span class="p">,</span><span class="mf">0.35</span><span class="p">,</span><span class="mf">0.4</span><span class="p">,</span><span class="mf">0.45</span><span class="p">,</span><span class="mf">0.5</span><span class="p">])</span>
<span class="n">nu_sigma_f</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.05</span><span class="p">,</span><span class="mf">0.1</span><span class="p">,</span><span class="mf">0.15</span><span class="p">,</span><span class="mf">0.2</span><span class="p">,</span><span class="mf">0.25</span><span class="p">,</span><span class="mf">0.3</span><span class="p">,</span><span class="mf">0.35</span><span class="p">,</span><span class="mf">0.4</span><span class="p">])</span>
<span class="o">...</span>

<span class="c"># Create datasets for each cross section type</span>
<span class="n">material_group</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s">&#39;total&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">sigma_t</span><span class="p">)</span>
<span class="n">material_group</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s">&#39;nu-fission&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="n">nu_sigma_f</span><span class="p">)</span>
<span class="o">...</span>

<span class="c"># Material 2</span>
<span class="o">...</span>

<span class="c"># Close and save the HDF5 file</span>
<span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</pre></div>
</div>
<p>Lastly, the <tt class="docutils literal"><span class="pre">'domain_type'</span></tt> parameter may be specified in conjuction with the optional <tt class="docutils literal"><span class="pre">geometry</span></tt> keyword argument. The <tt class="docutils literal"><span class="pre">load_from_hdf5(...)</span></tt> routine may be used to load multi-group cross sections directly into a pre-existing OpenMOC <tt class="docutils literal"><span class="pre">Geometry</span></tt> constructed with <tt class="docutils literal"><span class="pre">Materials</span></tt> with the same string names <em>or</em> integer IDs used as keys in the HDF5 binary file. Likewise, the <tt class="docutils literal"><span class="pre">load_from_hdf5(...)</span></tt> routine may be used to load multi-group cross sections directly into a pre-existing OpenMOC <tt class="docutils literal"><span class="pre">Geometry</span></tt> constructed with <tt class="docutils literal"><span class="pre">Cells</span></tt> with the same string names <em>or</em> integer IDs used as keys in the HDF5 binary file. The latter case may be useful when multiple <tt class="docutils literal"><span class="pre">Cells</span></tt> share the same <tt class="docutils literal"><span class="pre">Materials</span></tt>. This is illustrated with the following code snippet:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">openmoc</span>
<span class="kn">import</span> <span class="nn">openmoc.materialize</span> <span class="kn">as</span> <span class="nn">materialize</span>

<span class="c"># Build an OpenMOC Geommetry with Materials, Surfaces, Cells, etc.</span>
<span class="c"># The Cells must have the same IDs as those used in the HDF5 file</span>
<span class="o">...</span>
<span class="n">geometry</span> <span class="o">=</span> <span class="n">openmoc</span><span class="o">.</span><span class="n">Geometry</span><span class="p">()</span>
<span class="o">...</span>

<span class="c"># Import cross section data from an HDF5 file. This instantiates</span>
<span class="c"># objects for each material and returns them in a dictionary</span>
<span class="c"># indexed by a string name or integer ID</span>
<span class="n">hdf5_materials</span> <span class="o">=</span> <span class="n">materialize</span><span class="o">.</span><span class="n">load_from_hdf5</span><span class="p">(</span><span class="n">filename</span><span class="o">=</span><span class="s">&#39;materials-data.h5&#39;</span><span class="p">,</span>
                                            <span class="n">directory</span><span class="o">=</span><span class="s">&#39;/home/myuser&#39;</span><span class="p">,</span>
                                            <span class="n">domain_type</span><span class="o">=</span><span class="s">&#39;cell&#39;</span><span class="p">,</span>
                                            <span class="n">geometry</span><span class="o">=</span><span class="n">geometry</span><span class="p">)</span>
</pre></div>
</div>
<p>In this case there is no need to assign the <tt class="docutils literal"><span class="pre">Materials</span></tt> in the <tt class="docutils literal"><span class="pre">hdf5_materials</span></tt> dictionary to <tt class="docutils literal"><span class="pre">Cells</span></tt> since they are already incorporated into the <tt class="docutils literal"><span class="pre">Geometry</span></tt>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If datasets for both <tt class="docutils literal"><span class="pre">'transport'</span></tt> and <tt class="docutils literal"><span class="pre">'total'</span></tt> are defined for a material in the HDF5 file, <tt class="docutils literal"><span class="pre">openmoc.materialize</span></tt> will give precedence to the <tt class="docutils literal"><span class="pre">'transport'</span></tt> dataset and assign it as the total multi-group cross section.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If datasets for both <tt class="docutils literal"><span class="pre">'nu-scatter</span> <span class="pre">matrix'</span></tt> and <tt class="docutils literal"><span class="pre">'scatter</span> <span class="pre">matrix'</span></tt> are defined for a material in the HDF5 file, <tt class="docutils literal"><span class="pre">openmoc.materialize</span></tt> will give precedence to the <tt class="docutils literal"><span class="pre">'nu-scatter</span> <span class="pre">matrix'</span></tt> dataset and assign it as the multi-group scattering matrix cross section.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Users should note that OpenMOC will assign a minimum value of 1E-10 to all total cross sections assigned to a <tt class="docutils literal"><span class="pre">Material</span></tt> object. This prevents numerical divide-by-zero issues in the <tt class="docutils literal"><span class="pre">Solver</span></tt>, and is a useful sanity check when modeling (nearly) void regions - <em>e.g.</em>, a fuel pin cell &#8220;gap.&#8221;</p>
</div>
</div>
<div class="section" id="geometry-specification">
<h2>3.4. Geometry Specification<a class="headerlink" href="#geometry-specification" title="Permalink to this headline">¶</a></h2>
<p>The geometry in OpenMOC is described using constructive solid geometry (<a class="reference external" href="http://en.wikipedia.org/wiki/Constructive_solid_geometry">CSG</a>),
also sometimes referred to as combinatorial geometry. CSG allows a user to
create complex objects using Boolean operators on a set of simpler surfaces. In
the geometry model, each unique closed volume is defined by its bounding
surfaces. The CSG formulation used in OpenMOC is described in more detail in <a class="reference internal" href="../methods/constructive_solid_geometry.html#constructive-solid-geometry"><em>Constructive Solid Geometry</em></a>.</p>
<p>The following sections detail how to create surfaces, cells, universes and lattices to construct a simple 4 <img class="math" src="../_images/math/c69691d64985442217922c8d34e835a9dea60178.png" alt="\times"/> 4 pin cell lattice.</p>
<div class="section" id="surfaces">
<h3>3.4.1. Surfaces<a class="headerlink" href="#surfaces" title="Permalink to this headline">¶</a></h3>
<p>In most cases, the first step towards building a reactor geometry is to create the surfaces defining boundaries between distinct regions. The CSG formulation for surfaces in OpenMOC is described in detail in <a class="reference internal" href="../methods/constructive_solid_geometry.html#surfaces-halfspaces"><em>Surfaces and Halfspaces</em></a>. For LWRs, the most typical surfaces needed to model 2D rectangular lattices are the <tt class="docutils literal"><span class="pre">ZCylinder</span></tt>, <tt class="docutils literal"><span class="pre">XPlane</span></tt>, and <tt class="docutils literal"><span class="pre">YPlane</span></tt> classes. The following code snippet illustrates how to create a circle to represent a fuel pin and reflective boundary planes to surround a 4 <img class="math" src="../_images/math/c69691d64985442217922c8d34e835a9dea60178.png" alt="\times"/> 4 lattice.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Initialize circular fuel pin surface with an optional string name</span>
<span class="n">circle</span> <span class="o">=</span> <span class="n">openmoc</span><span class="o">.</span><span class="n">ZCylinder</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mf">0.45</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;fuel radius&#39;</span><span class="p">)</span>

<span class="c"># Initialize the planar surfaces bounding the entire geometry</span>
<span class="c"># with optional string names</span>
<span class="n">left</span> <span class="o">=</span> <span class="n">openmoc</span><span class="o">.</span><span class="n">XPlane</span><span class="p">(</span><span class="n">x</span><span class="o">=-</span><span class="mf">2.52</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;left&#39;</span><span class="p">)</span>
<span class="n">right</span> <span class="o">=</span> <span class="n">openmoc</span><span class="o">.</span><span class="n">XPlane</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mf">2.52</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;right&#39;</span><span class="p">)</span>
<span class="n">bottom</span> <span class="o">=</span> <span class="n">openmoc</span><span class="o">.</span><span class="n">YPlane</span><span class="p">(</span><span class="n">y</span><span class="o">=-</span><span class="mf">2.52</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;bottom&#39;</span><span class="p">)</span>
<span class="n">top</span> <span class="o">=</span> <span class="n">openmoc</span><span class="o">.</span><span class="n">YPlane</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="mf">2.52</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">&#39;top&#39;</span><span class="p">)</span>

<span class="c"># Set the boundary conditions for the bounding planes</span>
<span class="n">left</span><span class="o">.</span><span class="n">setBoundaryType</span><span class="p">(</span><span class="n">openmoc</span><span class="o">.</span><span class="n">REFLECTIVE</span><span class="p">)</span>
<span class="n">right</span><span class="o">.</span><span class="n">setBoundaryType</span><span class="p">(</span><span class="n">openmoc</span><span class="o">.</span><span class="n">REFLECTIVE</span><span class="p">)</span>
<span class="n">bottom</span><span class="o">.</span><span class="n">setBoundaryType</span><span class="p">(</span><span class="n">openmoc</span><span class="o">.</span><span class="n">REFLECTIVE</span><span class="p">)</span>
<span class="n">top</span><span class="o">.</span><span class="n">setBoundaryType</span><span class="p">(</span><span class="n">openmoc</span><span class="o">.</span><span class="n">REFLECTIVE</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="cells-and-universes">
<h3>3.4.2. Cells and Universes<a class="headerlink" href="#cells-and-universes" title="Permalink to this headline">¶</a></h3>
<p>The next step to create a geometry is to instantiate cells which represent unique geometric shapes and use them to construct universes. The CSG formulations for cells and universes in OpenMOC are discussed in further detail in <a class="reference internal" href="../methods/constructive_solid_geometry.html#cells"><em>Cells</em></a> and <a class="reference internal" href="../methods/constructive_solid_geometry.html#universes"><em>Universes</em></a>, respectively. OpenMOC provides the <tt class="docutils literal"><span class="pre">Cell</span></tt> class for regions of space bounded by <tt class="docutils literal"><span class="pre">Surface</span></tt> halfspaces and which may be filled by a <tt class="docutils literal"><span class="pre">Material</span></tt> or <tt class="docutils literal"><span class="pre">Universe</span></tt>. The following code snippet illustrates how to create cells filled by the fuel and moderator materials. Next, the script adds the appropriate halfspace of the circle surface created in the preceding section to each cell.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Retrieve the fuel and moderator materials</span>
<span class="n">uo2</span> <span class="o">=</span> <span class="n">materials</span><span class="p">[</span><span class="s">&#39;UO2&#39;</span><span class="p">]</span>
<span class="n">water</span> <span class="o">=</span> <span class="n">materials</span><span class="p">[</span><span class="s">&#39;Water&#39;</span><span class="p">]</span>

<span class="c"># Initialize the cells for the fuel pin and moderator</span>
<span class="c"># with optional string names</span>
<span class="n">fuel</span> <span class="o">=</span> <span class="n">openmoc</span><span class="o">.</span><span class="n">Cell</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;fuel cell&#39;</span><span class="p">)</span>
<span class="n">moderator</span> <span class="o">=</span> <span class="n">openmoc</span><span class="o">.</span><span class="n">Cell</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;moderator cell&#39;</span><span class="p">)</span>

<span class="c"># Assign the appropriate materials to fill each cell</span>
<span class="n">fuel</span><span class="o">.</span><span class="n">setFill</span><span class="p">(</span><span class="n">uo2</span><span class="p">)</span>
<span class="n">moderator</span><span class="o">.</span><span class="n">setFill</span><span class="p">(</span><span class="n">water</span><span class="p">)</span>

<span class="c"># Add the circle surface to each cell</span>
<span class="n">fuel</span><span class="o">.</span><span class="n">addSurface</span><span class="p">(</span><span class="n">halfspace</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">surface</span><span class="o">=</span><span class="n">circle</span><span class="p">)</span>
<span class="n">moderator</span><span class="o">.</span><span class="n">addSurface</span><span class="p">(</span><span class="n">halfspace</span><span class="o">=+</span><span class="mi">1</span><span class="p">,</span> <span class="n">surface</span><span class="o">=</span><span class="n">circle</span><span class="p">)</span>
</pre></div>
</div>
<p>Each universe is comprised of one or more cells. A <tt class="docutils literal"><span class="pre">Universe</span></tt> can be instantiated and each of the previously created cells added to it as shown in the following snippet.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Initialize a universe with an optional string name</span>
<span class="n">pin_univ</span> <span class="o">=</span> <span class="n">openmoc</span><span class="o">.</span><span class="n">Universe</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;pin universe&#39;</span><span class="p">)</span>

<span class="c"># Add each cell to the universe</span>
<span class="n">pin_univ</span><span class="o">.</span><span class="n">addCell</span><span class="p">(</span><span class="n">fuel</span><span class="p">)</span>
<span class="n">pin_univ</span><span class="o">.</span><span class="n">addCell</span><span class="p">(</span><span class="n">moderator</span><span class="p">)</span>
</pre></div>
</div>
<p>The OpenMOC <tt class="docutils literal"><span class="pre">Cell</span></tt> class may not only be filled with materials, but universes as well. As a result, a geometry may be constructed of a hierarchy of nested cells/universes. A hierarchichal geometry permits a simple treatment of repeating geometric structures on multiple length scales (<em>e.g.</em>, rectangular arrays of fuel pins and fuel assemblies).</p>
<p>OpenMOC does not place a limit on the hierarchical depth - or number of nested universe levels - that a user may define in constructing a geometry. The only limitation is that at the top of the hierarchy, a <em>root</em> cell must encapsulate the entire geometry in a <em>root</em> universe. The following code snippet illustrates the creation of a <tt class="docutils literal"><span class="pre">Cell</span></tt> which is filled by a lattice constructed in the next section. The appropriate halfspaces for the planes defined in the preceding section are added to the cell to enforce boundaries on the portion of the root universe relevant to the geometry.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Initialize a cell filled by a nested lattice with an optional</span>
<span class="c"># string name. This cell resides within the root universe.</span>
<span class="n">root_cell</span> <span class="o">=</span> <span class="n">openmoc</span><span class="o">.</span><span class="n">Cell</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;root cell&#39;</span><span class="p">)</span>
<span class="n">root_cell</span><span class="o">.</span><span class="n">setFill</span><span class="p">(</span><span class="n">lattice</span><span class="p">)</span>

<span class="c"># Add the bounding planar surfaces to the root cell</span>
<span class="n">root_cell</span><span class="o">.</span><span class="n">addSurface</span><span class="p">(</span><span class="n">halfspace</span><span class="o">=+</span><span class="mi">1</span><span class="p">,</span> <span class="n">surface</span><span class="o">=</span><span class="n">left</span><span class="p">)</span>
<span class="n">root_cell</span><span class="o">.</span><span class="n">addSurface</span><span class="p">(</span><span class="n">halfspace</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">surface</span><span class="o">=</span><span class="n">right</span><span class="p">)</span>
<span class="n">root_cell</span><span class="o">.</span><span class="n">addSurface</span><span class="p">(</span><span class="n">halfspace</span><span class="o">=+</span><span class="mi">1</span><span class="p">,</span> <span class="n">surface</span><span class="o">=</span><span class="n">bottom</span><span class="p">)</span>
<span class="n">root_cell</span><span class="o">.</span><span class="n">addSurface</span><span class="p">(</span><span class="n">halfspace</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">surface</span><span class="o">=</span><span class="n">top</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="rings-and-sectors">
<h3>3.4.3. Rings and Sectors<a class="headerlink" href="#rings-and-sectors" title="Permalink to this headline">¶</a></h3>
<p>The spatial <a class="reference external" href="http://en.wikipedia.org/wiki/Discretization">discretization</a> of the geometry is a key determining factor in the accuracy of OpenMOC&#8217;s simulation results. This is especially important since OpenMOC presently uses the <a class="reference internal" href="../methods/method_of_characteristics.html#flat-source-region-approximation"><em>Flat Source Region Approximation</em></a>.  The spatial discretization is most relevant in regions where the flux gradient is greatest. In LWRs composed of cylindrical fuel pins, the flux gradient is largely determined by the distance to the center of the nearest fuel pin and the angle formed between the center of the fuel pin and the point of interest (<em>i.e.</em>, <a class="reference external" href="http://en.wikipedia.org/wiki/Polar_coordinate_system">polar coordinates</a>). As a result, discretization along the radial coordinate using cylindrical <strong>rings</strong>, and along the angular coordinate using angular <strong>sectors</strong> is the most applicable way to discretize the geometry to capture the flux gradient.</p>
<p>This type of discretization is particularly useful for codes which can make use of an <a class="reference external" href="http://en.wikipedia.org/wiki/Unstructured_grid">unstructured mesh</a>, such as OpenMOC with its general <a class="reference internal" href="../methods/constructive_solid_geometry.html#constructive-solid-geometry"><em>Constructive Solid Geometry</em></a> formulation. To subdivide cylindrical fuel pins into rings and sectors in an LWR model would require a substantial amount of work for the user to create the necessary <tt class="docutils literal"><span class="pre">ZCylinder</span></tt> and/or <tt class="docutils literal"><span class="pre">Plane</span></tt> objects. Since this is a commonly needed feature for many users, OpenMOC includes the ability to automatically subdivide cells that contain at least one <tt class="docutils literal"><span class="pre">ZCylinder</span></tt> surface into rings and equally spaced angular sectors. In particular, OpenMOC uses <strong>cell cloning</strong> to create clones (or copies) of a <tt class="docutils literal"><span class="pre">Cell</span></tt> object and differentiates each one with <tt class="docutils literal"><span class="pre">ZCylinder</span></tt> or <tt class="docutils literal"><span class="pre">Plane</span></tt> objects to subdivide the pin cell.</p>
<p>There are three cases where rings can be created in a cell:</p>
<ol class="arabic simple">
<li>A <tt class="docutils literal"><span class="pre">Cell</span></tt> contains one <tt class="docutils literal"><span class="pre">ZCylinder</span></tt> with a negative halfspace.</li>
<li>A <tt class="docutils literal"><span class="pre">Cell</span></tt> contains one <tt class="docutils literal"><span class="pre">ZCylinder</span></tt> with a negative halfspace and one <tt class="docutils literal"><span class="pre">ZCylinder</span></tt> with a positive halfspace.</li>
<li>A <tt class="docutils literal"><span class="pre">Cell</span></tt> contains one <tt class="docutils literal"><span class="pre">ZCylinder</span></tt> with a positive halfspace.</li>
</ol>
<p>Rings for cases 1 and 2 are create such that each ring is of <strong>equal volume</strong>. Rings for cases 3 are created with equal <strong>ring spacing</strong>, where <img class="math" src="../_images/math/a016b6255fbe8008f1fe2a486535b8bca9b2111e.png" alt="(R_{outer} - R_{inner})"/> is the same for all rings. The outer bounding ring for case 3 is set to the distance from the center of the universe that the cell is in to the corner of the parent lattice cell or, if one doesn&#8217;t exist, the geometry bounding box. The rings for case 3 are chosen to have <strong>equal spacing</strong> instead of <strong>equal volume</strong> so that the inner ring (often a moderator ring next to a fuel pin) has a relatively small radius in order to capture the sharp flux gradient outside a fuel pin. The figure below shows a plot for the materials and plots of the cells for cases 1, 2, and 3 where 3 rings have been created for the corresponding cell in each case:</p>
<table border="1" class="docutils" id="figure-annular-pin-rings">
<colgroup>
<col width="24%" />
<col width="25%" />
<col width="25%" />
<col width="26%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="first last reference internal image-reference" href="../_images/annular_pin_materials.png" id="figure-annular-pin-rings-a"><img alt="../_images/annular_pin_materials.png" class="align-left" id="figure-annular-pin-rings-a" src="../_images/annular_pin_materials.png" style="width: 90%;" /></a>
</td>
<td><a class="first last reference internal image-reference" href="../_images/annular_pin_inner_rings.png" id="figure-annular-pin-rings-b"><img alt="../_images/annular_pin_inner_rings.png" class="align-left" id="figure-annular-pin-rings-b" src="../_images/annular_pin_inner_rings.png" style="width: 90%;" /></a>
</td>
<td><a class="first last reference internal image-reference" href="../_images/annular_pin_fuel_rings.png" id="figure-annular-pin-rings-c"><img alt="../_images/annular_pin_fuel_rings.png" class="align-left" id="figure-annular-pin-rings-c" src="../_images/annular_pin_fuel_rings.png" style="width: 90%;" /></a>
</td>
<td><a class="first last reference internal image-reference" href="../_images/annular_pin_outer_rings.png" id="figure-annular-pin-rings-d"><img alt="../_images/annular_pin_outer_rings.png" class="align-left" id="figure-annular-pin-rings-d" src="../_images/annular_pin_outer_rings.png" style="width: 90%;" /></a>
</td>
</tr>
</tbody>
</table>
<p>The following code snippet illustrates how a user may designate a positive integral number of rings and sectors for fuel pin <tt class="docutils literal"><span class="pre">Cells</span></tt> and a positive integral number of sectors with no rings for moderator <tt class="docutils literal"><span class="pre">Cells</span></tt> using the <tt class="docutils literal"><span class="pre">Cell.setNumRings(...)</span></tt> and <tt class="docutils literal"><span class="pre">Cell.setNumSectors(...)</span></tt> class methods.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Subdivide the fuel region into 3 rings and 12 angular sectors</span>
<span class="n">fuel</span><span class="o">.</span><span class="n">setNumRings</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">fuel</span><span class="o">.</span><span class="n">setNumSectors</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>

<span class="c"># Subdivide the moderator region into 4 angular sectors</span>
<span class="n">moderator</span><span class="o">.</span><span class="n">setNumSectors</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>The plots shown below illustrate the pin cell material layout (left) and flat source region layout (right) where the flat source regions have been discretized using 3 equal volume rings and 12 sectors in the fuel and 16 sectors in the moderator.</p>
<table border="1" class="docutils" id="figure-pin-cell-fsrs">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="first last reference internal image-reference" href="../_images/pin-cell-materials.png" id="figure-pin-cell-fsrs-a"><img alt="../_images/pin-cell-materials.png" class="align-right" id="figure-pin-cell-fsrs-a" src="../_images/pin-cell-materials.png" style="width: 50%;" /></a>
</td>
<td><a class="first last reference internal image-reference" href="../_images/pin-cell-fsrs.png" id="figure-pin-cell-fsrs-b"><img alt="../_images/pin-cell-fsrs.png" class="align-left" id="figure-pin-cell-fsrs-b" src="../_images/pin-cell-fsrs.png" style="width: 50%;" /></a>
</td>
</tr>
</tbody>
</table>
<p>As seen in the figure above, the sector divisions start along the plane <img class="math" src="../_images/math/e6bb193313c6dd69aea0a65814c37c3c8522a0f7.png" alt="\pi/4"/> radians clockwise of the horizontal plane. The user may wish to capture gradients in the moderator by adding rings in the moderator. The following code snippet repeats the scenario above, but with 2 rings in the moderator.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Subdivide the fuel region into 3 rings and 12 angular sectors</span>
<span class="n">fuel</span><span class="o">.</span><span class="n">setNumRings</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">fuel</span><span class="o">.</span><span class="n">setNumSectors</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>

<span class="c"># Subdivide the moderator region into 2 rings and 16 angular sectors</span>
<span class="n">moderator</span><span class="o">.</span><span class="n">setNumRings</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">moderator</span><span class="o">.</span><span class="n">setNumSectors</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
</pre></div>
</div>
<p>Again, the pin cell materials are illustrated below on the left, while the flat source regions are displayed on the right with 2 rings now present in the moderator.</p>
<table border="1" class="docutils" id="figure-pin-cell-fsrs-moderator-rings">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="first last reference internal image-reference" href="../_images/pin-cell-materials.png" id="figure-pin-cell-fsrs-moderator-rings-a"><img alt="../_images/pin-cell-materials.png" class="align-right" id="figure-pin-cell-fsrs-moderator-rings-a" src="../_images/pin-cell-materials.png" style="width: 50%;" /></a>
</td>
<td><a class="first last reference internal image-reference" href="../_images/pin-cell-fsrs-moderator-rings.png" id="figure-pin-cell-fsrs-moderator-rings-b"><img alt="../_images/pin-cell-fsrs-moderator-rings.png" class="align-left" id="figure-pin-cell-fsrs-moderator-rings-b" src="../_images/pin-cell-fsrs-moderator-rings.png" style="width: 50%;" /></a>
</td>
</tr>
</tbody>
</table>
<p>Lastly, the rings and sectors can be used to discretize regions between 2 <tt class="docutils literal"><span class="pre">ZCylinder</span></tt> objects, such as annular fuel. The following code snippet discretizes annular fuel into 3 rings and 12 sectors with the inner coolant and outer moderator both discretized into 8 sectors with no rings.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Subdivide the inner coolant region into 8 angular sectors</span>
<span class="n">inner_coolant</span><span class="o">.</span><span class="n">setNumSectors</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>

<span class="c"># Subdivide the annular fuel region into 3 rings and 12 sectors</span>
<span class="n">fuel</span><span class="o">.</span><span class="n">setNumRings</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">fuel</span><span class="o">.</span><span class="n">setNumSectors</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>

<span class="c"># Subdivide the outer moderator region into 8 angular sectors</span>
<span class="n">outer_moderator</span><span class="o">.</span><span class="n">setNumSectors</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
</pre></div>
</div>
<p>The annular pin cell materials are illustrated below on the left, with the resulting fuel and moderator discretization presented on the right.</p>
<table border="1" class="docutils" id="figure-pin-cell-fsrs-moderator-annular">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="first last reference internal image-reference" href="../_images/pin-cell-materials-annular.png" id="figure-pin-cell-fsrs-moderator-annular-a"><img alt="../_images/pin-cell-materials-annular.png" class="align-right" id="figure-pin-cell-fsrs-moderator-annular-a" src="../_images/pin-cell-materials-annular.png" style="width: 50%;" /></a>
</td>
<td><a class="first last reference internal image-reference" href="../_images/pin-cell-fsrs-annular.png" id="figure-pin-cell-fsrs-moderator-annular-b"><img alt="../_images/pin-cell-fsrs-annular.png" class="align-left" id="figure-pin-cell-fsrs-moderator-annular-b" src="../_images/pin-cell-fsrs-annular.png" style="width: 50%;" /></a>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Rings may <strong>only</strong> be used in <tt class="docutils literal"><span class="pre">Cell</span></tt> objects that contain a <tt class="docutils literal"><span class="pre">ZCylinder</span></tt> surface, such as a fuel pin.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Each subdivided region will be filled by the <strong>same Material</strong> as the <tt class="docutils literal"><span class="pre">Cell</span></tt> object created by the user in the Python script.</p>
</div>
</div>
<div class="section" id="lattices">
<h3>3.4.4. Lattices<a class="headerlink" href="#lattices" title="Permalink to this headline">¶</a></h3>
<p>Once the cells for the geometry have been created, OpenMOC&#8217;s <tt class="docutils literal"><span class="pre">Lattice</span></tt> class may be used to represent repeating patterns of the cells on a rectangular array. The CSG formulation for lattices is described further in <a class="reference internal" href="../methods/constructive_solid_geometry.html#lattices"><em>Lattices</em></a>. In OpenMOC, the <tt class="docutils literal"><span class="pre">Lattice</span></tt> class is a subclass of the <tt class="docutils literal"><span class="pre">Universe</span></tt> class. The following code snippet illustrates the creation of a 4 <img class="math" src="../_images/math/c69691d64985442217922c8d34e835a9dea60178.png" alt="\times"/> 4 lattice with each lattice cell filled by the pin universe created earlier. The total width of the lattice in <img class="math" src="../_images/math/188c175aac0a8a9c22499336711b5d7256407254.png" alt="x"/> and <img class="math" src="../_images/math/b124ff74afb0914bb434e8fb849eb56d734412f8.png" alt="y"/> are defined as parameters when the lattice is initialized. The lattice dimensions are used to define the rectangular region of interest centered at the origin of the <tt class="docutils literal"><span class="pre">Universe</span></tt> filling each lattice cell.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Initialize the lattice for the geometry</span>
<span class="n">lattice</span> <span class="o">=</span> <span class="n">openmoc</span><span class="o">.</span><span class="n">Lattice</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;4x4 pin lattice&#39;</span><span class="p">)</span>
<span class="n">lattice</span><span class="o">.</span><span class="n">setWidth</span><span class="p">(</span><span class="n">width_x</span><span class="o">=</span><span class="mf">5.04</span><span class="p">,</span> <span class="n">width_y</span><span class="o">=</span><span class="mf">5.04</span><span class="p">)</span>

<span class="c"># Assign each lattice cell a universe ID</span>
<span class="n">lattice</span><span class="o">.</span><span class="n">setUniverses</span><span class="p">([[</span><span class="n">pin_univ</span><span class="p">,</span> <span class="n">pin_univ</span><span class="p">,</span> <span class="n">pin_univ</span><span class="p">,</span> <span class="n">pin_univ</span><span class="p">],</span>
                      <span class="p">[</span><span class="n">pin_univ</span><span class="p">,</span> <span class="n">pin_univ</span><span class="p">,</span> <span class="n">pin_univ</span><span class="p">,</span> <span class="n">pin_univ</span><span class="p">],</span>
                      <span class="p">[</span><span class="n">pin_univ</span><span class="p">,</span> <span class="n">pin_univ</span><span class="p">,</span> <span class="n">pin_univ</span><span class="p">,</span> <span class="n">pin_univ</span><span class="p">],</span>
                      <span class="p">[</span><span class="n">pin_univ</span><span class="p">,</span> <span class="n">pin_univ</span><span class="p">,</span> <span class="n">pin_univ</span><span class="p">,</span> <span class="n">pin_univ</span><span class="p">]])</span>
</pre></div>
</div>
</div>
<div class="section" id="geometry">
<h3>3.4.5. Geometry<a class="headerlink" href="#geometry" title="Permalink to this headline">¶</a></h3>
<p>The final step in creating a geometry is to instantiate OpenMOC&#8217;s <tt class="docutils literal"><span class="pre">Geometry</span></tt> class. The <tt class="docutils literal"><span class="pre">Geometry</span></tt> class is the <em>root</em> node in a tree data structure which encapsulates all <tt class="docutils literal"><span class="pre">Materials</span></tt>, <tt class="docutils literal"><span class="pre">Surfaces</span></tt>, <tt class="docutils literal"><span class="pre">Cells</span></tt>, <tt class="docutils literal"><span class="pre">Universes</span></tt> and <tt class="docutils literal"><span class="pre">Lattices</span></tt>. The following code snippet illustrates the creation of a <em>root</em> <tt class="docutils literal"><span class="pre">Cell</span></tt> and <tt class="docutils literal"><span class="pre">Universe</span></tt> as well as a <tt class="docutils literal"><span class="pre">Geometry</span></tt> object. Next, the root universe is registered with the geometry. The last line of the script is called once all primitives have been registered and is used to traverse the CSG hierarchy and index the flat source regions in the geometry.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Initialize the root universe object</span>
<span class="n">root_univ</span> <span class="o">=</span> <span class="n">openmoc</span><span class="o">.</span><span class="n">Universe</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;root universe&#39;</span><span class="p">)</span>
<span class="n">root_univ</span><span class="o">.</span><span class="n">addCell</span><span class="p">(</span><span class="n">root_cell</span><span class="p">)</span>

<span class="c"># Initialize an empty geometry object</span>
<span class="n">geometry</span> <span class="o">=</span> <span class="n">openmoc</span><span class="o">.</span><span class="n">Geometry</span><span class="p">()</span>

<span class="c"># Register the root universe with the geometry</span>
<span class="n">geometry</span><span class="o">.</span><span class="n">setRootUniverse</span><span class="p">(</span><span class="n">root_univ</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="track-generation">
<h2>3.5. Track Generation<a class="headerlink" href="#track-generation" title="Permalink to this headline">¶</a></h2>
<p>Once the geometry has been initialized for a simulation, the next step is to perform ray tracing for track generation. The track generation process and algorithms in OpenMOC are described in more detail in <a class="reference internal" href="../methods/track_generation.html#track-generation"><em>Track Generation</em></a>. This step requires the instantiation of a <tt class="docutils literal"><span class="pre">TrackGenerator</span></tt> object and a function call to generate the tracks as illustrated in the following code snippet.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Initialize the track generator after the geometry has been</span>
<span class="c"># constructed. Use 64 azimuthal angles and 0.05 cm track spacing.</span>
<span class="n">track_generator</span> <span class="o">=</span> <span class="n">openmoc</span><span class="o">.</span><span class="n">TrackGenerator</span><span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">num_azim</span><span class="o">=</span><span class="mi">64</span><span class="p">,</span> \
                                         <span class="n">spacing</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>

<span class="c"># Generate tracks using ray tracing across the geometry</span>
<span class="n">track_generator</span><span class="o">.</span><span class="n">generateTracks</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="moc-source-iteration">
<h2>3.6. MOC Source Iteration<a class="headerlink" href="#moc-source-iteration" title="Permalink to this headline">¶</a></h2>
<p>One of OpenMOC&#8217;s <tt class="docutils literal"><span class="pre">Solver</span></tt> subclasses may be initialized given the <tt class="docutils literal"><span class="pre">TrackGenerator</span></tt> objects discussed in the preceding section. The most commonly used subclasses for OpenMOC simulations are itemized below:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">CPUSolver</span></tt> - multi-core CPUs, memory efficient, good parallel scaling <a class="reference internal" href="#cpus" id="id1">[CPUs]</a></li>
<li><tt class="docutils literal"><span class="pre">GPUSolver</span></tt> - GPUs, 30-50 <img class="math" src="../_images/math/c69691d64985442217922c8d34e835a9dea60178.png" alt="\times"/> faster than CPUs <a class="reference internal" href="#gpus" id="id2">[GPUs]</a></li>
</ul>
</div></blockquote>
<div class="section" id="criticality-calculations">
<h3>3.6.1. Criticality Calculations<a class="headerlink" href="#criticality-calculations" title="Permalink to this headline">¶</a></h3>
<p>The following code snippet illustrates the instantiation of the <tt class="docutils literal"><span class="pre">CPUSolver</span></tt> for multi-core CPUs. The code assigns runtime parameters to the solver and calls the <tt class="docutils literal"><span class="pre">computeEigenvalue(...)</span></tt> routine to execute the <a class="reference internal" href="../methods/eigenvalue_calculations.html#figure-overall-iterative-scheme"><em>MOC Source Iteration Algorithm</em></a>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Initialize a solver for the simulation and set the number of</span>
<span class="c"># threads and source convergence threshold</span>
<span class="n">solver</span> <span class="o">=</span> <span class="n">openmoc</span><span class="o">.</span><span class="n">CPUSolver</span><span class="p">(</span><span class="n">track_generator</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">setNumThreads</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">setConvergenceThreshold</span><span class="p">(</span><span class="mf">1E-5</span><span class="p">)</span>

<span class="c"># Converge the source with up to a maximum of 1000 source iterations</span>
<span class="n">solver</span><span class="o">.</span><span class="n">computeEigenvalue</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>

<span class="c"># Print a report of the time to solution</span>
<span class="n">solver</span><span class="o">.</span><span class="n">printTimerReport</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="fixed-source-calculations">
<h3>3.6.2. Fixed Source Calculations<a class="headerlink" href="#fixed-source-calculations" title="Permalink to this headline">¶</a></h3>
<p>It is also possible to add a fixed source to any region in OpenMOC. During computation of the total source, a fixed source is added together with the calculated scattering source and fission source for each flat source region. By default, the fixed source is set to zero everywhere. The <tt class="docutils literal"><span class="pre">setFixedSourceByFSR(...)</span></tt> routine allows the user to set the fixed source in a given flat source region using its unique ID. For most calcuations, setting the fixed source for every flat source region of interest individually can be cumbersome. In addition, this would require retreiving the unique ID for every flat source region in which the user desires to set the fixed source. Therefore, the <tt class="docutils literal"><span class="pre">setFixedSourceByCell(...)</span></tt> routine allows the user to set the fixed source for every flat source region within a cell to a common value. An example is given below for setting the fixed source of a <tt class="docutils literal"><span class="pre">Cell</span></tt> with a point source of unity in the first energy group.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Set the fixed source inside the source cell in group 1 to unity</span>
<span class="n">solver</span><span class="o">.</span><span class="n">setFixedSourceByCell</span><span class="p">(</span><span class="n">source_cell</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
</pre></div>
</div>
<p>The equivalent code for setting the point source of all flat source regions within the source cell using <tt class="docutils literal"><span class="pre">setFixedSourceByFSR(...)</span></tt> is given below.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Get the unique ID of the cell containing the point source</span>
<span class="n">point_source_cell_id</span> <span class="o">=</span> <span class="n">source_cell</span><span class="o">.</span><span class="n">getId</span><span class="p">()</span>

<span class="c"># Loop over all FSRs and test if the FSR is within the point source cell</span>
<span class="k">for</span> <span class="n">fsr_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">solver</span><span class="o">.</span><span class="n">getGeometry</span><span class="p">()</span><span class="o">.</span><span class="n">getNumFSRs</span><span class="p">()):</span>
  <span class="n">cell</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">getGeometry</span><span class="p">()</span><span class="o">.</span><span class="n">findCellContainingFSR</span><span class="p">(</span><span class="n">fsr_id</span><span class="p">)</span>

  <span class="c"># If the FSR is within the point source cell, set the fixed source</span>
  <span class="k">if</span> <span class="n">cell</span><span class="o">.</span><span class="n">getId</span><span class="p">()</span> <span class="o">==</span> <span class="n">point_source_cell_id</span><span class="p">:</span>
    <span class="n">solver</span><span class="o">.</span><span class="n">setFixedSourceByFSR</span><span class="p">(</span><span class="n">fsr_id</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
</pre></div>
</div>
<p>In this case, it is far simpler to set the fixed source by <tt class="docutils literal"><span class="pre">Cell</span></tt>. However, there may be cases where the user may wish to set the fixed source within a <tt class="docutils literal"><span class="pre">Cell</span></tt> to different values. For instance, if the user wishes to model a continuously varying fixed source and there are multiple flat source regions within some <tt class="docutils literal"><span class="pre">Cell</span></tt>, then for each flat source region within the cell the fixed source would need to be set individually.</p>
<p>For instance, if the user desires to input a source based on the location within the geometry, setting the source with <tt class="docutils literal"><span class="pre">setFixedSourceByFSR(...)</span></tt> could be useful. In particular if a user has defined a fucntion <tt class="docutils literal"><span class="pre">source_distribution</span></tt> which provides the source over the flat source regions that depends on the coordinates within the geometry and the energy group, the following code will set the source to the appropriate values.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Set the source every cell to the desired distribution</span>
<span class="k">for</span> <span class="n">fsr_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">solver</span><span class="o">.</span><span class="n">getGeometry</span><span class="p">()</span><span class="o">.</span><span class="n">getNumFSRs</span><span class="p">()):</span>

  <span class="c"># Get the coordinates of some point within the FSR</span>
  <span class="n">pt</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">getGeometry</span><span class="p">()</span><span class="o">.</span><span class="n">getFSRPoint</span><span class="p">(</span><span class="n">fsr_id</span><span class="p">)</span>
  <span class="n">x_pt</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">getX</span><span class="p">()</span>
  <span class="n">y_pt</span> <span class="o">=</span> <span class="n">pt</span><span class="o">.</span><span class="n">getY</span><span class="p">()</span>

  <span class="c"># Set the FSR source for every group</span>
  <span class="n">L</span> <span class="o">=</span> <span class="n">num_x</span> <span class="o">*</span> <span class="n">width_x</span> <span class="o">/</span> <span class="mi">2</span>
  <span class="n">H</span> <span class="o">=</span> <span class="n">num_y</span> <span class="o">*</span> <span class="n">width_y</span> <span class="o">/</span> <span class="mi">2</span>
  <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">materials</span><span class="p">[</span><span class="s">&#39;Water&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">getNumEnergyGroups</span><span class="p">()):</span>
    <span class="n">group</span> <span class="o">=</span> <span class="n">g</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">source_value</span> <span class="o">=</span> <span class="n">source_distribution</span><span class="p">(</span><span class="n">x_pt</span><span class="p">,</span> <span class="n">y_pt</span><span class="p">,</span> <span class="n">group</span><span class="p">)</span>
    <span class="n">solver</span><span class="o">.</span><span class="n">setFixedSourceByFSR</span><span class="p">(</span><span class="n">fsr_id</span><span class="p">,</span> <span class="n">group</span><span class="p">,</span> <span class="n">source_value</span><span class="p">)</span>
</pre></div>
</div>
<p>The OpenMOC <tt class="docutils literal"><span class="pre">Solver</span></tt> has other solution options in addition to the eigenvalue solver which can be very useful for fixed source calculations. Specifically, the <tt class="docutils literal"><span class="pre">computeFlux(...)</span></tt> and <tt class="docutils literal"><span class="pre">computeSource(...)</span></tt> routines solve neutron transport over the problem without computing an eigenvalue.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The fixed source can <strong>only</strong> be set <strong>after</strong> <tt class="docutils literal"><span class="pre">TrackGenerator</span></tt> has generated tracks</p>
</div>
</div>
<div class="section" id="flux-calculations">
<h3>3.6.3. Flux Calculations<a class="headerlink" href="#flux-calculations" title="Permalink to this headline">¶</a></h3>
<p>For many fixed source calculations, there is no fissionable material in the problem and the user simply desires the flux distribution within the specified geometry. For these problems the <tt class="docutils literal"><span class="pre">computeFlux(...)</span></tt> routine calculates the flux distribution within the geometry without computing any sources. Only the fixed source specified by the user is used to determine the total source distribution. This mode can be useful for solving problems where the user already knows the total neutron source distribution.</p>
<p>To illustrate the effect of this solver, a fixed source problem is chosen. This problem involves a <img class="math" src="../_images/math/37d7bde56fa6e58fe579cc52c6a770a699ad763c.png" alt="200 \times 200"/> grid of water cells with a cell in the upper left filled with a fixed source in the first group. A code snippet is presented below showing the initialization of the source and solver for this problem.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Initialize the OpenMOC solver</span>
<span class="n">solver</span> <span class="o">=</span> <span class="n">openmoc</span><span class="o">.</span><span class="n">CPUSolver</span><span class="p">(</span><span class="n">track_generator</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">setNumThreads</span><span class="p">(</span><span class="n">num_threads</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">setConvergenceThreshold</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span>

<span class="c"># Set the flux in the source cell to unity and compute the flux</span>
<span class="n">solver</span><span class="o">.</span><span class="n">setFixedSourceByCell</span><span class="p">(</span><span class="n">source_cell</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">computeFlux</span><span class="p">(</span><span class="n">max_iters</span><span class="p">)</span>
</pre></div>
</div>
<p>The first group flux is plotted below. All other flux plots are zero throughout the entire geometry because the scattering source is not accounted for in <tt class="docutils literal"><span class="pre">computeFlux(...)</span></tt> and neutrons are always born in the first group. By using the <tt class="docutils literal"><span class="pre">computeFlux(...)</span></tt> routine, OpenMOC is directed to only use the provided fixed source and not to update for fission or scattering. Notice that there are prominent ray effects since there is no scattering in this problem, an inherent characteristic of MOC solvers. The MOC solver is defined with 4 azimuthal angles for the figure on the left and 32 azimuthal angles for the figure on the right. As the number of angles increases, the effect is not as noticeable but is still present.</p>
<table border="1" class="docutils" id="figure-fixed-source-flux-calc">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="first last reference internal image-reference" href="../_images/fs-flux-calc-4-angles-group-1.png" id="figure-fixed-source-flux-calc-a"><img alt="../_images/fs-flux-calc-4-angles-group-1.png" class="align-right" id="figure-fixed-source-flux-calc-a" src="../_images/fs-flux-calc-4-angles-group-1.png" style="width: 50%;" /></a>
</td>
<td><a class="first last reference internal image-reference" href="../_images/fs-flux-calc-32-angles-group-1.png" id="figure-fixed-source-flux-calc-b"><img alt="../_images/fs-flux-calc-32-angles-group-1.png" class="align-left" id="figure-fixed-source-flux-calc-b" src="../_images/fs-flux-calc-32-angles-group-1.png" style="width: 50%;" /></a>
</td>
</tr>
</tbody>
</table>
<p>While this case seems ill-suited for the <tt class="docutils literal"><span class="pre">computeFlux(...)</span></tt> routine, <tt class="docutils literal"><span class="pre">computeFlux(...)</span></tt> is very useful for cases where the total source is known and can be defined by the user. For instance, if the total source <img class="math" src="../_images/math/98f322d8c1c9382fbb7594b3ce36d35fcd638299.png" alt="S_g"/> for energy group <img class="math" src="../_images/math/67f4714f065d485540ad40829e0717bf75e9dd85.png" alt="g"/> is defined to be a cosine distribution such as</p>
<div class="math">
<p><img src="../_images/math/65446c761c4d1cccc49a94cfbf7322e2d4094613.png" alt="S_g(x,y) = S_g(0,0) \cos{\frac{x}{L}} \cos{\frac{y}{H}}"/></p>
</div><p>where the geometry spans <img class="math" src="../_images/math/a425a0b90fc7c0fd908d1ef77bccf0af133be675.png" alt="x \in (-L, L)"/> and <img class="math" src="../_images/math/672aa6082bea3d4e5239fffa734939707ee66d4a.png" alt="y \in (-H, H)"/>. The source can be set using <tt class="docutils literal"><span class="pre">setFixedSourceByFSR(...)</span></tt> as described above. If the geometry is filled entirely with water and the <tt class="docutils literal"><span class="pre">computeFlux(...)</span></tt> routine is used to resolve the flux, the solver accurately computes the flux distribution as plotted below.</p>
<div class="align-center figure" id="figure-cosine-flux-distribution">
<a class="reference internal image-reference" href="../_images/cosine_flux_distribution.png"><img alt="../_images/cosine_flux_distribution.png" src="../_images/cosine_flux_distribution.png" style="width: 400px;" /></a>
</div>
</div>
<div class="section" id="source-calculations">
<h3>3.6.4. Source Calculations<a class="headerlink" href="#source-calculations" title="Permalink to this headline">¶</a></h3>
<p>In other problems, the source distribution is desired for a set eigenvalue. For this case, the <tt class="docutils literal"><span class="pre">computeSource(...)</span></tt> routine can be used, which calculates the total source (including any fixed source) in each flat source region iteratively. At the end of each transport sweep, the eigenvalue is reset to the eigenvalue set by the user. By default this value is 1.0. Returning to the first problem discussed using the <tt class="docutils literal"><span class="pre">computeFlux(...)</span></tt> routine where a fixed source was placed in a geometry filled with water, the <tt class="docutils literal"><span class="pre">computeFlux(...)</span></tt> routine could not account for scattering. Since the <tt class="docutils literal"><span class="pre">computeSource(...)</span></tt> routine computes both scattering and fission sources during transport sweeps, it is able to account for scattering and compute the correct flux distribution. The line below shows how the <tt class="docutils literal"><span class="pre">computeSource(...)</span></tt> routine can be called.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">solver</span><span class="o">.</span><span class="n">computeSource</span><span class="p">(</span><span class="n">max_iters</span><span class="p">)</span>
</pre></div>
</div>
<p>The resulting flux distribution in the third energy group (which previously was calculated to be zero everywhere) is shown below using 4 azimuthal angles in the figure to the left and 32 azimuthal angles in the figure to the right. Notice that ray effects are still present when a low number of azimuthal angles are used, but the effects are far less extreme than observed with <tt class="docutils literal"><span class="pre">computeFlux(...)</span></tt> due to scattering and with 32 azimuthal angles, the ray effects have largely disappeared.</p>
<table border="1" class="docutils" id="figure-fixed-source-calc">
<colgroup>
<col width="50%" />
<col width="50%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="first last reference internal image-reference" href="../_images/fs-4-angles-group-3.png" id="figure-fixed-source-calc-a"><img alt="../_images/fs-4-angles-group-3.png" class="align-right" id="figure-fixed-source-calc-a" src="../_images/fs-4-angles-group-3.png" style="width: 50%;" /></a>
</td>
<td><a class="first last reference internal image-reference" href="../_images/fs-32-angles-group-3.png" id="figure-fixed-source-calc-b"><img alt="../_images/fs-32-angles-group-3.png" class="align-left" id="figure-fixed-source-calc-b" src="../_images/fs-32-angles-group-3.png" style="width: 50%;" /></a>
</td>
</tr>
</tbody>
</table>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">This calculation mode has not yet been thoroughly tested</p>
</div>
</div>
<div class="section" id="convergence-options">
<h3>3.6.5. Convergence Options<a class="headerlink" href="#convergence-options" title="Permalink to this headline">¶</a></h3>
<p>There are a variety of convergence options available in OpenMOC. These options can be set in the <tt class="docutils literal"><span class="pre">res_type</span></tt> optional parameter of the <tt class="docutils literal"><span class="pre">computeEigenvalue(...)</span></tt> and <tt class="docutils literal"><span class="pre">computeSource(...)</span></tt> solvers. The options for <tt class="docutils literal"><span class="pre">res_type</span></tt> are:</p>
<ul class="simple">
<li><strong>SCALAR_FLUX</strong> - Sets the convergence based on the enegy-integrated scalar flux by each flat source region. This is the convergence criteria for <tt class="docutils literal"><span class="pre">computeFlux(...)</span></tt>.</li>
<li><strong>TOTAL_SOURCE</strong> - Sets the convergence based on the energy-integrated total source by each flat source region. This is the default for <tt class="docutils literal"><span class="pre">computeSource(...)</span></tt>.</li>
<li><strong>FISSION_SOURCE</strong> - Sets the convergence based on the energy-integrated fission source by each flat source region. This is the default for <tt class="docutils literal"><span class="pre">computeEigenvalue(...)</span></tt>.</li>
</ul>
<p>An example of setting the convergence option of a criticality calculation to the scalar flux is given below.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Compute the eigenvlaue with a maximum of 1000 source iterations</span>
<span class="c"># and converge by the scalar flux</span>
<span class="n">solver</span><span class="o">.</span><span class="n">computeEigenvalue</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="n">res_type</span><span class="o">=</span><span class="n">openmoc</span><span class="o">.</span><span class="n">SCALAR_FLUX</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="polar-quadrature">
<h3>3.6.6. Polar Quadrature<a class="headerlink" href="#polar-quadrature" title="Permalink to this headline">¶</a></h3>
<p>In OpenMOC, there are five included polar quadrature sets that couple with the standard constant-angle azimuthal quadrature set. These include equal angles, equal weights, Gauss Legendre, Leonard, and Tabuchi Yamamoto polar quadrature sets. Users can also input a custom polar quadrature set by manually setting the weights and sines of the polar angles. Example code on how to create the 6 polar quadrature sets is included below.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">openmoc</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="o">...</span>

<span class="c"># Create a Tabuchi Yamamoto PolarQuad object with 3 polar angles</span>
<span class="n">ty_polar_quad</span> <span class="o">=</span> <span class="n">openmoc</span><span class="o">.</span><span class="n">TYPolarQuad</span><span class="p">()</span>
<span class="n">ty_polar_quad</span><span class="o">.</span><span class="n">setNumPolarAngles</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

<span class="c"># Create a Gauss Legendre PolarQuad object with 3 polar angles</span>
<span class="n">gl_polar_quad</span> <span class="o">=</span> <span class="n">openmoc</span><span class="o">.</span><span class="n">GLPolarQuad</span><span class="p">()</span>
<span class="n">gl_polar_quad</span><span class="o">.</span><span class="n">setNumPolarAngles</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

<span class="c"># Create a Leonard PolarQuad object with 3 polar angles</span>
<span class="n">leonard_polar_quad</span> <span class="o">=</span> <span class="n">openmoc</span><span class="o">.</span><span class="n">LeonardPolarQuad</span><span class="p">()</span>
<span class="n">leonard_polar_quad</span><span class="o">.</span><span class="n">setNumPolarAngles</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

<span class="c"># Create an Equal Weights PolarQuad object with 3 polar angles</span>
<span class="n">ew_polar_quad</span> <span class="o">=</span> <span class="n">openmoc</span><span class="o">.</span><span class="n">EqualWeightsPolarQuad</span><span class="p">()</span>
<span class="n">ew_polar_quad</span><span class="o">.</span><span class="n">setNumPolarAngles</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

<span class="c"># Create an Equal Angles PolarQuad object with 3 polar angles</span>
<span class="n">ea_polar_quad</span> <span class="o">=</span> <span class="n">openmoc</span><span class="o">.</span><span class="n">EqualAnglesPolarQuad</span><span class="p">()</span>
<span class="n">ea_polar_quad</span><span class="o">.</span><span class="n">setNumPolarAngles</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

<span class="c"># Create a Custom PolarQuad object with 3 polar angles</span>
<span class="n">custom_polar_quad</span> <span class="o">=</span> <span class="n">openmoc</span><span class="o">.</span><span class="n">EqualAnglesPolarQuad</span><span class="p">()</span>
<span class="n">custom_polar_quad</span><span class="o">.</span><span class="n">setNumPolarAngles</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="n">thetas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">20.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">3.0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">2.5</span><span class="p">])</span>
<span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">])</span>
<span class="n">sin_thetas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">thetas</span><span class="p">)</span>
<span class="n">custom_polar_quad</span><span class="o">.</span><span class="n">setSinThetas</span><span class="p">(</span><span class="n">sin_thetas</span><span class="p">)</span>
<span class="n">custom_polar_quad</span><span class="o">.</span><span class="n">setWeights</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
<span class="o">...</span>
</pre></div>
</div>
<p>In order for a user specified quadrature set to be used in solving an MOC problem, it needs to be given to the Solver object. Example code on how to assign a polar quadrature set to a Solver and plot the polar quadrature set associated with the Solver is included below.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">openmoc</span>

<span class="o">...</span>

<span class="c"># Create a Leonard PolarQuad object with 3 polar angles</span>
<span class="n">leonard_polar_quad</span> <span class="o">=</span> <span class="n">openmoc</span><span class="o">.</span><span class="n">LeonardPolarQuad</span><span class="p">()</span>
<span class="n">leonard_polar_quad</span><span class="o">.</span><span class="n">setNumPolarAngles</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

<span class="c"># Create a CPUSolver and give it the Leonard PolarQuad object</span>
<span class="n">solver</span> <span class="o">=</span> <span class="n">openmoc</span><span class="o">.</span><span class="n">CPUSolver</span><span class="p">(</span><span class="n">track_generator</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">setPolarQuadrature</span><span class="p">(</span><span class="n">leonard_polar_quad</span><span class="p">)</span>
<span class="n">solver</span><span class="o">.</span><span class="n">computeEigenvalue</span><span class="p">()</span>

<span class="c"># Plot the quadrature set used in the solver</span>
<span class="n">openmoc</span><span class="o">.</span><span class="n">plotter</span><span class="o">.</span><span class="n">plot_quadrature</span><span class="p">(</span><span class="n">solver</span><span class="p">)</span>
<span class="o">...</span>
</pre></div>
</div>
<p>Plots of the six quadrature sets with 3 polar angles and 16 azimuthal angles are shown in <a class="reference internal" href="#figure-polar-quads"><em>Figure 4</em></a>.</p>
<div class="align-center figure" id="figure-polar-quads">
<a class="reference internal image-reference" href="../_images/polar_quadrature_sets.png"><img alt="../_images/polar_quadrature_sets.png" src="../_images/polar_quadrature_sets.png" style="width: 1000px;" /></a>
<p class="caption"><strong>Figure 4</strong>: Polar quadrature sets with 3 polar angles and 16 azimuthal angles.</p>
</div>
<p>The quadrature recommended by <a class="reference internal" href="#yamamoto" id="id3">[Yamamoto]</a> is used by default for the polar angles and weights in OpenMOC.</p>
</div>
<div class="section" id="fsr-volume-correction">
<h3>3.6.7. FSR Volume Correction<a class="headerlink" href="#fsr-volume-correction" title="Permalink to this headline">¶</a></h3>
<p>To be updated...</p>
</div>
</div>
<div class="section" id="cmfd-acceleration">
<h2>3.7. CMFD Acceleration<a class="headerlink" href="#cmfd-acceleration" title="Permalink to this headline">¶</a></h2>
<p>OpenMOC has an integrated CMFD acceleration framework that allows users to greatly accelerate the convergence of their neutron transport problems and achieve run-time time improvements of over 30 times. The CMFD acceleration framework is implemented in one class, <tt class="docutils literal"><span class="pre">Cmfd</span></tt>. Running a simulation with CMFD acceleration is quite easy and requires only a few additional lines of code in your input file and one command line option. The following code snippet illustrates the instantiation of the <tt class="docutils literal"><span class="pre">Cmfd</span></tt> class used to generate the CMFD mesh for your problem and give that mesh to the geometry.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Initialize the Cmfd object</span>
<span class="n">cmfd</span> <span class="o">=</span> <span class="n">Cmfd</span><span class="p">()</span>
<span class="n">cmfd</span><span class="o">.</span><span class="n">setLatticeStructure</span><span class="p">(</span><span class="mi">17</span><span class="p">,</span><span class="mi">17</span><span class="p">)</span>

<span class="c"># Optional CMFD parameters</span>
<span class="n">cmfd</span><span class="o">.</span><span class="n">setGroupStructure</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">])</span>
<span class="n">cmfd</span><span class="o">.</span><span class="n">setOpticallyThick</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
<span class="n">cmfd</span><span class="o">.</span><span class="n">setSORRelaxationFactor</span><span class="p">(</span><span class="mf">1.5</span><span class="p">)</span>
<span class="n">cmfd</span><span class="o">.</span><span class="n">setConvergenceThreshold</span><span class="p">(</span><span class="mf">1.E-8</span><span class="p">)</span>
<span class="n">cmfd</span><span class="o">.</span><span class="n">setFluxUpdateOn</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>

<span class="c"># Initialize the Geometry object</span>
<span class="n">geometry</span> <span class="o">=</span> <span class="n">Geometry</span><span class="p">()</span>
<span class="n">geometry</span><span class="o">.</span><span class="n">setCmfd</span><span class="p">(</span><span class="n">cmfd</span><span class="p">)</span>
<span class="o">...</span>
</pre></div>
</div>
<p>These lines of code should be placed in your input file at the location where the geometry object would be initialize had your problem been set up without CMFD acceleration. In this code, the cmfd object is initialized and the CMFD mesh lattice structure is set. In is generally best to have the CMFD mesh overlap with either the assembly or pincell mesh of the problem, but OpenMOC is designed to accept any regular mesh structure. The optional parameters are described below:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">setFluxUpdateOn</span></tt> (default: True) - This function is included to give the users the option to overlay the CMFD mesh, but toggle the CMFD update. If the CMFD mesh breaks up any parts of the geometry, this function be can be used to overlay the CMFD mesh for segmentation, but not perform a CMFD solve and flux update after each MOC iteration. This is useful in comparing runs with and without CMFD and ensuring the exact same segments are used.</li>
<li><tt class="docutils literal"><span class="pre">setGroupStructure</span></tt> (default: same as MOC group structure) - OpenMOC is able to perform CMFD on a coarse energy group structure to allow fine energy group problems to be accelerated with CMFD without incurring a significant computational overhead for CMFD. This function takes a python list as input with the first value of 1 (to indicate the first energy group) followed by an increasing values ending with the number of energy groups plus 1. In the example above, a 7 group MOC problem is broken up into 2 energy groups for CMFD.</li>
<li><tt class="docutils literal"><span class="pre">setOpticallyThick</span></tt> (default: False) - OpenMOC uses a correction factor on the material diffusion coefficients as described in the Theory and Methodology section. This correction factor is turned off by default.</li>
<li><tt class="docutils literal"><span class="pre">setSORRelaxationFactor</span></tt> (default: 1.0) - As described in the Theory and Methodology section, OpenMOC use the successive over-relaxation method (SOR) to solve the CMFD diffusion eigenvalue problem. The SOR method can use an over-relaxation factor to speed up the convergence of problems. Valid input for the SOR relaxation factor are values between 0 and 2. By default the SOR factor is set to 1.0, reducing the SOR method to the Gauss-Seidel method.</li>
<li><tt class="docutils literal"><span class="pre">setConvergenceThreshold</span></tt> (default: 1.E-7) - This method is used to set the convergence of the root-mean-square-error on the region and group wise fission source of the CMFD diffusion eigenvalue problem. By default, the convergence threshold is set at 1.E-7 and is sufficient for most problems.</li>
</ul>
</div></blockquote>
<p>With those few additional lines of code, you should be able to create an input file for any problem and utilize CMFD acceleration. The input file <tt class="docutils literal"><span class="pre">c5g7-cmfd.py</span></tt> provides a good example of how an input file is constructed that uses CMFD acceleration.</p>
</div>
<div class="section" id="references">
<h2>3.8. References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<table class="docutils citation" frame="void" id="cpus" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[CPUs]</a></td><td>William Boyd, Kord Smith, Benoit Forget, and Andrew Siegel, &#8220;Parallel Performance Results for the OpenMOC Method of Characteristics Code on Multi-Core Platforms.&#8221; <em>Submitted to the Proceedings of PHYSOR</em>, Kyoto, Japan (2014).</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="gpus" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[GPUs]</a></td><td>William Boyd, Kord Smith, and Benoit Forget, &#8220;A Massively Parallel Method of Characteristic Neutral Particle Transport Code for GPUs.&#8221; <em>Proc. Int&#8217;l Conf. Math. and Comp. Methods Appl. to Nucl. Sci. and Eng.</em>, Sun Valley, ID, USA (2013).</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="yamamoto" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[Yamamoto]</a></td><td><ol class="first last upperalpha simple">
<li>Yamamoto, M. Tabuchi, N. Sugimura, T. Ushio and M. Mori, &#8220;Derivation of Optimum Polar Angle Quadrature Set for the Method of Characteristics Based on Approximation Error for the Bickley Function.&#8221; <em>Journal of Nuclear Science and Engineering</em>, <strong>44(2)</strong>, pp. 129-136 (2007).</li>
</ol>
</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/openmoc-logo-sphinx-small.png" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">3. Writing Python Input Files</a><ul>
<li><a class="reference internal" href="#simulation-parameters">3.1. Simulation Parameters</a></li>
<li><a class="reference internal" href="#simulation-log-files">3.2. Simulation Log Files</a></li>
<li><a class="reference internal" href="#materials-specification">3.3. Materials Specification</a></li>
<li><a class="reference internal" href="#geometry-specification">3.4. Geometry Specification</a><ul>
<li><a class="reference internal" href="#surfaces">3.4.1. Surfaces</a></li>
<li><a class="reference internal" href="#cells-and-universes">3.4.2. Cells and Universes</a></li>
<li><a class="reference internal" href="#rings-and-sectors">3.4.3. Rings and Sectors</a></li>
<li><a class="reference internal" href="#lattices">3.4.4. Lattices</a></li>
<li><a class="reference internal" href="#geometry">3.4.5. Geometry</a></li>
</ul>
</li>
<li><a class="reference internal" href="#track-generation">3.5. Track Generation</a></li>
<li><a class="reference internal" href="#moc-source-iteration">3.6. MOC Source Iteration</a><ul>
<li><a class="reference internal" href="#criticality-calculations">3.6.1. Criticality Calculations</a></li>
<li><a class="reference internal" href="#fixed-source-calculations">3.6.2. Fixed Source Calculations</a></li>
<li><a class="reference internal" href="#flux-calculations">3.6.3. Flux Calculations</a></li>
<li><a class="reference internal" href="#source-calculations">3.6.4. Source Calculations</a></li>
<li><a class="reference internal" href="#convergence-options">3.6.5. Convergence Options</a></li>
<li><a class="reference internal" href="#polar-quadrature">3.6.6. Polar Quadrature</a></li>
<li><a class="reference internal" href="#fsr-volume-correction">3.6.7. FSR Volume Correction</a></li>
</ul>
</li>
<li><a class="reference internal" href="#cmfd-acceleration">3.7. CMFD Acceleration</a></li>
<li><a class="reference internal" href="#references">3.8. References</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="install.html"
                        title="previous chapter">2. Installation and Configuration</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="processing.html"
                        title="next chapter">4. Data Processing and Visualization</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/usersguide/input.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="processing.html" title="4. Data Processing and Visualization"
             >next</a> |</li>
        <li class="right" >
          <a href="install.html" title="2. Installation and Configuration"
             >previous</a> |</li>
        <li><a href="../index.html">OpenMOC Documentation</a> &raquo;</li>
          <li><a href="index.html" >User&#8217;s Guide</a> &raquo;</li> 
      </ul>
    </div>

    <div class="footer">
        &copy; Copyright 2012-2014, Massachusetts Institute of Technology.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-30411614-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

  </body>
</html>