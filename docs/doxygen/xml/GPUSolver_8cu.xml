<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.1.2">
  <compounddef id="GPUSolver_8cu" kind="file">
    <compoundname>GPUSolver.cu</compoundname>
    <includes refid="GPUSolver_8h" local="yes">GPUSolver.h</includes>
    <incdepgraph>
      <node id="47">
        <label>clone.h</label>
        <link refid="clone_8h_source"/>
        <childnode refid="48" relation="include">
        </childnode>
        <childnode refid="49" relation="include">
        </childnode>
      </node>
      <node id="42">
        <label>GPUSolver.h</label>
        <link refid="GPUSolver_8h"/>
        <childnode refid="43" relation="include">
        </childnode>
        <childnode refid="44" relation="include">
        </childnode>
        <childnode refid="45" relation="include">
        </childnode>
        <childnode refid="46" relation="include">
        </childnode>
        <childnode refid="47" relation="include">
        </childnode>
      </node>
      <node id="43">
        <label>thrust/reduce.h</label>
      </node>
      <node id="45">
        <label>sm_13_double_functions.h</label>
      </node>
      <node id="46">
        <label>sm_20_atomic_functions.h</label>
      </node>
      <node id="44">
        <label>thrust/device_vector.h</label>
      </node>
      <node id="41">
        <label>/home/wbinventor/NSE-CRPG-Codes/OpenMOC/src/dev/gpu/GPUSolver.cu</label>
        <link refid="GPUSolver.cu"/>
        <childnode refid="42" relation="include">
        </childnode>
      </node>
      <node id="49">
        <label>../DeviceTrack.h</label>
        <link refid="DeviceTrack_8h"/>
      </node>
      <node id="48">
        <label>../DeviceMaterial.h</label>
        <link refid="DeviceMaterial_8h"/>
      </node>
    </incdepgraph>
      <sectiondef kind="var">
      <memberdef kind="variable" id="GPUSolver_8cu_1acaa01780edc3284de962b0d61586c48d" prot="public" static="no" mutable="no">
        <type>__constant__ int</type>
        <definition>__constant__ int num_azim[1]</definition>
        <argsstring>[1]</argsstring>
        <name>num_azim</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The number of azimuthal angles </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/wbinventor/NSE-CRPG-Codes/OpenMOC/src/dev/gpu/GPUSolver.cu" line="5" bodyfile="/home/wbinventor/NSE-CRPG-Codes/OpenMOC/src/dev/gpu/GPUSolver.cu" bodystart="5" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="GPUSolver_8cu_1a3c9e0caaa1019a39b3b23336c89f7099" prot="public" static="no" mutable="no">
        <type>__constant__ int</type>
        <definition>__constant__ int num_groups[1]</definition>
        <argsstring>[1]</argsstring>
        <name>num_groups</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The number of energy groups </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/wbinventor/NSE-CRPG-Codes/OpenMOC/src/dev/gpu/GPUSolver.cu" line="8" bodyfile="/home/wbinventor/NSE-CRPG-Codes/OpenMOC/src/dev/gpu/GPUSolver.cu" bodystart="8" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="GPUSolver_8cu_1aa7703ed59688b19ccf47e9d14f65c6d6" prot="public" static="no" mutable="no">
        <type>__constant__ int</type>
        <definition>__constant__ int num_FSRs[1]</definition>
        <argsstring>[1]</argsstring>
        <name>num_FSRs</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The number of flat source regions </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/wbinventor/NSE-CRPG-Codes/OpenMOC/src/dev/gpu/GPUSolver.cu" line="11" bodyfile="/home/wbinventor/NSE-CRPG-Codes/OpenMOC/src/dev/gpu/GPUSolver.cu" bodystart="11" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="GPUSolver_8cu_1a2032dcf31e782449dc63dd7ae11fe877" prot="public" static="no" mutable="no">
        <type>__constant__ int</type>
        <definition>__constant__ int num_polar[1]</definition>
        <argsstring>[1]</argsstring>
        <name>num_polar</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The number of polar angles </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/wbinventor/NSE-CRPG-Codes/OpenMOC/src/dev/gpu/GPUSolver.cu" line="14" bodyfile="/home/wbinventor/NSE-CRPG-Codes/OpenMOC/src/dev/gpu/GPUSolver.cu" bodystart="14" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="GPUSolver_8cu_1a4172c0125fe91bf2b8f9d393a4a408eb" prot="public" static="no" mutable="no">
        <type>__constant__ int</type>
        <definition>__constant__ int two_times_num_polar[1]</definition>
        <argsstring>[1]</argsstring>
        <name>two_times_num_polar</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>Twice the number of polar angles </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/wbinventor/NSE-CRPG-Codes/OpenMOC/src/dev/gpu/GPUSolver.cu" line="17" bodyfile="/home/wbinventor/NSE-CRPG-Codes/OpenMOC/src/dev/gpu/GPUSolver.cu" bodystart="17" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="GPUSolver_8cu_1a8e52be9dd116ed6eb92d6bfc4975891f" prot="public" static="no" mutable="no">
        <type>__constant__ int</type>
        <definition>__constant__ int polar_times_groups[1]</definition>
        <argsstring>[1]</argsstring>
        <name>polar_times_groups</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The number of polar angles times energy groups </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/wbinventor/NSE-CRPG-Codes/OpenMOC/src/dev/gpu/GPUSolver.cu" line="20" bodyfile="/home/wbinventor/NSE-CRPG-Codes/OpenMOC/src/dev/gpu/GPUSolver.cu" bodystart="20" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="GPUSolver_8cu_1a41bd77d68a072379c50ab3f66ac580e9" prot="public" static="no" mutable="no">
        <type>__constant__ FP_PRECISION</type>
        <definition>__constant__ FP_PRECISION sinthetas[MAX_POLAR_ANGLES]</definition>
        <argsstring>[MAX_POLAR_ANGLES]</argsstring>
        <name>sinthetas</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>An array for the sines of the polar angle in the polar quadrature set </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/wbinventor/NSE-CRPG-Codes/OpenMOC/src/dev/gpu/GPUSolver.cu" line="23" bodyfile="/home/wbinventor/NSE-CRPG-Codes/OpenMOC/src/dev/gpu/GPUSolver.cu" bodystart="23" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="GPUSolver_8cu_1a1a43334097502e9e6041797794cf22a9" prot="public" static="no" mutable="no">
        <type>__constant__ FP_PRECISION</type>
        <definition>__constant__ FP_PRECISION polar_weights[MAX_POLAR_ANGLES *MAX_AZIM_ANGLES]</definition>
        <argsstring>[MAX_POLAR_ANGLES *MAX_AZIM_ANGLES]</argsstring>
        <name>polar_weights</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>An array of the weights for the polar angles from the quadrature set </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/wbinventor/NSE-CRPG-Codes/OpenMOC/src/dev/gpu/GPUSolver.cu" line="26" bodyfile="/home/wbinventor/NSE-CRPG-Codes/OpenMOC/src/dev/gpu/GPUSolver.cu" bodystart="26" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="GPUSolver_8cu_1a230a14a5cdb9470e080a6c84175a3f90" prot="public" static="no" mutable="no">
        <type>__constant__ int</type>
        <definition>__constant__ int num_tracks[MAX_AZIM_ANGLES/2]</definition>
        <argsstring>[MAX_AZIM_ANGLES/2]</argsstring>
        <name>num_tracks</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>A pointer to an array with the number of tracks per azimuthal angle </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/wbinventor/NSE-CRPG-Codes/OpenMOC/src/dev/gpu/GPUSolver.cu" line="29" bodyfile="/home/wbinventor/NSE-CRPG-Codes/OpenMOC/src/dev/gpu/GPUSolver.cu" bodystart="29" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="GPUSolver_8cu_1a28971b767a3a7c21a5f8d947d3ab4fb0" prot="public" static="no" mutable="no">
        <type>__constant__ int</type>
        <definition>__constant__ int tot_num_tracks[1]</definition>
        <argsstring>[1]</argsstring>
        <name>tot_num_tracks</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The total number of tracks </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/wbinventor/NSE-CRPG-Codes/OpenMOC/src/dev/gpu/GPUSolver.cu" line="32" bodyfile="/home/wbinventor/NSE-CRPG-Codes/OpenMOC/src/dev/gpu/GPUSolver.cu" bodystart="32" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="GPUSolver_8cu_1a072a248b8c2362c025fe97b8b1e5ffda" prot="public" static="no" mutable="no">
        <type>__constant__ bool</type>
        <definition>__constant__ bool interpolate_exponential[1]</definition>
        <argsstring>[1]</argsstring>
        <name>interpolate_exponential</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/wbinventor/NSE-CRPG-Codes/OpenMOC/src/dev/gpu/GPUSolver.cu" line="34" bodyfile="/home/wbinventor/NSE-CRPG-Codes/OpenMOC/src/dev/gpu/GPUSolver.cu" bodystart="34" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="GPUSolver_8cu_1a4e6f5f27989a53344d5a52f29d2c2fa4" prot="public" static="no" mutable="no">
        <type>__constant__ int</type>
        <definition>__constant__ int prefactor_max_index[1]</definition>
        <argsstring>[1]</argsstring>
        <name>prefactor_max_index</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The maximum index of the exponential prefactor array </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/wbinventor/NSE-CRPG-Codes/OpenMOC/src/dev/gpu/GPUSolver.cu" line="37" bodyfile="/home/wbinventor/NSE-CRPG-Codes/OpenMOC/src/dev/gpu/GPUSolver.cu" bodystart="37" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="GPUSolver_8cu_1a3ad44a11b35a322eac1af29b2cb54887" prot="public" static="no" mutable="no">
        <type>__constant__ FP_PRECISION</type>
        <definition>__constant__ FP_PRECISION prefactor_spacing[1]</definition>
        <argsstring>[1]</argsstring>
        <name>prefactor_spacing</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The spacing for the exponential prefactor array </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/wbinventor/NSE-CRPG-Codes/OpenMOC/src/dev/gpu/GPUSolver.cu" line="40" bodyfile="/home/wbinventor/NSE-CRPG-Codes/OpenMOC/src/dev/gpu/GPUSolver.cu" bodystart="40" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="GPUSolver_8cu_1ab02f3655a4ba29a173266ba545201081" prot="public" static="no" mutable="no">
        <type>__constant__ FP_PRECISION</type>
        <definition>__constant__ FP_PRECISION inverse_prefactor_spacing[1]</definition>
        <argsstring>[1]</argsstring>
        <name>inverse_prefactor_spacing</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>The inverse spacing for the exponential prefactor array </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/wbinventor/NSE-CRPG-Codes/OpenMOC/src/dev/gpu/GPUSolver.cu" line="43" bodyfile="/home/wbinventor/NSE-CRPG-Codes/OpenMOC/src/dev/gpu/GPUSolver.cu" bodystart="43" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="GPUSolver_8cu_1a77f276c943964f9a7c872c36d3b39376" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>__global__ void</type>
        <definition>__global__ void computeFissionSourcesOnDevice</definition>
        <argsstring>(FP_PRECISION *FSR_volumes, int *FSR_materials, dev_material *materials, FP_PRECISION *scalar_flux, FP_PRECISION *fission_sources)</argsstring>
        <name>computeFissionSourcesOnDevice</name>
        <param>
          <type>FP_PRECISION *</type>
          <declname>FSR_volumes</declname>
        </param>
        <param>
          <type>int *</type>
          <declname>FSR_materials</declname>
        </param>
        <param>
          <type><ref refid="structdev__material" kindref="compound">dev_material</ref> *</type>
          <declname>materials</declname>
        </param>
        <param>
          <type>FP_PRECISION *</type>
          <declname>scalar_flux</declname>
        </param>
        <param>
          <type>FP_PRECISION *</type>
          <declname>fission_sources</declname>
        </param>
        <briefdescription>
<para>Compute the total fission source from all flat source regions. </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>FSR_volumes</parametername>
</parameternamelist>
<parameterdescription>
<para>an array of flat source region volumes </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>FSR_materials</parametername>
</parameternamelist>
<parameterdescription>
<para>an array of flat source region materials </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>materials</parametername>
</parameternamelist>
<parameterdescription>
<para>an array of materials on the device </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>scalar_flux</parametername>
</parameternamelist>
<parameterdescription>
<para>the scalar flux in each flat source region </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>fission_sources</parametername>
</parameternamelist>
<parameterdescription>
<para>array of fission sources in each flat source region </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/wbinventor/NSE-CRPG-Codes/OpenMOC/src/dev/gpu/GPUSolver.cu" line="59" bodyfile="/home/wbinventor/NSE-CRPG-Codes/OpenMOC/src/dev/gpu/GPUSolver.cu" bodystart="55" bodyend="97"/>
      </memberdef>
      <memberdef kind="function" id="GPUSolver_8cu_1a742b8446da3db66c1fc6820a803bda9e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>__global__ void</type>
        <definition>__global__ void normalizeFluxesOnDevice</definition>
        <argsstring>(FP_PRECISION *scalar_flux, FP_PRECISION *boundary_flux, FP_PRECISION norm_factor)</argsstring>
        <name>normalizeFluxesOnDevice</name>
        <param>
          <type>FP_PRECISION *</type>
          <declname>scalar_flux</declname>
        </param>
        <param>
          <type>FP_PRECISION *</type>
          <declname>boundary_flux</declname>
        </param>
        <param>
          <type>FP_PRECISION</type>
          <declname>norm_factor</declname>
        </param>
        <briefdescription>
<para>Normalizes all flatsourceregion scalar fluxes and track boundary angular fluxes to the total fission source (times <formula id="0">$ \nu $</formula>). </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>scalar_flux</parametername>
</parameternamelist>
<parameterdescription>
<para>an array of the flat source region scalar fluxes </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>boundary_flux</parametername>
</parameternamelist>
<parameterdescription>
<para>an array of the boundary fluxes </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>norm_factor</parametername>
</parameternamelist>
<parameterdescription>
<para>the normalization factor </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/wbinventor/NSE-CRPG-Codes/OpenMOC/src/dev/gpu/GPUSolver.cu" line="109" bodyfile="/home/wbinventor/NSE-CRPG-Codes/OpenMOC/src/dev/gpu/GPUSolver.cu" bodystart="107" bodyend="133"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline lineno="1"><highlight class="preprocessor">#include<sp/>&quot;<ref refid="GPUSolver_8h" kindref="compound" tooltip="The GPUSolver class and GPU solver routines.">GPUSolver.h</ref>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2"><highlight class="normal"></highlight></codeline>
<codeline lineno="3"><highlight class="normal"></highlight></codeline>
<codeline lineno="5"><highlight class="normal">__constant__<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>num_azim[1];</highlight></codeline>
<codeline lineno="6"><highlight class="normal"></highlight></codeline>
<codeline lineno="8"><highlight class="normal">__constant__<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>num_groups[1];</highlight></codeline>
<codeline lineno="9"><highlight class="normal"></highlight></codeline>
<codeline lineno="11"><highlight class="normal">__constant__<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>num_FSRs[1];</highlight></codeline>
<codeline lineno="12"><highlight class="normal"></highlight></codeline>
<codeline lineno="14"><highlight class="normal">__constant__<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>num_polar[1];</highlight></codeline>
<codeline lineno="15"><highlight class="normal"></highlight></codeline>
<codeline lineno="17"><highlight class="normal">__constant__<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>two_times_num_polar[1];</highlight></codeline>
<codeline lineno="18"><highlight class="normal"></highlight></codeline>
<codeline lineno="20"><highlight class="normal">__constant__<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>polar_times_groups[1];</highlight></codeline>
<codeline lineno="21"><highlight class="normal"></highlight></codeline>
<codeline lineno="23"><highlight class="normal">__constant__<sp/>FP_PRECISION<sp/>sinthetas[<ref refid="GPUSolver_8h_1a91b4cb58a59ec4578195cd7787dacf66" kindref="member">MAX_POLAR_ANGLES</ref>];</highlight></codeline>
<codeline lineno="24"><highlight class="normal"></highlight></codeline>
<codeline lineno="26"><highlight class="normal">__constant__<sp/>FP_PRECISION<sp/><ref refid="GPUSolver_8h_1a818d2da0930d46b3fe53eff8bb60ea1f" kindref="member">polar_weights</ref>[<ref refid="GPUSolver_8h_1a91b4cb58a59ec4578195cd7787dacf66" kindref="member">MAX_POLAR_ANGLES</ref>*<ref refid="GPUSolver_8h_1a13ab74d9229f8b9544ae9decc54163da" kindref="member">MAX_AZIM_ANGLES</ref>];</highlight></codeline>
<codeline lineno="27"><highlight class="normal"></highlight></codeline>
<codeline lineno="29"><highlight class="normal">__constant__<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>num_tracks[<ref refid="GPUSolver_8h_1a13ab74d9229f8b9544ae9decc54163da" kindref="member">MAX_AZIM_ANGLES</ref>/2];</highlight></codeline>
<codeline lineno="30"><highlight class="normal"></highlight></codeline>
<codeline lineno="32"><highlight class="normal">__constant__<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>tot_num_tracks[1];</highlight></codeline>
<codeline lineno="33"><highlight class="normal"></highlight></codeline>
<codeline lineno="34"><highlight class="normal">__constant__<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>interpolate_exponential[1];</highlight></codeline>
<codeline lineno="35"><highlight class="normal"></highlight></codeline>
<codeline lineno="37"><highlight class="normal">__constant__<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>prefactor_max_index[1];</highlight></codeline>
<codeline lineno="38"><highlight class="normal"></highlight></codeline>
<codeline lineno="40"><highlight class="normal">__constant__<sp/>FP_PRECISION<sp/>prefactor_spacing[1];</highlight></codeline>
<codeline lineno="41"><highlight class="normal"></highlight></codeline>
<codeline lineno="43"><highlight class="normal">__constant__<sp/>FP_PRECISION<sp/>inverse_prefactor_spacing[1];</highlight></codeline>
<codeline lineno="44"><highlight class="normal"></highlight></codeline>
<codeline lineno="45"><highlight class="normal"></highlight></codeline>
<codeline lineno="46"><highlight class="normal"></highlight></codeline>
<codeline lineno="55"><highlight class="normal">__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>computeFissionSourcesOnDevice(FP_PRECISION*<sp/>FSR_volumes,</highlight></codeline>
<codeline lineno="56"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>FSR_materials,</highlight></codeline>
<codeline lineno="57"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structdev__material" kindref="compound" tooltip="A material&amp;#39;s nuclear data to be stored on a GPU.">dev_material</ref>*<sp/>materials,</highlight></codeline>
<codeline lineno="58"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FP_PRECISION*<sp/><ref refid="GPUSolver_8h_1a4089c9be8cf297ccf942eb8c29cca415" kindref="member">scalar_flux</ref>,</highlight></codeline>
<codeline lineno="59"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FP_PRECISION*<sp/>fission_sources)<sp/>{</highlight></codeline>
<codeline lineno="60"><highlight class="normal"></highlight></codeline>
<codeline lineno="61"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Use<sp/>a<sp/>shared<sp/>memory<sp/>buffer<sp/>for<sp/>each<sp/>thread&apos;s<sp/>fission<sp/>source<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="62"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>__shared__<sp/>FP_PRECISION<sp/>shared_fission_source[];</highlight></codeline>
<codeline lineno="63"><highlight class="normal"></highlight></codeline>
<codeline lineno="64"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>tid<sp/>=<sp/>threadIdx.x<sp/>+<sp/>blockIdx.x<sp/>*<sp/>blockDim.x;</highlight></codeline>
<codeline lineno="65"><highlight class="normal"></highlight></codeline>
<codeline lineno="66"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structdev__material" kindref="compound" tooltip="A material&amp;#39;s nuclear data to be stored on a GPU.">dev_material</ref>*<sp/>curr_material;</highlight></codeline>
<codeline lineno="67"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>nu_sigma_f;</highlight></codeline>
<codeline lineno="68"><highlight class="normal"><sp/><sp/><sp/><sp/>FP_PRECISION<sp/>volume;</highlight></codeline>
<codeline lineno="69"><highlight class="normal"><sp/><sp/><sp/><sp/>FP_PRECISION<sp/><ref refid="GPUSolver_8h_1aff1d2d6ea4da8b36276071f975850c6e" kindref="member">source</ref>;</highlight></codeline>
<codeline lineno="70"><highlight class="normal"></highlight></codeline>
<codeline lineno="71"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Initialize<sp/>fission<sp/>source<sp/>to<sp/>zero<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="72"><highlight class="normal"><sp/><sp/><sp/><sp/>shared_fission_source[threadIdx.x]<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="73"><highlight class="normal"></highlight></codeline>
<codeline lineno="74"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Iterate<sp/>over<sp/>all<sp/>FSRs<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="75"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(tid<sp/>&lt;<sp/>*num_FSRs)<sp/>{</highlight></codeline>
<codeline lineno="76"><highlight class="normal"></highlight></codeline>
<codeline lineno="77"><highlight class="normal"><sp/><sp/><sp/><sp/>curr_material<sp/>=<sp/>&amp;materials[FSR_materials[tid]];</highlight></codeline>
<codeline lineno="78"><highlight class="normal"><sp/><sp/><sp/><sp/>nu_sigma_f<sp/>=<sp/>curr_material-&gt;<ref refid="structdev__material_1a4199413689b49b9e54a8ce13cfe75cc3" kindref="member">_nu_sigma_f</ref>;</highlight></codeline>
<codeline lineno="79"><highlight class="normal"><sp/><sp/><sp/><sp/>volume<sp/>=<sp/>FSR_volumes[tid];</highlight></codeline>
<codeline lineno="80"><highlight class="normal"></highlight></codeline>
<codeline lineno="81"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Iterate<sp/>over<sp/>all<sp/>energy<sp/>groups<sp/>and<sp/>update</highlight></codeline>
<codeline lineno="82"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>fission<sp/>source<sp/>for<sp/>this<sp/>block<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="83"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>e=0;<sp/>e<sp/>&lt;<sp/>*num_groups;<sp/>e++)<sp/>{</highlight></codeline>
<codeline lineno="84"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>source<sp/>=<sp/>nu_sigma_f[e]<sp/>*<sp/><ref refid="GPUSolver_8h_1a4089c9be8cf297ccf942eb8c29cca415" kindref="member">scalar_flux</ref>(tid,e)<sp/>*<sp/>volume;</highlight></codeline>
<codeline lineno="85"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>shared_fission_source[threadIdx.x]<sp/>+=<sp/><ref refid="GPUSolver_8h_1aff1d2d6ea4da8b36276071f975850c6e" kindref="member">source</ref>;</highlight></codeline>
<codeline lineno="86"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="87"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="88"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Increment<sp/>thread<sp/>id<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="89"><highlight class="normal"><sp/><sp/><sp/><sp/>tid<sp/>+=<sp/>blockDim.x<sp/>*<sp/>gridDim.x;</highlight></codeline>
<codeline lineno="90"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="91"><highlight class="normal"></highlight></codeline>
<codeline lineno="92"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Copy<sp/>this<sp/>threads<sp/>fission<sp/>source<sp/>to<sp/>global<sp/>memory<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="93"><highlight class="normal"><sp/><sp/><sp/><sp/>tid<sp/>=<sp/>threadIdx.x<sp/>+<sp/>blockIdx.x<sp/>*<sp/>blockDim.x;</highlight></codeline>
<codeline lineno="94"><highlight class="normal"><sp/><sp/><sp/><sp/>fission_sources[tid]<sp/>=<sp/>shared_fission_source[threadIdx.x];</highlight></codeline>
<codeline lineno="95"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="96"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="97"><highlight class="normal">}</highlight></codeline>
<codeline lineno="98"><highlight class="normal"></highlight></codeline>
<codeline lineno="99"><highlight class="normal"></highlight></codeline>
<codeline lineno="107"><highlight class="normal">__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>normalizeFluxesOnDevice(FP_PRECISION*<sp/>scalar_flux,<sp/></highlight></codeline>
<codeline lineno="108"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FP_PRECISION*<sp/><ref refid="GPUSolver_8h_1acf77ad5d19c7d5cccf263d9a91700d2e" kindref="member">boundary_flux</ref>,<sp/></highlight></codeline>
<codeline lineno="109"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FP_PRECISION<sp/>norm_factor)<sp/>{</highlight></codeline>
<codeline lineno="110"><highlight class="normal"></highlight></codeline>
<codeline lineno="111"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>tid<sp/>=<sp/>threadIdx.x<sp/>+<sp/>blockIdx.x<sp/>*<sp/>blockDim.x;</highlight></codeline>
<codeline lineno="112"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="113"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Normalize<sp/>scalar<sp/>fluxes<sp/>for<sp/>each<sp/>flat<sp/>source<sp/>region<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="114"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal">(tid<sp/>&lt;<sp/>*num_FSRs)<sp/>{</highlight></codeline>
<codeline lineno="115"><highlight class="normal"></highlight></codeline>
<codeline lineno="116"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>e=0;<sp/>e<sp/>&lt;<sp/>*num_groups;<sp/>e++)</highlight></codeline>
<codeline lineno="117"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="GPUSolver_8h_1a4089c9be8cf297ccf942eb8c29cca415" kindref="member">scalar_flux</ref>(tid,e)<sp/>*=<sp/>norm_factor;</highlight></codeline>
<codeline lineno="118"><highlight class="normal"></highlight></codeline>
<codeline lineno="119"><highlight class="normal"><sp/><sp/><sp/><sp/>tid<sp/>+=<sp/>blockDim.x<sp/>*<sp/>gridDim.x;</highlight></codeline>
<codeline lineno="120"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="121"><highlight class="normal"></highlight></codeline>
<codeline lineno="122"><highlight class="normal"><sp/><sp/><sp/><sp/>tid<sp/>=<sp/>threadIdx.x<sp/>+<sp/>blockIdx.x<sp/>*<sp/>blockDim.x;</highlight></codeline>
<codeline lineno="123"><highlight class="normal"></highlight></codeline>
<codeline lineno="124"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Normalize<sp/>angular<sp/>boundary<sp/>fluxes<sp/>for<sp/>each<sp/>track<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="125"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal">(tid<sp/>&lt;<sp/>*tot_num_tracks)<sp/>{</highlight></codeline>
<codeline lineno="126"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>pe2=0;<sp/>pe2<sp/>&lt;<sp/>2*(*polar_times_groups);<sp/>pe2++)</highlight></codeline>
<codeline lineno="127"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="GPUSolver_8h_1acf77ad5d19c7d5cccf263d9a91700d2e" kindref="member">boundary_flux</ref>(tid,pe2)<sp/>*=<sp/>norm_factor;</highlight></codeline>
<codeline lineno="128"><highlight class="normal"></highlight></codeline>
<codeline lineno="129"><highlight class="normal"><sp/><sp/><sp/><sp/>tid<sp/>+=<sp/>blockDim.x<sp/>*<sp/>gridDim.x;</highlight></codeline>
<codeline lineno="130"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="131"><highlight class="normal"></highlight></codeline>
<codeline lineno="132"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="133"><highlight class="normal">}</highlight></codeline>
<codeline lineno="134"><highlight class="normal"></highlight></codeline>
<codeline lineno="135"><highlight class="normal"></highlight></codeline>
<codeline lineno="156"><highlight class="normal">__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>computeFSRSourcesOnDevice(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>FSR_materials,</highlight></codeline>
<codeline lineno="157"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structdev__material" kindref="compound" tooltip="A material&amp;#39;s nuclear data to be stored on a GPU.">dev_material</ref>*<sp/>materials,</highlight></codeline>
<codeline lineno="158"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FP_PRECISION*<sp/>scalar_flux,</highlight></codeline>
<codeline lineno="159"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FP_PRECISION*<sp/>source,</highlight></codeline>
<codeline lineno="160"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FP_PRECISION*<sp/><ref refid="GPUSolver_8h_1a1d5393f7bd91ea0ab5889ad0d57423d4" kindref="member">old_source</ref>,</highlight></codeline>
<codeline lineno="161"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FP_PRECISION*<sp/><ref refid="GPUSolver_8h_1a201104e7c4ebc64308385f741ae5143d" kindref="member">reduced_source</ref>,</highlight></codeline>
<codeline lineno="162"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FP_PRECISION<sp/>inverse_k_eff,</highlight></codeline>
<codeline lineno="163"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FP_PRECISION*<sp/>source_residuals)<sp/>{</highlight></codeline>
<codeline lineno="164"><highlight class="normal"></highlight></codeline>
<codeline lineno="165"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>tid<sp/>=<sp/>threadIdx.x<sp/>+<sp/>blockIdx.x<sp/>*<sp/>blockDim.x;</highlight></codeline>
<codeline lineno="166"><highlight class="normal"></highlight></codeline>
<codeline lineno="167"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Reset<sp/>the<sp/>residual<sp/>for<sp/>the<sp/>old<sp/>and<sp/>new<sp/>fission<sp/>sources<sp/>to<sp/>zero<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="168"><highlight class="normal"><sp/><sp/><sp/><sp/>source_residuals[threadIdx.x<sp/>+<sp/>blockIdx.x<sp/>*<sp/>blockDim.x]<sp/>=<sp/>0.0;</highlight></codeline>
<codeline lineno="169"><highlight class="normal"></highlight></codeline>
<codeline lineno="170"><highlight class="normal"><sp/><sp/><sp/><sp/>FP_PRECISION<sp/>fission_source;</highlight></codeline>
<codeline lineno="171"><highlight class="normal"><sp/><sp/><sp/><sp/>FP_PRECISION<sp/>scatter_source;</highlight></codeline>
<codeline lineno="172"><highlight class="normal"></highlight></codeline>
<codeline lineno="173"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structdev__material" kindref="compound" tooltip="A material&amp;#39;s nuclear data to be stored on a GPU.">dev_material</ref>*<sp/>curr_material;</highlight></codeline>
<codeline lineno="174"><highlight class="normal"></highlight></codeline>
<codeline lineno="175"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>nu_sigma_f;</highlight></codeline>
<codeline lineno="176"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>sigma_s;</highlight></codeline>
<codeline lineno="177"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>sigma_t;</highlight></codeline>
<codeline lineno="178"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>chi;</highlight></codeline>
<codeline lineno="179"><highlight class="normal"></highlight></codeline>
<codeline lineno="180"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Iterate<sp/>over<sp/>all<sp/>FSRs<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="181"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(tid<sp/>&lt;<sp/>*num_FSRs)<sp/>{</highlight></codeline>
<codeline lineno="182"><highlight class="normal"></highlight></codeline>
<codeline lineno="183"><highlight class="normal"><sp/><sp/><sp/><sp/>curr_material<sp/>=<sp/>&amp;materials[FSR_materials[tid]];</highlight></codeline>
<codeline lineno="184"><highlight class="normal"></highlight></codeline>
<codeline lineno="185"><highlight class="normal"><sp/><sp/><sp/><sp/>nu_sigma_f<sp/>=<sp/>curr_material-&gt;<ref refid="structdev__material_1a4199413689b49b9e54a8ce13cfe75cc3" kindref="member">_nu_sigma_f</ref>;</highlight></codeline>
<codeline lineno="186"><highlight class="normal"><sp/><sp/><sp/><sp/>sigma_s<sp/>=<sp/>curr_material-&gt;<ref refid="structdev__material_1aedbce7d066c40ead18618476ffb4d0c9" kindref="member">_sigma_s</ref>;</highlight></codeline>
<codeline lineno="187"><highlight class="normal"><sp/><sp/><sp/><sp/>sigma_t<sp/>=<sp/>curr_material-&gt;<ref refid="structdev__material_1add13483475ff96bda102dcb7a22ed899" kindref="member">_sigma_t</ref>;</highlight></codeline>
<codeline lineno="188"><highlight class="normal"><sp/><sp/><sp/><sp/>chi<sp/>=<sp/>curr_material-&gt;<ref refid="structdev__material_1a605811b8e96dfc2b8be12546c3b9e613" kindref="member">_chi</ref>;</highlight></codeline>
<codeline lineno="189"><highlight class="normal"></highlight></codeline>
<codeline lineno="190"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Initialize<sp/>the<sp/>fission<sp/>source<sp/>to<sp/>zero<sp/>for<sp/>this<sp/>region<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="191"><highlight class="normal"><sp/><sp/><sp/><sp/>fission_source<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="192"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="193"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Compute<sp/>total<sp/>fission<sp/>source<sp/>for<sp/>current<sp/>region<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="194"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>e=0;<sp/>e<sp/>&lt;<sp/>*num_groups;<sp/>e++)</highlight></codeline>
<codeline lineno="195"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fission_source<sp/>+=<sp/><ref refid="GPUSolver_8h_1a4089c9be8cf297ccf942eb8c29cca415" kindref="member">scalar_flux</ref>(tid,e)<sp/>*<sp/>nu_sigma_f[e];</highlight></codeline>
<codeline lineno="196"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="197"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Compute<sp/>total<sp/>scattering<sp/>source<sp/>for<sp/>region<sp/>for<sp/>group<sp/>G<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="198"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>G=0;<sp/>G<sp/>&lt;<sp/>*num_groups;<sp/>G++)<sp/>{</highlight></codeline>
<codeline lineno="199"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>scatter_source<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="200"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="201"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>g=0;<sp/>g<sp/>&lt;<sp/>*num_groups;<sp/>g++)</highlight></codeline>
<codeline lineno="202"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>scatter_source<sp/>+=<sp/></highlight></codeline>
<codeline lineno="203"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>sigma_s[G*(*num_groups)+g]<sp/>*<sp/><ref refid="GPUSolver_8h_1a4089c9be8cf297ccf942eb8c29cca415" kindref="member">scalar_flux</ref>(tid,g);</highlight></codeline>
<codeline lineno="204"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="205"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Set<sp/>the<sp/>total<sp/>source<sp/>for<sp/>this<sp/>region<sp/>in<sp/>this<sp/>group<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="206"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="GPUSolver_8h_1aff1d2d6ea4da8b36276071f975850c6e" kindref="member">source</ref>(tid,G)<sp/>=<sp/>(inverse_k_eff<sp/>*<sp/>fission_source<sp/>*<sp/>chi[G]<sp/>+</highlight></codeline>
<codeline lineno="207"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>scatter_source)<sp/>*<sp/><ref refid="GPUSolver_8h_1a662cb71fde841f2762641d9f82e1fbb5" kindref="member">ONE_OVER_FOUR_PI</ref>;</highlight></codeline>
<codeline lineno="208"><highlight class="normal"></highlight></codeline>
<codeline lineno="209"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="GPUSolver_8h_1a201104e7c4ebc64308385f741ae5143d" kindref="member">reduced_source</ref>(tid,G)<sp/>=<sp/>__fdividef(<ref refid="GPUSolver_8h_1aff1d2d6ea4da8b36276071f975850c6e" kindref="member">source</ref>(tid,G),<sp/>sigma_t[G]);</highlight></codeline>
<codeline lineno="210"><highlight class="normal"></highlight></codeline>
<codeline lineno="211"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Compute<sp/>the<sp/>norm<sp/>of<sp/>residuals<sp/>of<sp/>the<sp/>sources<sp/>for<sp/>convergence<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="212"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(fabs(<ref refid="GPUSolver_8h_1aff1d2d6ea4da8b36276071f975850c6e" kindref="member">source</ref>(tid,G))<sp/>&gt;<sp/>1E-10)</highlight></codeline>
<codeline lineno="213"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>source_residuals[threadIdx.x<sp/>+<sp/>blockIdx.x<sp/>*<sp/>blockDim.x]<sp/>+=</highlight></codeline>
<codeline lineno="214"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>pow((<ref refid="GPUSolver_8h_1aff1d2d6ea4da8b36276071f975850c6e" kindref="member">source</ref>(tid,G)<sp/>-<sp/><ref refid="GPUSolver_8h_1a1d5393f7bd91ea0ab5889ad0d57423d4" kindref="member">old_source</ref>(tid,G))<sp/>/</highlight></codeline>
<codeline lineno="215"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="GPUSolver_8h_1aff1d2d6ea4da8b36276071f975850c6e" kindref="member">source</ref>(tid,G),<sp/>2);</highlight></codeline>
<codeline lineno="216"><highlight class="normal"></highlight></codeline>
<codeline lineno="217"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Update<sp/>the<sp/>old<sp/>source<sp/>*/</highlight><highlight class="normal"><sp/></highlight></codeline>
<codeline lineno="218"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="GPUSolver_8h_1a1d5393f7bd91ea0ab5889ad0d57423d4" kindref="member">old_source</ref>(tid,G)<sp/>=<sp/><ref refid="GPUSolver_8h_1aff1d2d6ea4da8b36276071f975850c6e" kindref="member">source</ref>(tid,G);</highlight></codeline>
<codeline lineno="219"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="220"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="221"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Increment<sp/>the<sp/>thread<sp/>id<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="222"><highlight class="normal"><sp/><sp/><sp/><sp/>tid<sp/>+=<sp/>blockDim.x<sp/>*<sp/>gridDim.x;</highlight></codeline>
<codeline lineno="223"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="224"><highlight class="normal"></highlight></codeline>
<codeline lineno="225"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="226"><highlight class="normal">}</highlight></codeline>
<codeline lineno="227"><highlight class="normal"></highlight></codeline>
<codeline lineno="228"><highlight class="normal"></highlight></codeline>
<codeline lineno="229"><highlight class="normal"></highlight></codeline>
<codeline lineno="230"><highlight class="normal"></highlight></codeline>
<codeline lineno="231"><highlight class="normal"></highlight></codeline>
<codeline lineno="241"><highlight class="normal">__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>computeFissionAndAbsorption(FP_PRECISION*<sp/>FSR_volumes,</highlight></codeline>
<codeline lineno="242"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>FSR_materials,</highlight></codeline>
<codeline lineno="243"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structdev__material" kindref="compound" tooltip="A material&amp;#39;s nuclear data to be stored on a GPU.">dev_material</ref>*<sp/>materials,</highlight></codeline>
<codeline lineno="244"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FP_PRECISION*<sp/>scalar_flux,</highlight></codeline>
<codeline lineno="245"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FP_PRECISION*<sp/>tot_absorption,</highlight></codeline>
<codeline lineno="246"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FP_PRECISION*<sp/>tot_fission)<sp/>{</highlight></codeline>
<codeline lineno="247"><highlight class="normal"></highlight></codeline>
<codeline lineno="248"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>tid<sp/>=<sp/>threadIdx.x<sp/>+<sp/>blockIdx.x<sp/>*<sp/>blockDim.x;</highlight></codeline>
<codeline lineno="249"><highlight class="normal"></highlight></codeline>
<codeline lineno="250"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structdev__material" kindref="compound" tooltip="A material&amp;#39;s nuclear data to be stored on a GPU.">dev_material</ref>*<sp/>curr_material;</highlight></codeline>
<codeline lineno="251"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>nu_sigma_f;</highlight></codeline>
<codeline lineno="252"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>sigma_a;</highlight></codeline>
<codeline lineno="253"><highlight class="normal"><sp/><sp/><sp/><sp/>FP_PRECISION<sp/>volume;</highlight></codeline>
<codeline lineno="254"><highlight class="normal"></highlight></codeline>
<codeline lineno="255"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>absorption<sp/>=<sp/>0.;</highlight></codeline>
<codeline lineno="256"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>fission<sp/>=<sp/>0.;</highlight></codeline>
<codeline lineno="257"><highlight class="normal"></highlight></codeline>
<codeline lineno="258"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Iterate<sp/>over<sp/>all<sp/>FSRs<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="259"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(tid<sp/>&lt;<sp/>*num_FSRs)<sp/>{</highlight></codeline>
<codeline lineno="260"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="261"><highlight class="normal"><sp/><sp/><sp/><sp/>curr_material<sp/>=<sp/>&amp;materials[FSR_materials[tid]];</highlight></codeline>
<codeline lineno="262"><highlight class="normal"><sp/><sp/><sp/><sp/>nu_sigma_f<sp/>=<sp/>curr_material-&gt;<ref refid="structdev__material_1a4199413689b49b9e54a8ce13cfe75cc3" kindref="member">_nu_sigma_f</ref>;</highlight></codeline>
<codeline lineno="263"><highlight class="normal"><sp/><sp/><sp/><sp/>sigma_a<sp/>=<sp/>curr_material-&gt;<ref refid="structdev__material_1ada9eb4b160228c5817d3c962d3455b36" kindref="member">_sigma_a</ref>;</highlight></codeline>
<codeline lineno="264"><highlight class="normal"><sp/><sp/><sp/><sp/>volume<sp/>=<sp/>FSR_volumes[tid];</highlight></codeline>
<codeline lineno="265"><highlight class="normal"></highlight></codeline>
<codeline lineno="266"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>curr_abs<sp/>=<sp/>0.;</highlight></codeline>
<codeline lineno="267"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>curr_fission<sp/>=<sp/>0.;</highlight></codeline>
<codeline lineno="268"><highlight class="normal"></highlight></codeline>
<codeline lineno="269"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Iterate<sp/>over<sp/>all<sp/>energy<sp/>groups<sp/>and<sp/>update</highlight></codeline>
<codeline lineno="270"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>fission<sp/>and<sp/>absorption<sp/>rates<sp/>for<sp/>this<sp/>block<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="271"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>e=0;<sp/>e<sp/>&lt;<sp/>*num_groups;<sp/>e++)<sp/>{</highlight></codeline>
<codeline lineno="272"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>curr_abs<sp/>+=<sp/>sigma_a[e]<sp/>*<sp/><ref refid="GPUSolver_8h_1a4089c9be8cf297ccf942eb8c29cca415" kindref="member">scalar_flux</ref>(tid,e);</highlight></codeline>
<codeline lineno="273"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>curr_fission<sp/>+=<sp/>nu_sigma_f[e]<sp/>*<sp/><ref refid="GPUSolver_8h_1a4089c9be8cf297ccf942eb8c29cca415" kindref="member">scalar_flux</ref>(tid,e);</highlight></codeline>
<codeline lineno="274"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="275"><highlight class="normal"></highlight></codeline>
<codeline lineno="276"><highlight class="normal"><sp/><sp/><sp/><sp/>absorption<sp/>+=<sp/>curr_abs<sp/>*<sp/>volume;</highlight></codeline>
<codeline lineno="277"><highlight class="normal"><sp/><sp/><sp/><sp/>fission<sp/>+=<sp/>curr_fission<sp/>*<sp/>volume;</highlight></codeline>
<codeline lineno="278"><highlight class="normal"></highlight></codeline>
<codeline lineno="279"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Increment<sp/>thread<sp/>id<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="280"><highlight class="normal"><sp/><sp/><sp/><sp/>tid<sp/>+=<sp/>blockDim.x<sp/>*<sp/>gridDim.x;</highlight></codeline>
<codeline lineno="281"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="282"><highlight class="normal"></highlight></codeline>
<codeline lineno="283"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Copy<sp/>this<sp/>thread&apos;s<sp/>fission<sp/>and<sp/>absorption<sp/>rates<sp/>to<sp/>global<sp/>memory<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="284"><highlight class="normal"><sp/><sp/><sp/><sp/>tid<sp/>=<sp/>threadIdx.x<sp/>+<sp/>blockIdx.x<sp/>*<sp/>blockDim.x;</highlight></codeline>
<codeline lineno="285"><highlight class="normal"><sp/><sp/><sp/><sp/>tot_absorption[tid]<sp/>=<sp/>absorption;</highlight></codeline>
<codeline lineno="286"><highlight class="normal"><sp/><sp/><sp/><sp/>tot_fission[tid]<sp/>=<sp/>fission;</highlight></codeline>
<codeline lineno="287"><highlight class="normal"></highlight></codeline>
<codeline lineno="288"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="289"><highlight class="normal">}</highlight></codeline>
<codeline lineno="290"><highlight class="normal"></highlight></codeline>
<codeline lineno="291"><highlight class="normal"></highlight></codeline>
<codeline lineno="300"><highlight class="normal">__device__<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>computePrefactorIndex(FP_PRECISION<sp/>tau)<sp/>{</highlight></codeline>
<codeline lineno="301"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>index<sp/>=<sp/>tau<sp/>*<sp/>*inverse_prefactor_spacing;</highlight></codeline>
<codeline lineno="302"><highlight class="normal"><sp/><sp/><sp/><sp/>index<sp/>*=<sp/>*two_times_num_polar;</highlight></codeline>
<codeline lineno="303"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>index;</highlight></codeline>
<codeline lineno="304"><highlight class="normal">}</highlight></codeline>
<codeline lineno="305"><highlight class="normal"></highlight></codeline>
<codeline lineno="306"><highlight class="normal"></highlight></codeline>
<codeline lineno="315"><highlight class="normal">__device__<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>atomicAdd(</highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>address,<sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>val)<sp/>{</highlight></codeline>
<codeline lineno="316"><highlight class="normal"></highlight></codeline>
<codeline lineno="317"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">long</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">long</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>address_as_ull<sp/>=<sp/>(</highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">long</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">long</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*)address;</highlight></codeline>
<codeline lineno="318"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">long</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">long</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>old<sp/>=<sp/>*address_as_ull,<sp/>assumed;</highlight></codeline>
<codeline lineno="319"><highlight class="normal"></highlight></codeline>
<codeline lineno="320"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">do</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="321"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>assumed<sp/>=<sp/>old;</highlight></codeline>
<codeline lineno="322"><highlight class="normal"><sp/><sp/><sp/><sp/>old<sp/>=<sp/>atomicCAS(address_as_ull,<sp/>assumed,<sp/>__double_as_longlong(val<sp/>+</highlight></codeline>
<codeline lineno="323"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__longlong_as_double(assumed)));</highlight></codeline>
<codeline lineno="324"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(assumed<sp/>!=<sp/>old);</highlight></codeline>
<codeline lineno="325"><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline lineno="326"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>__longlong_as_double(old);</highlight></codeline>
<codeline lineno="327"><highlight class="normal">}</highlight></codeline>
<codeline lineno="328"><highlight class="normal"></highlight></codeline>
<codeline lineno="329"><highlight class="normal"></highlight></codeline>
<codeline lineno="342"><highlight class="normal">__device__<sp/>FP_PRECISION<sp/>computeExponential(FP_PRECISION<sp/>sigma_t,<sp/></highlight></codeline>
<codeline lineno="343"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FP_PRECISION<sp/>length,</highlight></codeline>
<codeline lineno="344"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FP_PRECISION*<sp/>_prefactor_array,</highlight></codeline>
<codeline lineno="345"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>p)<sp/>{</highlight></codeline>
<codeline lineno="346"><highlight class="normal"></highlight></codeline>
<codeline lineno="347"><highlight class="normal"><sp/><sp/><sp/><sp/>FP_PRECISION<sp/>exponential;</highlight></codeline>
<codeline lineno="348"><highlight class="normal"><sp/><sp/><sp/><sp/>FP_PRECISION<sp/>tau<sp/>=<sp/>sigma_t<sp/>*<sp/>length;</highlight></codeline>
<codeline lineno="349"><highlight class="normal"></highlight></codeline>
<codeline lineno="350"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Evaluate<sp/>the<sp/>exponential<sp/>using<sp/>the<sp/>lookup<sp/>table<sp/>-<sp/>linear<sp/>interpolation<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="351"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(*interpolate_exponential)<sp/>{</highlight></codeline>
<codeline lineno="352"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>index;</highlight></codeline>
<codeline lineno="353"><highlight class="normal"></highlight></codeline>
<codeline lineno="354"><highlight class="normal"><sp/><sp/><sp/><sp/>index<sp/>=<sp/>int(tau<sp/>*<sp/>(*inverse_prefactor_spacing))<sp/>*<sp/>(*two_times_num_polar);</highlight></codeline>
<codeline lineno="355"><highlight class="normal"><sp/><sp/><sp/><sp/>exponential<sp/>=<sp/>(1.<sp/>-<sp/>(_prefactor_array[index+2<sp/>*<sp/>p]<sp/>*<sp/>tau<sp/>+<sp/></highlight></codeline>
<codeline lineno="356"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_prefactor_array[index<sp/>+<sp/>2<sp/>*<sp/>p<sp/>+1]));</highlight></codeline>
<codeline lineno="357"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="358"><highlight class="normal"></highlight></codeline>
<codeline lineno="359"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Evalute<sp/>the<sp/>exponential<sp/>using<sp/>the<sp/>intrinsic<sp/>exp<sp/>function<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="360"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="361"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FP_PRECISION<sp/>sintheta<sp/>=<sp/>sinthetas[p];</highlight></codeline>
<codeline lineno="362"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#ifdef<sp/>SINGLE</highlight></codeline>
<codeline lineno="363"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/>exponential<sp/>=<sp/>1.0<sp/>-<sp/>__expf(-<sp/>tau<sp/>/<sp/>sintheta);</highlight></codeline>
<codeline lineno="364"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#else</highlight></codeline>
<codeline lineno="365"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/>exponential<sp/>=<sp/>1.0<sp/>-<sp/>exp(-<sp/>tau<sp/>/<sp/>sintheta);</highlight></codeline>
<codeline lineno="366"><highlight class="normal"></highlight><highlight class="preprocessor"><sp/><sp/><sp/><sp/>#endif</highlight></codeline>
<codeline lineno="367"><highlight class="preprocessor"></highlight><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="368"><highlight class="normal"></highlight></codeline>
<codeline lineno="369"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>exponential;</highlight></codeline>
<codeline lineno="370"><highlight class="normal">}</highlight></codeline>
<codeline lineno="371"><highlight class="normal"></highlight></codeline>
<codeline lineno="372"><highlight class="normal"></highlight></codeline>
<codeline lineno="388"><highlight class="normal">__device__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>scalarFluxTally(<ref refid="structdev__segment" kindref="compound" tooltip="A dev_segment represents a line segment within a single flat source region along a track...">dev_segment</ref>*<sp/>curr_segment,<sp/></highlight></codeline>
<codeline lineno="389"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>energy_group,</highlight></codeline>
<codeline lineno="390"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structdev__material" kindref="compound" tooltip="A material&amp;#39;s nuclear data to be stored on a GPU.">dev_material</ref>*<sp/>materials,</highlight></codeline>
<codeline lineno="391"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FP_PRECISION*<sp/><ref refid="CPUSolver_8h_1a2143506339a36528e1c9d7e27501897f" kindref="member">track_flux</ref>,</highlight></codeline>
<codeline lineno="392"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FP_PRECISION*<sp/>reduced_source,</highlight></codeline>
<codeline lineno="393"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FP_PRECISION*<sp/><ref refid="GPUSolver_8h_1a818d2da0930d46b3fe53eff8bb60ea1f" kindref="member">polar_weights</ref>,</highlight></codeline>
<codeline lineno="394"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FP_PRECISION*<sp/>_prefactor_array,</highlight></codeline>
<codeline lineno="395"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FP_PRECISION*<sp/>scalar_flux)<sp/>{</highlight></codeline>
<codeline lineno="396"><highlight class="normal"></highlight></codeline>
<codeline lineno="397"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>fsr_id<sp/>=<sp/>curr_segment-&gt;<ref refid="structdev__segment_1a986cb48a5ac6eb7b26791b828d363ee3" kindref="member">_region_uid</ref>;</highlight></codeline>
<codeline lineno="398"><highlight class="normal"><sp/><sp/><sp/><sp/>FP_PRECISION<sp/>length<sp/>=<sp/>curr_segment-&gt;<ref refid="structdev__segment_1a2aac6afa16185fef69c96c7dcb964d68" kindref="member">_length</ref>;</highlight></codeline>
<codeline lineno="399"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structdev__material" kindref="compound" tooltip="A material&amp;#39;s nuclear data to be stored on a GPU.">dev_material</ref>*<sp/>curr_material<sp/>=<sp/>&amp;materials[curr_segment-&gt;<ref refid="structdev__segment_1a0385feac05b7d6f5d25bb175a17a72dd" kindref="member">_material_uid</ref>];</highlight></codeline>
<codeline lineno="400"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal"><sp/>*sigma_t<sp/>=<sp/>curr_material-&gt;<ref refid="structdev__material_1add13483475ff96bda102dcb7a22ed899" kindref="member">_sigma_t</ref>;</highlight></codeline>
<codeline lineno="401"><highlight class="normal"></highlight></codeline>
<codeline lineno="402"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>The<sp/>average<sp/>flux<sp/>long<sp/>this<sp/>segment<sp/>in<sp/>this<sp/>flat<sp/>source<sp/>region<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="403"><highlight class="normal"><sp/><sp/><sp/><sp/>FP_PRECISION<sp/>psibar;</highlight></codeline>
<codeline lineno="404"><highlight class="normal"><sp/><sp/><sp/><sp/>FP_PRECISION<sp/>exponential;</highlight></codeline>
<codeline lineno="405"><highlight class="normal"></highlight></codeline>
<codeline lineno="406"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Zero<sp/>the<sp/>FSR<sp/>scalar<sp/>flux<sp/>contribution<sp/>from<sp/>this<sp/>segment<sp/></highlight></codeline>
<codeline lineno="407"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>and<sp/>energy<sp/>group<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="408"><highlight class="normal"><sp/><sp/><sp/><sp/>FP_PRECISION<sp/>fsr_flux<sp/>=<sp/>0.0;</highlight></codeline>
<codeline lineno="409"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="410"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Compute<sp/>the<sp/>exponential<sp/>prefactor<sp/>hashtable<sp/>index<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="411"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="412"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Loop<sp/>over<sp/>polar<sp/>angles<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="413"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>p=0;<sp/>p<sp/>&lt;<sp/>*num_polar;<sp/>p++)<sp/>{</highlight></codeline>
<codeline lineno="414"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>exponential<sp/>=<sp/>computeExponential(sigma_t[energy_group],<sp/></highlight></codeline>
<codeline lineno="415"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>length,<sp/>_prefactor_array,<sp/>p);</highlight></codeline>
<codeline lineno="416"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>psibar<sp/>=<sp/>(track_flux[p]<sp/>-<sp/><ref refid="GPUSolver_8h_1a201104e7c4ebc64308385f741ae5143d" kindref="member">reduced_source</ref>(fsr_id,energy_group))<sp/>*<sp/></highlight></codeline>
<codeline lineno="417"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>exponential;</highlight></codeline>
<codeline lineno="418"><highlight class="normal"><sp/><sp/><sp/><sp/>fsr_flux<sp/>+=<sp/>psibar<sp/>*<sp/>polar_weights[p];</highlight></codeline>
<codeline lineno="419"><highlight class="normal"><sp/><sp/><sp/><sp/>track_flux[p]<sp/>-=<sp/>psibar;</highlight></codeline>
<codeline lineno="420"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="421"><highlight class="normal"></highlight></codeline>
<codeline lineno="422"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Atomically<sp/>increment<sp/>the<sp/>scalar<sp/>flux<sp/>for<sp/>this<sp/>flat<sp/>source<sp/>region<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="423"><highlight class="normal"><sp/><sp/><sp/><sp/>atomicAdd(&amp;<ref refid="GPUSolver_8h_1a4089c9be8cf297ccf942eb8c29cca415" kindref="member">scalar_flux</ref>(fsr_id,energy_group),<sp/>fsr_flux);</highlight></codeline>
<codeline lineno="424"><highlight class="normal">}</highlight></codeline>
<codeline lineno="425"><highlight class="normal"></highlight></codeline>
<codeline lineno="426"><highlight class="normal"></highlight></codeline>
<codeline lineno="441"><highlight class="normal">__device__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>transferBoundaryFlux(<ref refid="structdev__track" kindref="compound" tooltip="A dev_track represents a characteristic line across the geometry.">dev_track</ref>*<sp/>curr_track,</highlight></codeline>
<codeline lineno="442"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FP_PRECISION*<sp/>track_flux,<sp/></highlight></codeline>
<codeline lineno="443"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FP_PRECISION*<sp/>boundary_flux,<sp/></highlight></codeline>
<codeline lineno="444"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FP_PRECISION*<sp/>leakage,</highlight></codeline>
<codeline lineno="445"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FP_PRECISION*<sp/>polar_weights,</highlight></codeline>
<codeline lineno="446"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>energy_angle_index,</highlight></codeline>
<codeline lineno="447"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>direction)<sp/>{</highlight></codeline>
<codeline lineno="448"><highlight class="normal"></highlight></codeline>
<codeline lineno="449"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>start<sp/>=<sp/>energy_angle_index;</highlight></codeline>
<codeline lineno="450"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>bc;</highlight></codeline>
<codeline lineno="451"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>track_out_id;</highlight></codeline>
<codeline lineno="452"><highlight class="normal"></highlight></codeline>
<codeline lineno="453"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Extract<sp/>boundary<sp/>conditions<sp/>for<sp/>this<sp/>track<sp/>and<sp/>the<sp/>pointer<sp/>to<sp/>the</highlight></codeline>
<codeline lineno="454"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>outgoing<sp/>reflective<sp/>track,<sp/>and<sp/>index<sp/>into<sp/>the<sp/>leakage<sp/>array<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="455"><highlight class="normal"></highlight></codeline>
<codeline lineno="456"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>For<sp/>the<sp/>&quot;forward&quot;<sp/>direction<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="457"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(direction)<sp/>{</highlight></codeline>
<codeline lineno="458"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bc<sp/>=<sp/>curr_track-&gt;<ref refid="structdev__track_1addb28e8a88465c66a1a9d7a9ad58f911" kindref="member">_bc_out</ref>;</highlight></codeline>
<codeline lineno="459"><highlight class="normal"><sp/><sp/><sp/><sp/>track_out_id<sp/>=<sp/>curr_track-&gt;<ref refid="structdev__track_1ae1cc4465ace9a092f14a39dfdf5092cc" kindref="member">_track_out</ref>;</highlight></codeline>
<codeline lineno="460"><highlight class="normal"><sp/><sp/><sp/><sp/>start<sp/>+=<sp/>curr_track-&gt;<ref refid="structdev__track_1a17fffea5df6d8c3f41a627c1395eeae1" kindref="member">_refl_out</ref><sp/>*<sp/>(*polar_times_groups);</highlight></codeline>
<codeline lineno="461"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="462"><highlight class="normal"></highlight></codeline>
<codeline lineno="463"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>For<sp/>the<sp/>&quot;reverse&quot;<sp/>direction<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="464"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="465"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>bc<sp/>=<sp/>curr_track-&gt;<ref refid="structdev__track_1ad7d86a84771ebc8fbed3dd65594b3576" kindref="member">_bc_in</ref>;</highlight></codeline>
<codeline lineno="466"><highlight class="normal"><sp/><sp/><sp/><sp/>track_out_id<sp/>=<sp/>curr_track-&gt;<ref refid="structdev__track_1acca709c56cb665b225cfd792390ca389" kindref="member">_track_in</ref>;</highlight></codeline>
<codeline lineno="467"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>start<sp/>+=<sp/>curr_track-&gt;<ref refid="structdev__track_1a9b75926a79608ba2918268efd431b1dd" kindref="member">_refl_in</ref><sp/>*<sp/>(*polar_times_groups);</highlight></codeline>
<codeline lineno="468"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="469"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="470"><highlight class="normal"><sp/><sp/><sp/><sp/>FP_PRECISION*<sp/><ref refid="CPUSolver_8h_1a1ada87108681a86ec25d66c3644e04e3" kindref="member">track_out_flux</ref><sp/>=<sp/>&amp;<ref refid="GPUSolver_8h_1acf77ad5d19c7d5cccf263d9a91700d2e" kindref="member">boundary_flux</ref>(track_out_id,start);</highlight></codeline>
<codeline lineno="471"><highlight class="normal"></highlight></codeline>
<codeline lineno="472"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Put<sp/>track&apos;s<sp/>flux<sp/>in<sp/>the<sp/>shared<sp/>memory<sp/>temporary<sp/>flux<sp/>array<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="473"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>p=0;<sp/>p<sp/>&lt;<sp/>*num_polar;<sp/>p++)<sp/>{</highlight></codeline>
<codeline lineno="474"><highlight class="normal"><sp/><sp/><sp/><sp/>track_out_flux[p]<sp/>=<sp/>track_flux[p]<sp/>*<sp/>bc;</highlight></codeline>
<codeline lineno="475"><highlight class="normal"><sp/><sp/><sp/><sp/>leakage[0]<sp/>+=<sp/>track_flux[p]<sp/>*<sp/>polar_weights[p]<sp/>*<sp/>(!bc);</highlight></codeline>
<codeline lineno="476"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="477"><highlight class="normal">}</highlight></codeline>
<codeline lineno="478"><highlight class="normal"></highlight></codeline>
<codeline lineno="479"><highlight class="normal"></highlight></codeline>
<codeline lineno="497"><highlight class="normal">__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>transportSweepOnDevice(FP_PRECISION*<sp/>scalar_flux,</highlight></codeline>
<codeline lineno="498"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FP_PRECISION*<sp/>boundary_flux,</highlight></codeline>
<codeline lineno="499"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FP_PRECISION*<sp/>reduced_source,</highlight></codeline>
<codeline lineno="500"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FP_PRECISION*<sp/>leakage,</highlight></codeline>
<codeline lineno="501"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structdev__material" kindref="compound" tooltip="A material&amp;#39;s nuclear data to be stored on a GPU.">dev_material</ref>*<sp/>materials,</highlight></codeline>
<codeline lineno="502"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structdev__track" kindref="compound" tooltip="A dev_track represents a characteristic line across the geometry.">dev_track</ref>*<sp/>tracks,</highlight></codeline>
<codeline lineno="503"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FP_PRECISION*<sp/>_prefactor_array,</highlight></codeline>
<codeline lineno="504"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>tid_offset,</highlight></codeline>
<codeline lineno="505"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>tid_max)<sp/>{</highlight></codeline>
<codeline lineno="506"><highlight class="normal"></highlight></codeline>
<codeline lineno="507"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Shared<sp/>memory<sp/>buffer<sp/>for<sp/>each<sp/>thread&apos;s<sp/>angular<sp/>flux<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="508"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">extern</highlight><highlight class="normal"><sp/>__shared__<sp/>FP_PRECISION<sp/>temp_flux[];</highlight></codeline>
<codeline lineno="509"><highlight class="normal"><sp/><sp/><sp/><sp/>FP_PRECISION*<sp/><ref refid="CPUSolver_8h_1a2143506339a36528e1c9d7e27501897f" kindref="member">track_flux</ref>;</highlight></codeline>
<codeline lineno="510"><highlight class="normal"></highlight></codeline>
<codeline lineno="511"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>tid<sp/>=<sp/>tid_offset<sp/>+<sp/>threadIdx.x<sp/>+<sp/>blockIdx.x<sp/>*<sp/>blockDim.x;</highlight></codeline>
<codeline lineno="512"><highlight class="normal"></highlight></codeline>
<codeline lineno="513"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>track_id<sp/>=<sp/>int(tid<sp/>/<sp/>*num_groups);</highlight></codeline>
<codeline lineno="514"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>track_flux_index<sp/>=<sp/>threadIdx.x<sp/>*<sp/>(*two_times_num_polar);</highlight></codeline>
<codeline lineno="515"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>energy_group<sp/>=<sp/>tid<sp/>%<sp/>(*num_groups);</highlight></codeline>
<codeline lineno="516"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>energy_angle_index<sp/>=<sp/>energy_group<sp/>*<sp/>(*num_polar);</highlight></codeline>
<codeline lineno="517"><highlight class="normal"></highlight></codeline>
<codeline lineno="518"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structdev__track" kindref="compound" tooltip="A dev_track represents a characteristic line across the geometry.">dev_track</ref>*<sp/>curr_track;</highlight></codeline>
<codeline lineno="519"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>num_segments;</highlight></codeline>
<codeline lineno="520"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structdev__segment" kindref="compound" tooltip="A dev_segment represents a line segment within a single flat source region along a track...">dev_segment</ref>*<sp/>curr_segment;</highlight></codeline>
<codeline lineno="521"><highlight class="normal"></highlight></codeline>
<codeline lineno="522"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Iterate<sp/>over<sp/>track<sp/>with<sp/>azimuthal<sp/>angles<sp/>in<sp/>(0,<sp/>pi/2)<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="523"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(track_id<sp/>&lt;<sp/>tid_max)<sp/>{</highlight></codeline>
<codeline lineno="524"><highlight class="normal"></highlight></codeline>
<codeline lineno="525"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Initialize<sp/>local<sp/>registers<sp/>with<sp/>important<sp/>data<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="526"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>curr_track<sp/>=<sp/>&amp;tracks[track_id];</highlight></codeline>
<codeline lineno="527"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>num_segments<sp/>=<sp/>curr_track-&gt;<ref refid="structdev__track_1a257b1a4150d11de2e2a2809c2713de6c" kindref="member">_num_segments</ref>;</highlight></codeline>
<codeline lineno="528"><highlight class="normal"></highlight></codeline>
<codeline lineno="529"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Retrieve<sp/>a<sp/>pointer<sp/>to<sp/>this<sp/>thread&apos;s<sp/>shared<sp/>memory<sp/>buffer<sp/>for<sp/>angular<sp/>flux<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="530"><highlight class="normal"><sp/><sp/><sp/><sp/>track_flux<sp/>=<sp/>&amp;temp_flux[track_flux_index];</highlight></codeline>
<codeline lineno="531"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="532"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Put<sp/>track&apos;s<sp/>flux<sp/>in<sp/>the<sp/>shared<sp/>memory<sp/>temporary<sp/>flux<sp/>array<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="533"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>p=0;<sp/>p<sp/>&lt;<sp/>*num_polar;<sp/>p++)<sp/>{</highlight></codeline>
<codeline lineno="534"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="535"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Forward<sp/>flux<sp/>along<sp/>this<sp/>track<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="536"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>track_flux[p]<sp/>=<sp/><ref refid="GPUSolver_8h_1acf77ad5d19c7d5cccf263d9a91700d2e" kindref="member">boundary_flux</ref>(track_id,p+energy_angle_index);</highlight></codeline>
<codeline lineno="537"><highlight class="normal"></highlight></codeline>
<codeline lineno="538"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Reverse<sp/>flux<sp/>along<sp/>this<sp/>track<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="539"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>track_flux[(*num_polar)<sp/>+<sp/>p]<sp/>=<sp/><ref refid="GPUSolver_8h_1acf77ad5d19c7d5cccf263d9a91700d2e" kindref="member">boundary_flux</ref>(track_id,p+energy_angle_index+(*polar_times_groups));</highlight></codeline>
<codeline lineno="540"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="541"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="542"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Loop<sp/>over<sp/>each<sp/>segment<sp/>in<sp/>forward<sp/>direction<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="543"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i=0;<sp/>i<sp/>&lt;<sp/>num_segments;<sp/>i++)<sp/>{</highlight></codeline>
<codeline lineno="544"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>curr_segment<sp/>=<sp/>&amp;curr_track-&gt;<ref refid="structdev__track_1a0d80897523e45e6d3c23e6dbe94f7210" kindref="member">_segments</ref>[i];</highlight></codeline>
<codeline lineno="545"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>scalarFluxTally(curr_segment,<sp/>energy_group,<sp/>materials,</highlight></codeline>
<codeline lineno="546"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>track_flux,<sp/>reduced_source,<sp/>polar_weights,</highlight></codeline>
<codeline lineno="547"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_prefactor_array,<sp/>scalar_flux);</highlight></codeline>
<codeline lineno="548"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="549"><highlight class="normal"></highlight></codeline>
<codeline lineno="550"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Transfer<sp/>flux<sp/>to<sp/>outgoing<sp/>track<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="551"><highlight class="normal"><sp/><sp/><sp/><sp/>transferBoundaryFlux(curr_track,<sp/>track_flux,<sp/>boundary_flux,<sp/></highlight></codeline>
<codeline lineno="552"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;leakage[threadIdx.x<sp/>+<sp/>blockIdx.x<sp/>*<sp/>blockDim.x],<sp/></highlight></codeline>
<codeline lineno="553"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>polar_weights,<sp/>energy_angle_index,<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="554"><highlight class="normal"></highlight></codeline>
<codeline lineno="555"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Loop<sp/>over<sp/>each<sp/>segment<sp/>in<sp/>reverse<sp/>direction<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="556"><highlight class="normal"><sp/><sp/><sp/><sp/>track_flux<sp/>=<sp/>&amp;temp_flux[track_flux_index<sp/>+<sp/>(*num_polar)];</highlight></codeline>
<codeline lineno="557"><highlight class="normal"></highlight></codeline>
<codeline lineno="558"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i=num_segments-1;<sp/>i<sp/>&gt;<sp/>-1;<sp/>i--)<sp/>{</highlight></codeline>
<codeline lineno="559"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>curr_segment<sp/>=<sp/>&amp;curr_track-&gt;<ref refid="structdev__track_1a0d80897523e45e6d3c23e6dbe94f7210" kindref="member">_segments</ref>[i];</highlight></codeline>
<codeline lineno="560"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>scalarFluxTally(curr_segment,<sp/>energy_group,<sp/>materials,</highlight></codeline>
<codeline lineno="561"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>track_flux,<sp/>reduced_source,<sp/>polar_weights,</highlight></codeline>
<codeline lineno="562"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_prefactor_array,<sp/>scalar_flux);</highlight></codeline>
<codeline lineno="563"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="564"><highlight class="normal"></highlight></codeline>
<codeline lineno="565"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Transfer<sp/>flux<sp/>to<sp/>outgoing<sp/>track<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="566"><highlight class="normal"><sp/><sp/><sp/><sp/>transferBoundaryFlux(curr_track,<sp/>track_flux,<sp/>boundary_flux,<sp/></highlight></codeline>
<codeline lineno="567"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>&amp;leakage[threadIdx.x<sp/>+<sp/>blockIdx.x<sp/>*<sp/>blockDim.x],<sp/></highlight></codeline>
<codeline lineno="568"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>polar_weights,<sp/>energy_angle_index,<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="569"><highlight class="normal"></highlight></codeline>
<codeline lineno="570"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Update<sp/>the<sp/>indices<sp/>for<sp/>this<sp/>thread<sp/>to<sp/>the<sp/>next<sp/>track,<sp/>energy<sp/>group<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="571"><highlight class="normal"><sp/><sp/><sp/><sp/>tid<sp/>+=<sp/>blockDim.x<sp/>*<sp/>gridDim.x;</highlight></codeline>
<codeline lineno="572"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>track_id<sp/>=<sp/>int(tid<sp/>/<sp/>*num_groups);</highlight></codeline>
<codeline lineno="573"><highlight class="normal"><sp/><sp/><sp/><sp/>energy_group<sp/>=<sp/>tid<sp/>%<sp/>(*num_groups);</highlight></codeline>
<codeline lineno="574"><highlight class="normal"><sp/><sp/><sp/><sp/>energy_angle_index<sp/>=<sp/>energy_group<sp/>*<sp/>(*num_polar);</highlight></codeline>
<codeline lineno="575"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="576"><highlight class="normal"></highlight></codeline>
<codeline lineno="577"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="578"><highlight class="normal">}</highlight></codeline>
<codeline lineno="579"><highlight class="normal"></highlight></codeline>
<codeline lineno="580"><highlight class="normal"></highlight></codeline>
<codeline lineno="590"><highlight class="normal">__global__<sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>addSourceToScalarFluxOnDevice(FP_PRECISION*<sp/>scalar_flux,</highlight></codeline>
<codeline lineno="591"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FP_PRECISION*<sp/>reduced_source,</highlight></codeline>
<codeline lineno="592"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>FP_PRECISION*<sp/>FSR_volumes,</highlight></codeline>
<codeline lineno="593"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>FSR_materials,</highlight></codeline>
<codeline lineno="594"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="structdev__material" kindref="compound" tooltip="A material&amp;#39;s nuclear data to be stored on a GPU.">dev_material</ref>*<sp/>materials)<sp/>{</highlight></codeline>
<codeline lineno="595"><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline lineno="596"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>tid<sp/>=<sp/>threadIdx.x<sp/>+<sp/>blockIdx.x<sp/>*<sp/>blockDim.x;</highlight></codeline>
<codeline lineno="597"><highlight class="normal"><sp/><sp/><sp/><sp/>FP_PRECISION<sp/>volume;</highlight></codeline>
<codeline lineno="598"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="599"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structdev__material" kindref="compound" tooltip="A material&amp;#39;s nuclear data to be stored on a GPU.">dev_material</ref>*<sp/>curr_material;</highlight></codeline>
<codeline lineno="600"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>sigma_t;</highlight></codeline>
<codeline lineno="601"><highlight class="normal"></highlight></codeline>
<codeline lineno="602"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Iterate<sp/>over<sp/>all<sp/>FSRs<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="603"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(tid<sp/>&lt;<sp/>*num_FSRs)<sp/>{</highlight></codeline>
<codeline lineno="604"><highlight class="normal"></highlight></codeline>
<codeline lineno="605"><highlight class="normal"><sp/><sp/><sp/><sp/>curr_material<sp/>=<sp/>&amp;materials[FSR_materials[tid]];</highlight></codeline>
<codeline lineno="606"><highlight class="normal"><sp/><sp/><sp/><sp/>volume<sp/>=<sp/>FSR_volumes[tid];</highlight></codeline>
<codeline lineno="607"><highlight class="normal"><sp/><sp/><sp/><sp/>sigma_t<sp/>=<sp/>curr_material-&gt;<ref refid="structdev__material_1add13483475ff96bda102dcb7a22ed899" kindref="member">_sigma_t</ref>;</highlight></codeline>
<codeline lineno="608"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="609"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Iterate<sp/>over<sp/>all<sp/>energy<sp/>groups<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="610"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i=0;<sp/>i<sp/>&lt;<sp/>*num_groups;<sp/>i++)<sp/>{</highlight></codeline>
<codeline lineno="611"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="GPUSolver_8h_1a4089c9be8cf297ccf942eb8c29cca415" kindref="member">scalar_flux</ref>(tid,i)<sp/>*=<sp/>0.5;</highlight></codeline>
<codeline lineno="612"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="GPUSolver_8h_1a4089c9be8cf297ccf942eb8c29cca415" kindref="member">scalar_flux</ref>(tid,i)<sp/>=<sp/><ref refid="GPUSolver_8h_1ac6b39b7a27b735f3a62be33f38041985" kindref="member">FOUR_PI</ref><sp/>*<sp/><ref refid="GPUSolver_8h_1a201104e7c4ebc64308385f741ae5143d" kindref="member">reduced_source</ref>(tid,i)<sp/>+<sp/></highlight></codeline>
<codeline lineno="613"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>__fdividef(<ref refid="GPUSolver_8h_1a4089c9be8cf297ccf942eb8c29cca415" kindref="member">scalar_flux</ref>(tid,i),<sp/>(sigma_t[i]<sp/>*<sp/>volume));</highlight></codeline>
<codeline lineno="614"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="615"><highlight class="normal"></highlight></codeline>
<codeline lineno="616"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Increment<sp/>thread<sp/>id<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="617"><highlight class="normal"><sp/><sp/><sp/><sp/>tid<sp/>+=<sp/>blockDim.x<sp/>*<sp/>gridDim.x;</highlight></codeline>
<codeline lineno="618"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="619"><highlight class="normal"></highlight></codeline>
<codeline lineno="620"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="621"><highlight class="normal">}</highlight></codeline>
<codeline lineno="622"><highlight class="normal"></highlight></codeline>
<codeline lineno="623"><highlight class="normal"></highlight></codeline>
<codeline lineno="624"><highlight class="normal"></highlight></codeline>
<codeline lineno="625"><highlight class="normal"></highlight></codeline>
<codeline lineno="634"><highlight class="normal">GPUSolver::GPUSolver(<ref refid="classGeometry" kindref="compound" tooltip="The master class containing references to all geometry-related objects (surfaces, cells...">Geometry</ref>*<sp/>geometry,<sp/><ref refid="classTrackGenerator" kindref="compound" tooltip="The track generator is dedicated to generating tracks which cyclically wrap across the geometry...">TrackGenerator</ref>*<sp/>track_generator)<sp/>:</highlight></codeline>
<codeline lineno="635"><highlight class="normal"></highlight></codeline>
<codeline lineno="636"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classSolver" kindref="compound" tooltip="This is an abstract base class from which different types of Solvers subclass for different architect...">Solver</ref>(geometry,<sp/>track_generator)<sp/>{</highlight></codeline>
<codeline lineno="637"><highlight class="normal"></highlight></codeline>
<codeline lineno="638"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/**************************************************************************/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="639"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Host<sp/>data<sp/>initialization<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="640"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/**************************************************************************/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="641"><highlight class="normal"></highlight></codeline>
<codeline lineno="642"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>The<sp/>default<sp/>number<sp/>of<sp/>threadblocks<sp/>and<sp/>threads<sp/>per<sp/>threadblock<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="643"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>_B<sp/>=<sp/>64;</highlight></codeline>
<codeline lineno="644"><highlight class="normal"><sp/><sp/><sp/><sp/>_T<sp/>=<sp/>64;</highlight></codeline>
<codeline lineno="645"><highlight class="normal"></highlight></codeline>
<codeline lineno="646"><highlight class="normal"></highlight></codeline>
<codeline lineno="647"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/**************************************************************************/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="648"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Device<sp/>data<sp/>initialization<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="649"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/**************************************************************************/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="650"><highlight class="normal"></highlight></codeline>
<codeline lineno="651"><highlight class="normal"><sp/><sp/><sp/><sp/>_materials<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="652"><highlight class="normal"><sp/><sp/><sp/><sp/>_dev_tracks<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="653"><highlight class="normal"></highlight></codeline>
<codeline lineno="654"><highlight class="normal"><sp/><sp/><sp/><sp/>_tot_absorption<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="655"><highlight class="normal"><sp/><sp/><sp/><sp/>_tot_fission<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="656"><highlight class="normal"><sp/><sp/><sp/><sp/>_leakage<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="657"><highlight class="normal"></highlight></codeline>
<codeline lineno="658"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(track_generator<sp/>!=<sp/>NULL)</highlight></codeline>
<codeline lineno="659"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>setTrackGenerator(track_generator);</highlight></codeline>
<codeline lineno="660"><highlight class="normal"></highlight></codeline>
<codeline lineno="661"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(geometry<sp/>!=<sp/>NULL)</highlight></codeline>
<codeline lineno="662"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>setGeometry(geometry);</highlight></codeline>
<codeline lineno="663"><highlight class="normal">}</highlight></codeline>
<codeline lineno="664"><highlight class="normal"></highlight></codeline>
<codeline lineno="665"><highlight class="normal"></highlight></codeline>
<codeline lineno="666"><highlight class="normal"></highlight></codeline>
<codeline lineno="671"><highlight class="normal">GPUSolver::~GPUSolver()<sp/>{</highlight></codeline>
<codeline lineno="672"><highlight class="normal"></highlight></codeline>
<codeline lineno="673"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="classSolver_1a84372339d7c2b5da3f07bc8b0822f42f" kindref="member">_FSR_volumes</ref><sp/>!=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="674"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaFree(<ref refid="classSolver_1a84372339d7c2b5da3f07bc8b0822f42f" kindref="member">_FSR_volumes</ref>);</highlight></codeline>
<codeline lineno="675"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classSolver_1a84372339d7c2b5da3f07bc8b0822f42f" kindref="member">_FSR_volumes</ref><sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="676"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="677"><highlight class="normal"></highlight></codeline>
<codeline lineno="678"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(_FSR_materials<sp/>!=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="679"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaFree(_FSR_materials);</highlight></codeline>
<codeline lineno="680"><highlight class="normal"><sp/><sp/><sp/><sp/>_FSR_materials<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="681"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="682"><highlight class="normal"></highlight></codeline>
<codeline lineno="683"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(_materials<sp/>!=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="684"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaFree(_materials);</highlight></codeline>
<codeline lineno="685"><highlight class="normal"><sp/><sp/><sp/><sp/>_materials<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="686"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="687"><highlight class="normal"></highlight></codeline>
<codeline lineno="688"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(_dev_tracks<sp/>!=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="689"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaFree(_dev_tracks);</highlight></codeline>
<codeline lineno="690"><highlight class="normal"><sp/><sp/><sp/><sp/>_dev_tracks<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="691"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="692"><highlight class="normal"></highlight></codeline>
<codeline lineno="693"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="classSolver_1adcfcfe1758affc74780907584fc7beaf" kindref="member">_boundary_flux</ref><sp/>!=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="694"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaFree(<ref refid="classSolver_1adcfcfe1758affc74780907584fc7beaf" kindref="member">_boundary_flux</ref>);</highlight></codeline>
<codeline lineno="695"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classSolver_1adcfcfe1758affc74780907584fc7beaf" kindref="member">_boundary_flux</ref><sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="696"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="697"><highlight class="normal"></highlight></codeline>
<codeline lineno="698"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="classSolver_1a60df3fd1a13667c294b1519d59a00b87" kindref="member">_scalar_flux</ref><sp/>!=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="699"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaFree(<ref refid="classSolver_1a60df3fd1a13667c294b1519d59a00b87" kindref="member">_scalar_flux</ref>);</highlight></codeline>
<codeline lineno="700"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classSolver_1a60df3fd1a13667c294b1519d59a00b87" kindref="member">_scalar_flux</ref><sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="701"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="702"><highlight class="normal"></highlight></codeline>
<codeline lineno="703"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="classSolver_1a935ab1926ea3d625d0c549c5f8595c07" kindref="member">_source</ref><sp/>!=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="704"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaFree(<ref refid="classSolver_1a935ab1926ea3d625d0c549c5f8595c07" kindref="member">_source</ref>);</highlight></codeline>
<codeline lineno="705"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classSolver_1a935ab1926ea3d625d0c549c5f8595c07" kindref="member">_source</ref><sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="706"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="707"><highlight class="normal"></highlight></codeline>
<codeline lineno="708"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="classSolver_1ad7d3233142b6798f9aea7330b221754c" kindref="member">_old_source</ref><sp/>!=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="709"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaFree(<ref refid="classSolver_1ad7d3233142b6798f9aea7330b221754c" kindref="member">_old_source</ref>);</highlight></codeline>
<codeline lineno="710"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classSolver_1ad7d3233142b6798f9aea7330b221754c" kindref="member">_old_source</ref><sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="711"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="712"><highlight class="normal"></highlight></codeline>
<codeline lineno="713"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="classSolver_1aff69bb3f354f5c598e1117e2a3515f1b" kindref="member">_reduced_source</ref><sp/>!=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="714"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaFree(<ref refid="classSolver_1aff69bb3f354f5c598e1117e2a3515f1b" kindref="member">_reduced_source</ref>);</highlight></codeline>
<codeline lineno="715"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classSolver_1aff69bb3f354f5c598e1117e2a3515f1b" kindref="member">_reduced_source</ref><sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="716"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="717"><highlight class="normal"></highlight></codeline>
<codeline lineno="718"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="classSolver_1ac6de9ad9091dae955848d83a91b0f3b5" kindref="member">_FSRs_to_powers</ref><sp/>!=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="719"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaFree(<ref refid="classSolver_1ac6de9ad9091dae955848d83a91b0f3b5" kindref="member">_FSRs_to_powers</ref>);</highlight></codeline>
<codeline lineno="720"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classSolver_1ac6de9ad9091dae955848d83a91b0f3b5" kindref="member">_FSRs_to_powers</ref><sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="721"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="722"><highlight class="normal"></highlight></codeline>
<codeline lineno="723"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="classSolver_1a2ae997684ddbc16e2c8575cb6dcad788" kindref="member">_FSRs_to_pin_powers</ref><sp/>!=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="724"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaFree(<ref refid="classSolver_1a2ae997684ddbc16e2c8575cb6dcad788" kindref="member">_FSRs_to_pin_powers</ref>);</highlight></codeline>
<codeline lineno="725"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classSolver_1a2ae997684ddbc16e2c8575cb6dcad788" kindref="member">_FSRs_to_pin_powers</ref><sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="726"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="727"><highlight class="normal"></highlight></codeline>
<codeline lineno="728"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="classSolver_1a63b1f8d78d02dc5a0f2dc392597cc5af" kindref="member">_fission_sources</ref><sp/>!=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="729"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_fission_sources_vec.clear();</highlight></codeline>
<codeline lineno="730"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classSolver_1a63b1f8d78d02dc5a0f2dc392597cc5af" kindref="member">_fission_sources</ref><sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="731"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="732"><highlight class="normal"></highlight></codeline>
<codeline lineno="733"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(_tot_absorption<sp/>!=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="734"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_tot_absorption_vec.clear();</highlight></codeline>
<codeline lineno="735"><highlight class="normal"><sp/><sp/><sp/><sp/>_tot_absorption<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="736"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="737"><highlight class="normal"></highlight></codeline>
<codeline lineno="738"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(_tot_fission<sp/>!=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="739"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_tot_fission_vec.clear();</highlight></codeline>
<codeline lineno="740"><highlight class="normal"><sp/><sp/><sp/><sp/>_tot_fission<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="741"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="742"><highlight class="normal"></highlight></codeline>
<codeline lineno="743"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="classSolver_1af2285a2a6361ea1d351e3b8c55858c92" kindref="member">_source_residuals</ref><sp/>!=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="744"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_source_residuals_vec.clear();</highlight></codeline>
<codeline lineno="745"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classSolver_1af2285a2a6361ea1d351e3b8c55858c92" kindref="member">_source_residuals</ref><sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="746"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="747"><highlight class="normal"></highlight></codeline>
<codeline lineno="748"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(_leakage<sp/>!=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="749"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_leakage_vec.clear();</highlight></codeline>
<codeline lineno="750"><highlight class="normal"><sp/><sp/><sp/><sp/>_leakage<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="751"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="752"><highlight class="normal"></highlight></codeline>
<codeline lineno="753"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(_prefactor_array<sp/>!=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="754"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaFree(_prefactor_array);</highlight></codeline>
<codeline lineno="755"><highlight class="normal"><sp/><sp/><sp/><sp/>_prefactor_array<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="756"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="757"><highlight class="normal">}</highlight></codeline>
<codeline lineno="758"><highlight class="normal"></highlight></codeline>
<codeline lineno="759"><highlight class="normal"></highlight></codeline>
<codeline lineno="765"><highlight class="normal">FP_PRECISION<sp/><ref refid="classGPUSolver_1a7bdb08af13273639f652d0acc22eae28" kindref="member" tooltip="Returns the scalar flux for a flat source region.">GPUSolver::getFSRScalarFlux</ref>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>fsr_id,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>energy_group)<sp/>{</highlight></codeline>
<codeline lineno="766"><highlight class="normal"></highlight></codeline>
<codeline lineno="767"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Error<sp/>checking<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="768"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(fsr_id<sp/>&gt;=<sp/><ref refid="classSolver_1a2e17e8aa8a11d4300e89179984ca4347" kindref="member">_num_FSRs</ref>)</highlight></codeline>
<codeline lineno="769"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>log_printf(<ref refid="log_8h_1a5096002e05063d13577205e0bc5f0564a2fd6f336d08340583bd620a7f5694c90" kindref="member">ERROR</ref>,<sp/></highlight><highlight class="stringliteral">&quot;Unable<sp/>to<sp/>return<sp/>a<sp/>scalar<sp/>flux<sp/>for<sp/>FSR<sp/>id<sp/>=<sp/>%d<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="770"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;in<sp/>enery<sp/>group<sp/>%d<sp/>since<sp/>the<sp/>solver<sp/>only<sp/>contains<sp/>FSR<sp/>with<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="771"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;IDs<sp/>greater<sp/>than<sp/>or<sp/>equal<sp/>to<sp/>%d&quot;</highlight><highlight class="normal">,<sp/></highlight></codeline>
<codeline lineno="772"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fsr_id,<sp/>energy_group,<sp/><ref refid="classSolver_1a2e17e8aa8a11d4300e89179984ca4347" kindref="member">_num_FSRs</ref>-1);</highlight></codeline>
<codeline lineno="773"><highlight class="normal"></highlight></codeline>
<codeline lineno="774"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(fsr_id<sp/>&lt;<sp/>0)</highlight></codeline>
<codeline lineno="775"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>log_printf(<ref refid="log_8h_1a5096002e05063d13577205e0bc5f0564a2fd6f336d08340583bd620a7f5694c90" kindref="member">ERROR</ref>,<sp/></highlight><highlight class="stringliteral">&quot;Unable<sp/>to<sp/>return<sp/>a<sp/>scalar<sp/>flux<sp/>for<sp/>FSR<sp/>id<sp/>=<sp/>%d<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="776"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;in<sp/>energy<sp/>group<sp/>%d<sp/>since<sp/>FSRs<sp/>do<sp/>not<sp/>have<sp/>negative<sp/>IDs&quot;</highlight><highlight class="normal">,<sp/></highlight></codeline>
<codeline lineno="777"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fsr_id,<sp/>energy_group);</highlight></codeline>
<codeline lineno="778"><highlight class="normal"></highlight></codeline>
<codeline lineno="779"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(energy_group-1<sp/>&gt;=<sp/><ref refid="classSolver_1ab18db0ed64afb0dade6054a7a08ae3c4" kindref="member">_num_groups</ref>)</highlight></codeline>
<codeline lineno="780"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>log_printf(<ref refid="log_8h_1a5096002e05063d13577205e0bc5f0564a2fd6f336d08340583bd620a7f5694c90" kindref="member">ERROR</ref>,<sp/></highlight><highlight class="stringliteral">&quot;Unable<sp/>to<sp/>return<sp/>a<sp/>scalar<sp/>flux<sp/>for<sp/>FSR<sp/>id<sp/>=<sp/>%d<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="781"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;in<sp/>energy<sp/>group<sp/>%d<sp/>since<sp/>the<sp/>solver<sp/>only<sp/>has<sp/>%d<sp/>energy<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="782"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;groups&quot;</highlight><highlight class="normal">,<sp/>fsr_id,<sp/>energy_group,<sp/><ref refid="classSolver_1ab18db0ed64afb0dade6054a7a08ae3c4" kindref="member">_num_groups</ref>);</highlight></codeline>
<codeline lineno="783"><highlight class="normal"></highlight></codeline>
<codeline lineno="784"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(energy_group<sp/>&lt;=<sp/>0)</highlight></codeline>
<codeline lineno="785"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>log_printf(<ref refid="log_8h_1a5096002e05063d13577205e0bc5f0564a2fd6f336d08340583bd620a7f5694c90" kindref="member">ERROR</ref>,<sp/></highlight><highlight class="stringliteral">&quot;Unable<sp/>to<sp/>return<sp/>a<sp/>scalar<sp/>flux<sp/>for<sp/>FSR<sp/>id<sp/>=<sp/>%d<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="786"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;in<sp/>energy<sp/>group<sp/>%d<sp/>since<sp/>energy<sp/>groups<sp/>are<sp/>greater<sp/>than<sp/>1&quot;</highlight><highlight class="normal">,</highlight></codeline>
<codeline lineno="787"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>fsr_id,<sp/>energy_group);</highlight></codeline>
<codeline lineno="788"><highlight class="normal"></highlight></codeline>
<codeline lineno="789"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Copy<sp/>the<sp/>scalar<sp/>flux<sp/>for<sp/>this<sp/>FSR<sp/>and<sp/>energy<sp/>group<sp/>from<sp/>the<sp/>device<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="790"><highlight class="normal"><sp/><sp/><sp/><sp/>FP_PRECISION<sp/>fsr_scalar_flux;</highlight></codeline>
<codeline lineno="791"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>flux_index<sp/>=<sp/>fsr_id<sp/>*<sp/><ref refid="classSolver_1ab18db0ed64afb0dade6054a7a08ae3c4" kindref="member">_num_groups</ref><sp/>+<sp/>energy_group<sp/>-<sp/>1;</highlight></codeline>
<codeline lineno="792"><highlight class="normal"><sp/><sp/><sp/><sp/>cudaMemcpy((</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*)&amp;fsr_scalar_flux,<sp/>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*)&amp;<ref refid="classSolver_1a60df3fd1a13667c294b1519d59a00b87" kindref="member">_scalar_flux</ref>[flux_index],<sp/></highlight></codeline>
<codeline lineno="793"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(FP_PRECISION),<sp/>cudaMemcpyDeviceToHost);</highlight></codeline>
<codeline lineno="794"><highlight class="normal"></highlight></codeline>
<codeline lineno="795"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>fsr_scalar_flux;</highlight></codeline>
<codeline lineno="796"><highlight class="normal">}</highlight></codeline>
<codeline lineno="797"><highlight class="normal"></highlight></codeline>
<codeline lineno="798"><highlight class="normal"></highlight></codeline>
<codeline lineno="804"><highlight class="normal">FP_PRECISION*<sp/><ref refid="classGPUSolver_1a181b0d902129e5bb8e70375e061c3c6f" kindref="member" tooltip="Returns an array of the scalar flux in each flat source region in each energy group.">GPUSolver::getFSRScalarFluxes</ref>()<sp/>{</highlight></codeline>
<codeline lineno="805"><highlight class="normal"></highlight></codeline>
<codeline lineno="806"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="classSolver_1a60df3fd1a13667c294b1519d59a00b87" kindref="member">_scalar_flux</ref><sp/>==<sp/>NULL)</highlight></codeline>
<codeline lineno="807"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>log_printf(<ref refid="log_8h_1a5096002e05063d13577205e0bc5f0564a2fd6f336d08340583bd620a7f5694c90" kindref="member">ERROR</ref>,<sp/></highlight><highlight class="stringliteral">&quot;Unable<sp/>to<sp/>returns<sp/>the<sp/>device<sp/>solver&apos;s<sp/>scalar<sp/>flux<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="808"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;array<sp/>since<sp/>it<sp/>has<sp/>not<sp/>yet<sp/>been<sp/>allocated<sp/>in<sp/>memory&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="809"><highlight class="normal"></highlight></codeline>
<codeline lineno="810"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Copy<sp/>the<sp/>scalar<sp/>flux<sp/>for<sp/>all<sp/>FSRs<sp/>from<sp/>the<sp/>device<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="811"><highlight class="normal"><sp/><sp/><sp/><sp/>FP_PRECISION*<sp/>fsr_scalar_fluxes<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/>FP_PRECISION[<ref refid="classSolver_1a2e17e8aa8a11d4300e89179984ca4347" kindref="member">_num_FSRs</ref><sp/>*<sp/><ref refid="classSolver_1ab18db0ed64afb0dade6054a7a08ae3c4" kindref="member">_num_groups</ref>];</highlight></codeline>
<codeline lineno="812"><highlight class="normal"><sp/><sp/><sp/><sp/>cudaMemcpy((</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*)fsr_scalar_fluxes,<sp/>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*)<ref refid="classSolver_1a60df3fd1a13667c294b1519d59a00b87" kindref="member">_scalar_flux</ref>,</highlight></codeline>
<codeline lineno="813"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classSolver_1a2e17e8aa8a11d4300e89179984ca4347" kindref="member">_num_FSRs</ref><sp/>*<sp/><ref refid="classSolver_1ab18db0ed64afb0dade6054a7a08ae3c4" kindref="member">_num_groups</ref><sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(FP_PRECISION),</highlight></codeline>
<codeline lineno="814"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaMemcpyDeviceToHost);</highlight></codeline>
<codeline lineno="815"><highlight class="normal"></highlight></codeline>
<codeline lineno="816"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>fsr_scalar_fluxes;</highlight></codeline>
<codeline lineno="817"><highlight class="normal">}</highlight></codeline>
<codeline lineno="818"><highlight class="normal"></highlight></codeline>
<codeline lineno="819"><highlight class="normal"></highlight></codeline>
<codeline lineno="825"><highlight class="normal">FP_PRECISION*<sp/><ref refid="classGPUSolver_1a063ab8d6110e315b214ec4d7ddc6225f" kindref="member" tooltip="Returns an array indexed by flat source region IDs with the corresponding flat source region power...">GPUSolver::getFSRPowers</ref>()<sp/>{</highlight></codeline>
<codeline lineno="826"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="classSolver_1ac6de9ad9091dae955848d83a91b0f3b5" kindref="member">_FSRs_to_powers</ref><sp/>==<sp/>NULL)</highlight></codeline>
<codeline lineno="827"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>log_printf(<ref refid="log_8h_1a5096002e05063d13577205e0bc5f0564a2fd6f336d08340583bd620a7f5694c90" kindref="member">ERROR</ref>,<sp/></highlight><highlight class="stringliteral">&quot;Unable<sp/>to<sp/>returns<sp/>the<sp/>device<sp/>solver&apos;s<sp/>FSR<sp/>power<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="828"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;array<sp/>since<sp/>it<sp/>has<sp/>not<sp/>yet<sp/>been<sp/>allocated<sp/>in<sp/>memory&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="829"><highlight class="normal"></highlight></codeline>
<codeline lineno="830"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="classSolver_1ac6de9ad9091dae955848d83a91b0f3b5" kindref="member">_FSRs_to_powers</ref>;</highlight></codeline>
<codeline lineno="831"><highlight class="normal">}</highlight></codeline>
<codeline lineno="832"><highlight class="normal"></highlight></codeline>
<codeline lineno="833"><highlight class="normal"></highlight></codeline>
<codeline lineno="839"><highlight class="normal">FP_PRECISION*<sp/><ref refid="classGPUSolver_1a112682552df45606ffc40f1afe35417d" kindref="member" tooltip="Return an array indexed by flat source region IDs with the corresponding pin cell power...">GPUSolver::getFSRPinPowers</ref>()<sp/>{</highlight></codeline>
<codeline lineno="840"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="classSolver_1a2ae997684ddbc16e2c8575cb6dcad788" kindref="member">_FSRs_to_pin_powers</ref><sp/>==<sp/>NULL)</highlight></codeline>
<codeline lineno="841"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>log_printf(<ref refid="log_8h_1a5096002e05063d13577205e0bc5f0564a2fd6f336d08340583bd620a7f5694c90" kindref="member">ERROR</ref>,<sp/></highlight><highlight class="stringliteral">&quot;Unable<sp/>to<sp/>returns<sp/>the<sp/>device<sp/>solver&apos;s<sp/>FSR<sp/>pin<sp/>power<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="842"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;array<sp/>since<sp/>it<sp/>has<sp/>not<sp/>yet<sp/>been<sp/>allocated<sp/>in<sp/>memory&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="843"><highlight class="normal"></highlight></codeline>
<codeline lineno="844"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="classSolver_1a2ae997684ddbc16e2c8575cb6dcad788" kindref="member">_FSRs_to_pin_powers</ref>;</highlight></codeline>
<codeline lineno="845"><highlight class="normal">}</highlight></codeline>
<codeline lineno="846"><highlight class="normal"></highlight></codeline>
<codeline lineno="847"><highlight class="normal"></highlight></codeline>
<codeline lineno="852"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>GPUSolver::setNumThreadBlocks(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>num_blocks)<sp/>{</highlight></codeline>
<codeline lineno="853"><highlight class="normal"></highlight></codeline>
<codeline lineno="854"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(num_blocks<sp/>&lt;<sp/>0)</highlight></codeline>
<codeline lineno="855"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>log_printf(<ref refid="log_8h_1a5096002e05063d13577205e0bc5f0564a2fd6f336d08340583bd620a7f5694c90" kindref="member">ERROR</ref>,<sp/></highlight><highlight class="stringliteral">&quot;Unable<sp/>to<sp/>set<sp/>the<sp/>number<sp/>of<sp/>threadblocks<sp/>to<sp/>%d<sp/>since<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="856"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;it<sp/>is<sp/>a<sp/>negative<sp/>number&quot;</highlight><highlight class="normal">,<sp/>num_blocks);</highlight></codeline>
<codeline lineno="857"><highlight class="normal"></highlight></codeline>
<codeline lineno="858"><highlight class="normal"><sp/><sp/><sp/><sp/>_B<sp/>=<sp/>num_blocks;</highlight></codeline>
<codeline lineno="859"><highlight class="normal">}</highlight></codeline>
<codeline lineno="860"><highlight class="normal"></highlight></codeline>
<codeline lineno="861"><highlight class="normal"></highlight></codeline>
<codeline lineno="866"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>GPUSolver::setNumThreadsPerBlock(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>num_threads)<sp/>{</highlight></codeline>
<codeline lineno="867"><highlight class="normal"></highlight></codeline>
<codeline lineno="868"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(num_threads<sp/>&lt;<sp/>0)</highlight></codeline>
<codeline lineno="869"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>log_printf(<ref refid="log_8h_1a5096002e05063d13577205e0bc5f0564a2fd6f336d08340583bd620a7f5694c90" kindref="member">ERROR</ref>,<sp/></highlight><highlight class="stringliteral">&quot;Unable<sp/>to<sp/>set<sp/>the<sp/>number<sp/>of<sp/>threads<sp/>per<sp/>block<sp/>to<sp/>%d<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="870"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;since<sp/>it<sp/>is<sp/>a<sp/>negative<sp/>number&quot;</highlight><highlight class="normal">,<sp/>num_threads);</highlight></codeline>
<codeline lineno="871"><highlight class="normal"></highlight></codeline>
<codeline lineno="872"><highlight class="normal"><sp/><sp/><sp/><sp/>_T<sp/>=<sp/>num_threads;</highlight></codeline>
<codeline lineno="873"><highlight class="normal">}</highlight></codeline>
<codeline lineno="874"><highlight class="normal"></highlight></codeline>
<codeline lineno="875"><highlight class="normal"></highlight></codeline>
<codeline lineno="882"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="classGPUSolver_1a6e6d50acc405f83a15bd24e2bc908e1d" kindref="member" tooltip="Sets the geometry for the solver.">GPUSolver::setGeometry</ref>(<ref refid="classGeometry" kindref="compound" tooltip="The master class containing references to all geometry-related objects (surfaces, cells...">Geometry</ref>*<sp/>geometry)<sp/>{</highlight></codeline>
<codeline lineno="883"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classGPUSolver_1a6e6d50acc405f83a15bd24e2bc908e1d" kindref="member" tooltip="Sets the geometry for the solver.">Solver::setGeometry</ref>(geometry);</highlight></codeline>
<codeline lineno="884"><highlight class="normal"><sp/><sp/><sp/><sp/>initializeMaterials();</highlight></codeline>
<codeline lineno="885"><highlight class="normal"></highlight></codeline>
<codeline lineno="886"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Copy<sp/>the<sp/>number<sp/>of<sp/>energy<sp/>groups<sp/>to<sp/>constant<sp/>memory<sp/>on<sp/>the<sp/>GPU<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="887"><highlight class="normal"><sp/><sp/><sp/><sp/>cudaMemcpyToSymbol(num_groups,<sp/>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*)&amp;<ref refid="classSolver_1ab18db0ed64afb0dade6054a7a08ae3c4" kindref="member">_num_groups</ref>,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">),<sp/>0,</highlight></codeline>
<codeline lineno="888"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaMemcpyHostToDevice);</highlight></codeline>
<codeline lineno="889"><highlight class="normal">}</highlight></codeline>
<codeline lineno="890"><highlight class="normal"></highlight></codeline>
<codeline lineno="891"><highlight class="normal"></highlight></codeline>
<codeline lineno="898"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="classGPUSolver_1ab0298357c57685b183c772b6abaa88e8" kindref="member" tooltip="Sets the track generator with characteristic tracks for the solver.">GPUSolver::setTrackGenerator</ref>(<ref refid="classTrackGenerator" kindref="compound" tooltip="The track generator is dedicated to generating tracks which cyclically wrap across the geometry...">TrackGenerator</ref>*<sp/>track_generator)<sp/>{</highlight></codeline>
<codeline lineno="899"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classGPUSolver_1ab0298357c57685b183c772b6abaa88e8" kindref="member" tooltip="Sets the track generator with characteristic tracks for the solver.">Solver::setTrackGenerator</ref>(track_generator);</highlight></codeline>
<codeline lineno="900"><highlight class="normal"><sp/><sp/><sp/><sp/>initializeTracks();</highlight></codeline>
<codeline lineno="901"><highlight class="normal">}</highlight></codeline>
<codeline lineno="902"><highlight class="normal"></highlight></codeline>
<codeline lineno="903"><highlight class="normal"></highlight></codeline>
<codeline lineno="907"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>GPUSolver::initializePolarQuadrature()<sp/>{</highlight></codeline>
<codeline lineno="908"><highlight class="normal"></highlight></codeline>
<codeline lineno="909"><highlight class="normal"><sp/><sp/><sp/><sp/>log_printf(<ref refid="log_8h_1a5096002e05063d13577205e0bc5f0564a748005382152808a72b1a9177d9dc806" kindref="member">INFO</ref>,<sp/></highlight><highlight class="stringliteral">&quot;Initializing<sp/>polar<sp/>quadrature<sp/>on<sp/>the<sp/>GPU...&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="910"><highlight class="normal"></highlight></codeline>
<codeline lineno="911"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Deletes<sp/>the<sp/>old<sp/>quadrature<sp/>if<sp/>one<sp/>existed<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="912"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="classSolver_1a4cf19c17278e367f44c6e735e437103d" kindref="member">_quad</ref><sp/>!=<sp/>NULL)</highlight></codeline>
<codeline lineno="913"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">delete</highlight><highlight class="normal"><sp/><ref refid="classSolver_1a4cf19c17278e367f44c6e735e437103d" kindref="member">_quad</ref>;</highlight></codeline>
<codeline lineno="914"><highlight class="normal"></highlight></codeline>
<codeline lineno="915"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classSolver_1a4cf19c17278e367f44c6e735e437103d" kindref="member">_quad</ref><sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/><ref refid="classQuadrature" kindref="compound" tooltip="Stores values for a variety of polar quadratures which may be used.">Quadrature</ref>(<ref refid="classSolver_1a3c8910d870254066e9ba89c75c3a1003" kindref="member">_quadrature_type</ref>,<sp/><ref refid="classSolver_1a49cc179a9f47c5ca5f6d19c954d680ad" kindref="member">_num_polar</ref>);</highlight></codeline>
<codeline lineno="916"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classSolver_1a84ce3dbf9e3c4a86773161e7c92b1da1" kindref="member">_polar_times_groups</ref><sp/>=<sp/><ref refid="classSolver_1ab18db0ed64afb0dade6054a7a08ae3c4" kindref="member">_num_groups</ref><sp/>*<sp/><ref refid="classSolver_1a49cc179a9f47c5ca5f6d19c954d680ad" kindref="member">_num_polar</ref>;</highlight></codeline>
<codeline lineno="917"><highlight class="normal"></highlight></codeline>
<codeline lineno="918"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Copy<sp/>the<sp/>number<sp/>of<sp/>polar<sp/>angles<sp/>to<sp/>constant<sp/>memory<sp/>on<sp/>the<sp/>GPU<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="919"><highlight class="normal"><sp/><sp/><sp/><sp/>cudaMemcpyToSymbol(num_polar,<sp/>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*)&amp;_num_polar,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">),<sp/>0,</highlight></codeline>
<codeline lineno="920"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaMemcpyHostToDevice);</highlight></codeline>
<codeline lineno="921"><highlight class="normal"></highlight></codeline>
<codeline lineno="922"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Copy<sp/>twice<sp/>the<sp/>number<sp/>of<sp/>polar<sp/>angles<sp/>to<sp/>constant<sp/>memory<sp/>on<sp/>the<sp/>GPU<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="923"><highlight class="normal"><sp/><sp/><sp/><sp/>cudaMemcpyToSymbol(two_times_num_polar,<sp/>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*)&amp;<ref refid="classSolver_1a5f9e45e5d2a93bc3b18ca2659b95ac6a" kindref="member">_two_times_num_polar</ref>,<sp/></highlight></codeline>
<codeline lineno="924"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">),<sp/>0,<sp/>cudaMemcpyHostToDevice);</highlight></codeline>
<codeline lineno="925"><highlight class="normal"></highlight></codeline>
<codeline lineno="926"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Copy<sp/>the<sp/>number<sp/>of<sp/>polar<sp/>angles<sp/>times<sp/>energy<sp/>groups<sp/>to<sp/>constant<sp/>memory<sp/></highlight></codeline>
<codeline lineno="927"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>on<sp/>the<sp/>GPU<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="928"><highlight class="normal"><sp/><sp/><sp/><sp/>cudaMemcpyToSymbol(polar_times_groups,<sp/>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*)&amp;<ref refid="classSolver_1a84ce3dbf9e3c4a86773161e7c92b1da1" kindref="member">_polar_times_groups</ref>,<sp/></highlight></codeline>
<codeline lineno="929"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">),<sp/>0,<sp/>cudaMemcpyHostToDevice);</highlight></codeline>
<codeline lineno="930"><highlight class="normal"></highlight></codeline>
<codeline lineno="931"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Compute<sp/>polar<sp/>times<sp/>azimuthal<sp/>angle<sp/>weights<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="932"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="classSolver_1a8407ebcfee31a54a67e6d5ca2e3d4e6b" kindref="member">_polar_weights</ref><sp/>!=<sp/>NULL)</highlight></codeline>
<codeline lineno="933"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">delete</highlight><highlight class="normal"><sp/>[]<sp/><ref refid="classSolver_1a8407ebcfee31a54a67e6d5ca2e3d4e6b" kindref="member">_polar_weights</ref>;</highlight></codeline>
<codeline lineno="934"><highlight class="normal"></highlight></codeline>
<codeline lineno="935"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classSolver_1a8407ebcfee31a54a67e6d5ca2e3d4e6b" kindref="member">_polar_weights</ref><sp/>=</highlight></codeline>
<codeline lineno="936"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(FP_PRECISION*)malloc(_num_polar<sp/>*<sp/><ref refid="classSolver_1a9f0fd3a842870803f27c47ed51a83039" kindref="member">_num_azim</ref><sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(FP_PRECISION));</highlight></codeline>
<codeline lineno="937"><highlight class="normal"></highlight></codeline>
<codeline lineno="938"><highlight class="normal"><sp/><sp/><sp/><sp/>FP_PRECISION*<sp/>multiples<sp/>=<sp/><ref refid="classSolver_1a4cf19c17278e367f44c6e735e437103d" kindref="member">_quad</ref>-&gt;<ref refid="classQuadrature_1abe4b4b49360a9fd5723e65fd35fb3ab9" kindref="member" tooltip="Returns a pointer to the quadrature&amp;#39;s multiples array.">getMultiples</ref>();</highlight></codeline>
<codeline lineno="939"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>azim_weights<sp/>=<sp/><ref refid="classSolver_1a7f7349dc153dd9e728697c922cf7c052" kindref="member">_track_generator</ref>-&gt;<ref refid="classTrackGenerator_1a1488db5d20339280b0e6fadf19a6d431" kindref="member" tooltip="Return a pointer to the array of azimuthal weights.">getAzimWeights</ref>();</highlight></codeline>
<codeline lineno="940"><highlight class="normal"></highlight></codeline>
<codeline lineno="941"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i=0;<sp/>i<sp/>&lt;<sp/><ref refid="classSolver_1a9f0fd3a842870803f27c47ed51a83039" kindref="member">_num_azim</ref>;<sp/>i++)<sp/>{</highlight></codeline>
<codeline lineno="942"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j=0;<sp/>j<sp/>&lt;<sp/><ref refid="classSolver_1a49cc179a9f47c5ca5f6d19c954d680ad" kindref="member">_num_polar</ref>;<sp/>j++)</highlight></codeline>
<codeline lineno="943"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classSolver_1a8407ebcfee31a54a67e6d5ca2e3d4e6b" kindref="member">_polar_weights</ref>[i*_num_polar+j]<sp/>=<sp/>azim_weights[i]*multiples[j]*<ref refid="GPUSolver_8h_1ac6b39b7a27b735f3a62be33f38041985" kindref="member">FOUR_PI</ref>;</highlight></codeline>
<codeline lineno="944"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="945"><highlight class="normal"></highlight></codeline>
<codeline lineno="946"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Copy<sp/>the<sp/>polar<sp/>weights<sp/>to<sp/>constant<sp/>memory<sp/>on<sp/>the<sp/>GPU<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="947"><highlight class="normal"><sp/><sp/><sp/><sp/>cudaMemcpyToSymbol(polar_weights,<sp/>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*)<ref refid="classSolver_1a8407ebcfee31a54a67e6d5ca2e3d4e6b" kindref="member">_polar_weights</ref>,</highlight></codeline>
<codeline lineno="948"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_num_polar<sp/>*<sp/>_num_azim<sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(FP_PRECISION),</highlight></codeline>
<codeline lineno="949"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>0,<sp/>cudaMemcpyHostToDevice);</highlight></codeline>
<codeline lineno="950"><highlight class="normal">}</highlight></codeline>
<codeline lineno="951"><highlight class="normal"></highlight></codeline>
<codeline lineno="952"><highlight class="normal"></highlight></codeline>
<codeline lineno="958"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>GPUSolver::initializePowerArrays()<sp/>{</highlight></codeline>
<codeline lineno="959"><highlight class="normal"></highlight></codeline>
<codeline lineno="960"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/>log_printf(<ref refid="log_8h_1a5096002e05063d13577205e0bc5f0564a748005382152808a72b1a9177d9dc806" kindref="member">INFO</ref>,<sp/></highlight><highlight class="stringliteral">&quot;Initializing<sp/>FSR<sp/>power<sp/>arrays<sp/>on<sp/>the<sp/>GPU...&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="961"><highlight class="normal"></highlight></codeline>
<codeline lineno="962"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Delete<sp/>old<sp/>power<sp/>arrays<sp/>if<sp/>they<sp/>exist<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="963"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="classSolver_1ac6de9ad9091dae955848d83a91b0f3b5" kindref="member">_FSRs_to_powers</ref><sp/>!=<sp/>NULL)</highlight></codeline>
<codeline lineno="964"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">delete</highlight><highlight class="normal"><sp/>[]<sp/><ref refid="classSolver_1ac6de9ad9091dae955848d83a91b0f3b5" kindref="member">_FSRs_to_powers</ref>;</highlight></codeline>
<codeline lineno="965"><highlight class="normal"></highlight></codeline>
<codeline lineno="966"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="classSolver_1a2ae997684ddbc16e2c8575cb6dcad788" kindref="member">_FSRs_to_pin_powers</ref><sp/>!=<sp/>NULL)</highlight></codeline>
<codeline lineno="967"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">delete</highlight><highlight class="normal"><sp/>[]<sp/><ref refid="classSolver_1a2ae997684ddbc16e2c8575cb6dcad788" kindref="member">_FSRs_to_pin_powers</ref>;</highlight></codeline>
<codeline lineno="968"><highlight class="normal"></highlight></codeline>
<codeline lineno="969"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Allocate<sp/>memory<sp/>for<sp/>FSR<sp/>power<sp/>and<sp/>pin<sp/>power<sp/>arrays<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="970"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">try</highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="971"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classSolver_1ac6de9ad9091dae955848d83a91b0f3b5" kindref="member">_FSRs_to_powers</ref><sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/>FP_PRECISION[<ref refid="classSolver_1a2e17e8aa8a11d4300e89179984ca4347" kindref="member">_num_FSRs</ref>];</highlight></codeline>
<codeline lineno="972"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classSolver_1a2ae997684ddbc16e2c8575cb6dcad788" kindref="member">_FSRs_to_pin_powers</ref><sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/>FP_PRECISION[<ref refid="classSolver_1a2e17e8aa8a11d4300e89179984ca4347" kindref="member">_num_FSRs</ref>];</highlight></codeline>
<codeline lineno="973"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="974"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">catch</highlight><highlight class="normal">(std::exception<sp/>&amp;e)<sp/>{</highlight></codeline>
<codeline lineno="975"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>log_printf(<ref refid="log_8h_1a5096002e05063d13577205e0bc5f0564a2fd6f336d08340583bd620a7f5694c90" kindref="member">ERROR</ref>,<sp/></highlight><highlight class="stringliteral">&quot;Could<sp/>not<sp/>allocate<sp/>memory<sp/>for<sp/>the<sp/>device<sp/>solver&apos;s<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="976"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;FSR<sp/>power<sp/>arrays.<sp/>Backtrace:%s&quot;</highlight><highlight class="normal">,<sp/>e.what());</highlight></codeline>
<codeline lineno="977"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="978"><highlight class="normal">}</highlight></codeline>
<codeline lineno="979"><highlight class="normal"></highlight></codeline>
<codeline lineno="980"><highlight class="normal"></highlight></codeline>
<codeline lineno="989"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>GPUSolver::initializeFSRs()<sp/>{</highlight></codeline>
<codeline lineno="990"><highlight class="normal"></highlight></codeline>
<codeline lineno="991"><highlight class="normal"><sp/><sp/><sp/><sp/>log_printf(<ref refid="log_8h_1a5096002e05063d13577205e0bc5f0564a748005382152808a72b1a9177d9dc806" kindref="member">INFO</ref>,<sp/></highlight><highlight class="stringliteral">&quot;Initializing<sp/>FSRs<sp/>on<sp/>the<sp/>GPU...&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="992"><highlight class="normal"></highlight></codeline>
<codeline lineno="993"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Delete<sp/>old<sp/>FSRs<sp/>array<sp/>if<sp/>it<sp/>exists<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="994"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="classSolver_1a84372339d7c2b5da3f07bc8b0822f42f" kindref="member">_FSR_volumes</ref><sp/>!=<sp/>NULL)</highlight></codeline>
<codeline lineno="995"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaFree(<ref refid="classSolver_1a84372339d7c2b5da3f07bc8b0822f42f" kindref="member">_FSR_volumes</ref>);</highlight></codeline>
<codeline lineno="996"><highlight class="normal"></highlight></codeline>
<codeline lineno="997"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(_FSR_materials<sp/>!=<sp/>NULL)</highlight></codeline>
<codeline lineno="998"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaFree(_FSR_materials);</highlight></codeline>
<codeline lineno="999"><highlight class="normal"></highlight></codeline>
<codeline lineno="1000"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Allocate<sp/>memory<sp/>for<sp/>all<sp/>tracks<sp/>and<sp/>track<sp/>offset<sp/>indices<sp/>on<sp/>the<sp/>device<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1001"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">try</highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="1002"><highlight class="normal"></highlight></codeline>
<codeline lineno="1003"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Allocate<sp/>memory<sp/>on<sp/>device<sp/>for<sp/>FSR<sp/>volumes<sp/>and<sp/>material<sp/>uids<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1004"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaMalloc((</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">**)&amp;<ref refid="classSolver_1a84372339d7c2b5da3f07bc8b0822f42f" kindref="member">_FSR_volumes</ref>,<sp/><ref refid="classSolver_1a2e17e8aa8a11d4300e89179984ca4347" kindref="member">_num_FSRs</ref><sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(FP_PRECISION));</highlight></codeline>
<codeline lineno="1005"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaMalloc((</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">**)&amp;_FSR_materials,<sp/><ref refid="classSolver_1a2e17e8aa8a11d4300e89179984ca4347" kindref="member">_num_FSRs</ref><sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">));</highlight></codeline>
<codeline lineno="1006"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1007"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Create<sp/>a<sp/>temporary<sp/>FSR<sp/>array<sp/>to<sp/>populate<sp/>and<sp/>then<sp/>copy<sp/>to<sp/>device<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1008"><highlight class="normal"><sp/><sp/><sp/><sp/>FP_PRECISION*<sp/>temp_FSR_volumes<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/>FP_PRECISION[<ref refid="classSolver_1a2e17e8aa8a11d4300e89179984ca4347" kindref="member">_num_FSRs</ref>];</highlight></codeline>
<codeline lineno="1009"><highlight class="normal"></highlight></codeline>
<codeline lineno="1010"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Get<sp/>the<sp/>array<sp/>indexed<sp/>by<sp/>FSR<sp/>IDs<sp/>with<sp/>material<sp/>ID<sp/>values<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1011"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal">*<sp/>FSRs_to_materials<sp/>=<sp/><ref refid="classSolver_1ae323198b6be6ddc402c53784c5a89b7f" kindref="member">_geometry</ref>-&gt;<ref refid="classGeometry_1a31555779a6ef4fb89a56ed7b775d2921" kindref="member" tooltip="Return an array indexed by flat source region IDs which contain the corresponding material IDs...">getFSRtoMaterialMap</ref>();</highlight></codeline>
<codeline lineno="1012"><highlight class="normal"></highlight></codeline>
<codeline lineno="1013"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Initialize<sp/>each<sp/>FSRs<sp/>volume<sp/>to<sp/>0<sp/>to<sp/>avoid<sp/>NaNs<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1014"><highlight class="normal"><sp/><sp/><sp/><sp/>memset(temp_FSR_volumes,<sp/>FP_PRECISION(0.),<sp/></highlight></codeline>
<codeline lineno="1015"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classSolver_1a2e17e8aa8a11d4300e89179984ca4347" kindref="member">_num_FSRs</ref>*</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(FP_PRECISION));</highlight></codeline>
<codeline lineno="1016"><highlight class="normal"></highlight></codeline>
<codeline lineno="1017"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classTrack" kindref="compound" tooltip="A track represents a characteristic line across the geometry.">Track</ref>*<sp/>track;</highlight></codeline>
<codeline lineno="1018"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>num_segments;</highlight></codeline>
<codeline lineno="1019"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsegment" kindref="compound" tooltip="A segment represents a line segment within a single flat source region along a track.">segment</ref>*<sp/>curr_segment;</highlight></codeline>
<codeline lineno="1020"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structsegment" kindref="compound" tooltip="A segment represents a line segment within a single flat source region along a track.">segment</ref>*<sp/>segments;</highlight></codeline>
<codeline lineno="1021"><highlight class="normal"><sp/><sp/><sp/><sp/>FP_PRECISION<sp/>volume;</highlight></codeline>
<codeline lineno="1022"><highlight class="normal"></highlight></codeline>
<codeline lineno="1023"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">double</highlight><highlight class="normal">*<sp/>azim_weights<sp/>=<sp/><ref refid="classSolver_1a7f7349dc153dd9e728697c922cf7c052" kindref="member">_track_generator</ref>-&gt;<ref refid="classTrackGenerator_1a1488db5d20339280b0e6fadf19a6d431" kindref="member" tooltip="Return a pointer to the array of azimuthal weights.">getAzimWeights</ref>();</highlight></codeline>
<codeline lineno="1024"><highlight class="normal"></highlight></codeline>
<codeline lineno="1025"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Set<sp/>each<sp/>FSR&apos;s<sp/>volume<sp/>by<sp/>accumulating<sp/>the<sp/>total<sp/>length<sp/>of<sp/>all</highlight></codeline>
<codeline lineno="1026"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tracks<sp/>inside<sp/>the<sp/>FSR.<sp/>Iterate<sp/>over<sp/>azimuthal<sp/>angle,<sp/>track,<sp/>segment*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1027"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i=0;<sp/>i<sp/>&lt;<sp/><ref refid="classSolver_1a9f0fd3a842870803f27c47ed51a83039" kindref="member">_num_azim</ref>;<sp/>i++)<sp/>{</highlight></codeline>
<codeline lineno="1028"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j=0;<sp/>j<sp/>&lt;<sp/><ref refid="classSolver_1a564e918dc20cdc12f40e15a86fffefc2" kindref="member">_num_tracks</ref>[i];<sp/>j++)<sp/>{</highlight></codeline>
<codeline lineno="1029"><highlight class="normal"></highlight></codeline>
<codeline lineno="1030"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>track<sp/>=<sp/>&amp;<ref refid="classSolver_1a7f7349dc153dd9e728697c922cf7c052" kindref="member">_track_generator</ref>-&gt;<ref refid="classTrackGenerator_1a293c6a25a694bfcb8187cfd679fa3639" kindref="member" tooltip="Returns a 2D jagged array of the tracks.">getTracks</ref>()[i][j];</highlight></codeline>
<codeline lineno="1031"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>num_segments<sp/>=<sp/>track-&gt;<ref refid="classTrack_1a034893295ac06eed35aac0c7ed172419" kindref="member" tooltip="Return the number of segments along this track.">getNumSegments</ref>();</highlight></codeline>
<codeline lineno="1032"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>segments<sp/>=<sp/>track-&gt;<ref refid="classTrack_1a796efa8dc12ef0f1073ba264f4074380" kindref="member" tooltip="Returns a vector of pointers to the track&amp;#39;s segments.">getSegments</ref>();</highlight></codeline>
<codeline lineno="1033"><highlight class="normal"></highlight></codeline>
<codeline lineno="1034"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Iterate<sp/>over<sp/>the<sp/>track&apos;s<sp/>segments<sp/>to<sp/>update<sp/>FSR<sp/>volumes<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1035"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>s<sp/>=<sp/>0;<sp/>s<sp/>&lt;<sp/>num_segments;<sp/>s++)<sp/>{</highlight></codeline>
<codeline lineno="1036"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>curr_segment<sp/>=<sp/>&amp;segments[s];</highlight></codeline>
<codeline lineno="1037"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>volume<sp/>=<sp/>curr_segment-&gt;<ref refid="structsegment_1a50c5a635c531d34ad3435ebcc3b6f593" kindref="member">_length</ref><sp/>*<sp/>azim_weights[i];</highlight></codeline>
<codeline lineno="1038"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>temp_FSR_volumes[curr_segment-&gt;<ref refid="structsegment_1ad4185c78e4df6c12a07392dfee367706" kindref="member">_region_id</ref>]<sp/>+=<sp/>volume;</highlight></codeline>
<codeline lineno="1039"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1040"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1041"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1042"><highlight class="normal"></highlight></codeline>
<codeline lineno="1043"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Copy<sp/>the<sp/>temporary<sp/>array<sp/>of<sp/>FSRs<sp/>to<sp/>the<sp/>device<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1044"><highlight class="normal"><sp/><sp/><sp/><sp/>cudaMemcpy((</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*)<ref refid="classSolver_1a84372339d7c2b5da3f07bc8b0822f42f" kindref="member">_FSR_volumes</ref>,<sp/>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*)temp_FSR_volumes,</highlight></codeline>
<codeline lineno="1045"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classSolver_1a2e17e8aa8a11d4300e89179984ca4347" kindref="member">_num_FSRs</ref><sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(FP_PRECISION),<sp/>cudaMemcpyHostToDevice);</highlight></codeline>
<codeline lineno="1046"><highlight class="normal"><sp/><sp/><sp/><sp/>cudaMemcpy((</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*)_FSR_materials,<sp/>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*)FSRs_to_materials,</highlight></codeline>
<codeline lineno="1047"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classSolver_1a2e17e8aa8a11d4300e89179984ca4347" kindref="member">_num_FSRs</ref><sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">),<sp/>cudaMemcpyHostToDevice);</highlight></codeline>
<codeline lineno="1048"><highlight class="normal"></highlight></codeline>
<codeline lineno="1049"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Copy<sp/>the<sp/>number<sp/>of<sp/>flat<sp/>source<sp/>regions<sp/>into<sp/>constant<sp/>memory<sp/>on<sp/></highlight></codeline>
<codeline lineno="1050"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>the<sp/>GPU<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1051"><highlight class="normal"><sp/><sp/><sp/><sp/>cudaMemcpyToSymbol(num_FSRs,<sp/>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*)&amp;<ref refid="classSolver_1a2e17e8aa8a11d4300e89179984ca4347" kindref="member">_num_FSRs</ref>,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">),<sp/>0,</highlight></codeline>
<codeline lineno="1052"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaMemcpyHostToDevice);</highlight></codeline>
<codeline lineno="1053"><highlight class="normal"></highlight></codeline>
<codeline lineno="1054"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Free<sp/>the<sp/>temporary<sp/>array<sp/>of<sp/>FSRs<sp/>on<sp/>the<sp/>host<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1055"><highlight class="normal"><sp/><sp/><sp/><sp/>free(temp_FSR_volumes);</highlight></codeline>
<codeline lineno="1056"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1057"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">catch</highlight><highlight class="normal">(std::exception<sp/>&amp;e)<sp/>{</highlight></codeline>
<codeline lineno="1058"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>log_printf(<ref refid="log_8h_1a5096002e05063d13577205e0bc5f0564a2fd6f336d08340583bd620a7f5694c90" kindref="member">ERROR</ref>,<sp/></highlight><highlight class="stringliteral">&quot;Could<sp/>not<sp/>allocate<sp/>memory<sp/>for<sp/>the<sp/>solver&apos;s<sp/>flat<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1059"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;source<sp/>regions<sp/>on<sp/>the<sp/>device.<sp/>Backtrace:%s&quot;</highlight><highlight class="normal">,<sp/>e.what());</highlight></codeline>
<codeline lineno="1060"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1061"><highlight class="normal"></highlight></codeline>
<codeline lineno="1062"><highlight class="normal"><sp/><sp/><sp/><sp/>initializeThrustVectors();</highlight></codeline>
<codeline lineno="1063"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1064"><highlight class="normal"></highlight></codeline>
<codeline lineno="1065"><highlight class="normal"></highlight></codeline>
<codeline lineno="1069"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>GPUSolver::initializeMaterials()<sp/>{</highlight></codeline>
<codeline lineno="1070"><highlight class="normal"></highlight></codeline>
<codeline lineno="1071"><highlight class="normal"><sp/><sp/><sp/><sp/>log_printf(<ref refid="log_8h_1a5096002e05063d13577205e0bc5f0564a748005382152808a72b1a9177d9dc806" kindref="member">INFO</ref>,<sp/></highlight><highlight class="stringliteral">&quot;Initializing<sp/>materials<sp/>on<sp/>the<sp/>GPU...&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="1072"><highlight class="normal"></highlight></codeline>
<codeline lineno="1073"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Delete<sp/>old<sp/>materials<sp/>array<sp/>if<sp/>it<sp/>exists<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1074"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(_materials<sp/>!=<sp/>NULL)</highlight></codeline>
<codeline lineno="1075"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaFree(_materials);</highlight></codeline>
<codeline lineno="1076"><highlight class="normal"></highlight></codeline>
<codeline lineno="1077"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Allocate<sp/>memory<sp/>for<sp/>all<sp/>tracks<sp/>and<sp/>track<sp/>offset<sp/>indices<sp/>on<sp/>the<sp/>device<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1078"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">try</highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="1079"><highlight class="normal"></highlight></codeline>
<codeline lineno="1080"><highlight class="normal"><sp/><sp/><sp/><sp/>std::map&lt;short<sp/>int,<sp/>Material*&gt;<sp/>host_materials=<ref refid="classSolver_1ae323198b6be6ddc402c53784c5a89b7f" kindref="member">_geometry</ref>-&gt;<ref refid="classGeometry_1a5f132e61ba7bbc3cda6b4a5beaa2a443" kindref="member">getMaterials</ref>();</highlight></codeline>
<codeline lineno="1081"><highlight class="normal"><sp/><sp/><sp/><sp/>std::map&lt;short<sp/>int,<sp/>Material*&gt;::iterator<sp/>iter;</highlight></codeline>
<codeline lineno="1082"><highlight class="normal"></highlight></codeline>
<codeline lineno="1083"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Iterate<sp/>through<sp/>all<sp/>materials<sp/>and<sp/>clone<sp/>them<sp/>on<sp/>the<sp/>device<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1084"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaMalloc((</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">**)&amp;_materials,<sp/><ref refid="classSolver_1a5b17e508bd721f49a382673efcd8ae1b" kindref="member">_num_materials</ref><sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="structdev__material" kindref="compound" tooltip="A material&amp;#39;s nuclear data to be stored on a GPU.">dev_material</ref>));</highlight></codeline>
<codeline lineno="1085"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(iter=host_materials.begin();<sp/>iter<sp/>!=<sp/>host_materials.end();<sp/>++iter)</highlight></codeline>
<codeline lineno="1086"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cloneMaterialOnGPU(iter-&gt;second,<sp/>&amp;_materials[iter-&gt;second-&gt;getUid()]);</highlight></codeline>
<codeline lineno="1087"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1088"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">catch</highlight><highlight class="normal">(std::exception<sp/>&amp;e)<sp/>{</highlight></codeline>
<codeline lineno="1089"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>log_printf(<ref refid="log_8h_1a5096002e05063d13577205e0bc5f0564a2fd6f336d08340583bd620a7f5694c90" kindref="member">ERROR</ref>,<sp/></highlight><highlight class="stringliteral">&quot;Could<sp/>not<sp/>allocate<sp/>memory<sp/>for<sp/>the<sp/>device<sp/>solver&apos;s<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1090"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;materials.<sp/>Backtrace:%s&quot;</highlight><highlight class="normal">,<sp/>e.what());</highlight></codeline>
<codeline lineno="1091"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1092"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1093"><highlight class="normal"></highlight></codeline>
<codeline lineno="1094"><highlight class="normal"></highlight></codeline>
<codeline lineno="1098"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>GPUSolver::initializeTracks()<sp/>{</highlight></codeline>
<codeline lineno="1099"><highlight class="normal"></highlight></codeline>
<codeline lineno="1100"><highlight class="normal"><sp/><sp/><sp/><sp/>log_printf(<ref refid="log_8h_1a5096002e05063d13577205e0bc5f0564a748005382152808a72b1a9177d9dc806" kindref="member">INFO</ref>,<sp/></highlight><highlight class="stringliteral">&quot;Initializing<sp/>tracks<sp/>on<sp/>the<sp/>GPU...&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="1101"><highlight class="normal"></highlight></codeline>
<codeline lineno="1102"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Delete<sp/>old<sp/>tracks<sp/>array<sp/>if<sp/>it<sp/>exists<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1103"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(_dev_tracks<sp/>!=<sp/>NULL)</highlight></codeline>
<codeline lineno="1104"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaFree(_dev_tracks);</highlight></codeline>
<codeline lineno="1105"><highlight class="normal"></highlight></codeline>
<codeline lineno="1106"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Allocate<sp/>memory<sp/>for<sp/>all<sp/>tracks<sp/>and<sp/>track<sp/>offset<sp/>indices<sp/>on<sp/>the<sp/>device<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1107"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">try</highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="1108"><highlight class="normal"></highlight></codeline>
<codeline lineno="1109"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Allocate<sp/>array<sp/>of<sp/>tracks<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1110"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaMalloc((</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">**)&amp;_dev_tracks,<sp/><ref refid="classSolver_1a817518832fb051823de9e8855319f02e" kindref="member">_tot_num_tracks</ref><sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(<ref refid="structdev__track" kindref="compound" tooltip="A dev_track represents a characteristic line across the geometry.">dev_track</ref>));</highlight></codeline>
<codeline lineno="1111"><highlight class="normal"></highlight></codeline>
<codeline lineno="1112"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Iterate<sp/>through<sp/>all<sp/>tracks<sp/>and<sp/>clone<sp/>them<sp/>on<sp/>the<sp/>device<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1113"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>index;</highlight></codeline>
<codeline lineno="1114"><highlight class="normal"></highlight></codeline>
<codeline lineno="1115"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i=0;<sp/>i<sp/>&lt;<sp/><ref refid="classSolver_1a817518832fb051823de9e8855319f02e" kindref="member">_tot_num_tracks</ref>;<sp/>i++)<sp/>{</highlight></codeline>
<codeline lineno="1116"><highlight class="normal"></highlight></codeline>
<codeline lineno="1117"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cloneTrackOnGPU(<ref refid="classSolver_1a775ed41fc1268312c8fb25ec994e1351" kindref="member">_tracks</ref>[i],<sp/>&amp;_dev_tracks[i]);</highlight></codeline>
<codeline lineno="1118"><highlight class="normal"></highlight></codeline>
<codeline lineno="1119"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Make<sp/>track<sp/>reflective<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1120"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>index<sp/>=<sp/>computeScalarTrackIndex(<ref refid="classSolver_1a775ed41fc1268312c8fb25ec994e1351" kindref="member">_tracks</ref>[i]-&gt;getTrackInI(),</highlight></codeline>
<codeline lineno="1121"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classSolver_1a775ed41fc1268312c8fb25ec994e1351" kindref="member">_tracks</ref>[i]-&gt;getTrackInJ());</highlight></codeline>
<codeline lineno="1122"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaMemcpy((</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*)&amp;_dev_tracks[i]._track_in,</highlight></codeline>
<codeline lineno="1123"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*)&amp;index,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">),<sp/>cudaMemcpyHostToDevice);</highlight></codeline>
<codeline lineno="1124"><highlight class="normal"></highlight></codeline>
<codeline lineno="1125"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>index<sp/>=<sp/>computeScalarTrackIndex(<ref refid="classSolver_1a775ed41fc1268312c8fb25ec994e1351" kindref="member">_tracks</ref>[i]-&gt;getTrackOutI(),</highlight></codeline>
<codeline lineno="1126"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classSolver_1a775ed41fc1268312c8fb25ec994e1351" kindref="member">_tracks</ref>[i]-&gt;getTrackOutJ());</highlight></codeline>
<codeline lineno="1127"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaMemcpy((</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*)&amp;_dev_tracks[i]._track_out,</highlight></codeline>
<codeline lineno="1128"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*)&amp;index,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">),<sp/>cudaMemcpyHostToDevice);</highlight></codeline>
<codeline lineno="1129"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1130"><highlight class="normal"></highlight></codeline>
<codeline lineno="1131"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Copy<sp/>the<sp/>array<sp/>of<sp/>number<sp/>of<sp/>tracks<sp/>for<sp/>each<sp/>azimuthal<sp/>angles<sp/>into<sp/></highlight></codeline>
<codeline lineno="1132"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>constant<sp/>memory<sp/>on<sp/>GPU<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1133"><highlight class="normal"><sp/><sp/><sp/><sp/>cudaMemcpyToSymbol(num_tracks,<sp/>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*)_num_tracks,<sp/></highlight></codeline>
<codeline lineno="1134"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_num_azim<sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">),<sp/>0,<sp/>cudaMemcpyHostToDevice);</highlight></codeline>
<codeline lineno="1135"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1136"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Copy<sp/>the<sp/>total<sp/>number<sp/>of<sp/>tracks<sp/>into<sp/>constant<sp/>memory<sp/>on<sp/>GPU<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1137"><highlight class="normal"><sp/><sp/><sp/><sp/>cudaMemcpyToSymbol(tot_num_tracks,<sp/>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*)&amp;_tot_num_tracks,</highlight></codeline>
<codeline lineno="1138"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">),<sp/>0,<sp/>cudaMemcpyHostToDevice);</highlight></codeline>
<codeline lineno="1139"><highlight class="normal"></highlight></codeline>
<codeline lineno="1140"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Copy<sp/>the<sp/>number<sp/>of<sp/>azimuthal<sp/>angles<sp/>into<sp/>constant<sp/>memory<sp/>on<sp/>GPU<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1141"><highlight class="normal"><sp/><sp/><sp/><sp/>cudaMemcpyToSymbol(num_azim,<sp/>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*)&amp;_num_azim,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">),<sp/>0,<sp/></highlight></codeline>
<codeline lineno="1142"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaMemcpyHostToDevice);</highlight></codeline>
<codeline lineno="1143"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1144"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Copy<sp/>the<sp/>array<sp/>of<sp/>number<sp/>of<sp/>tracks<sp/>for<sp/>each<sp/>azimuthal<sp/>angles<sp/>into<sp/></highlight></codeline>
<codeline lineno="1145"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>constant<sp/>memory<sp/>on<sp/>GPU<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1146"><highlight class="normal"><sp/><sp/><sp/><sp/>cudaMemcpyToSymbol(num_tracks,<sp/>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*)_num_tracks,<sp/></highlight></codeline>
<codeline lineno="1147"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_num_azim<sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">),<sp/>0,<sp/>cudaMemcpyHostToDevice);</highlight></codeline>
<codeline lineno="1148"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1149"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Copy<sp/>the<sp/>total<sp/>number<sp/>of<sp/>tracks<sp/>into<sp/>constant<sp/>memory<sp/>on<sp/>GPU<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1150"><highlight class="normal"><sp/><sp/><sp/><sp/>cudaMemcpyToSymbol(tot_num_tracks,<sp/>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*)&amp;_tot_num_tracks,</highlight></codeline>
<codeline lineno="1151"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">),<sp/>0,<sp/>cudaMemcpyHostToDevice);</highlight></codeline>
<codeline lineno="1152"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1153"><highlight class="normal"></highlight></codeline>
<codeline lineno="1154"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">catch</highlight><highlight class="normal">(std::exception<sp/>&amp;e)<sp/>{</highlight></codeline>
<codeline lineno="1155"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>log_printf(<ref refid="log_8h_1a5096002e05063d13577205e0bc5f0564a2fd6f336d08340583bd620a7f5694c90" kindref="member">ERROR</ref>,<sp/></highlight><highlight class="stringliteral">&quot;Could<sp/>not<sp/>allocate<sp/>memory<sp/>for<sp/>the<sp/>solver&apos;s<sp/>tracks<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1156"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;on<sp/>the<sp/>device.<sp/>Backtrace:%s&quot;</highlight><highlight class="normal">,<sp/>e.what());</highlight></codeline>
<codeline lineno="1157"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1158"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1159"><highlight class="normal"></highlight></codeline>
<codeline lineno="1160"><highlight class="normal"></highlight></codeline>
<codeline lineno="1167"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>GPUSolver::initializeFluxArrays()<sp/>{</highlight></codeline>
<codeline lineno="1168"><highlight class="normal"></highlight></codeline>
<codeline lineno="1169"><highlight class="normal"><sp/><sp/><sp/><sp/>log_printf(<ref refid="log_8h_1a5096002e05063d13577205e0bc5f0564a748005382152808a72b1a9177d9dc806" kindref="member">INFO</ref>,<sp/></highlight><highlight class="stringliteral">&quot;Initializing<sp/>flux<sp/>arrays<sp/>on<sp/>the<sp/>GPU...&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="1170"><highlight class="normal"></highlight></codeline>
<codeline lineno="1171"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Delete<sp/>old<sp/>flux<sp/>arrays<sp/>if<sp/>they<sp/>exist<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1172"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="classSolver_1adcfcfe1758affc74780907584fc7beaf" kindref="member">_boundary_flux</ref><sp/>!=<sp/>NULL)</highlight></codeline>
<codeline lineno="1173"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaFree(<ref refid="classSolver_1adcfcfe1758affc74780907584fc7beaf" kindref="member">_boundary_flux</ref>);</highlight></codeline>
<codeline lineno="1174"><highlight class="normal"></highlight></codeline>
<codeline lineno="1175"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="classSolver_1a60df3fd1a13667c294b1519d59a00b87" kindref="member">_scalar_flux</ref><sp/>!=<sp/>NULL)</highlight></codeline>
<codeline lineno="1176"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaFree(<ref refid="classSolver_1a60df3fd1a13667c294b1519d59a00b87" kindref="member">_scalar_flux</ref>);</highlight></codeline>
<codeline lineno="1177"><highlight class="normal"></highlight></codeline>
<codeline lineno="1178"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Allocate<sp/>memory<sp/>for<sp/>all<sp/>flux<sp/>arrays<sp/>on<sp/>the<sp/>device<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1179"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">try</highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="1180"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaMalloc((</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">**)&amp;<ref refid="classSolver_1adcfcfe1758affc74780907584fc7beaf" kindref="member">_boundary_flux</ref>,</highlight></codeline>
<codeline lineno="1181"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>2*_tot_num_tracks<sp/>*<sp/><ref refid="classSolver_1a84ce3dbf9e3c4a86773161e7c92b1da1" kindref="member">_polar_times_groups</ref>*</highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(FP_PRECISION));</highlight></codeline>
<codeline lineno="1182"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaMalloc((</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">**)&amp;<ref refid="classSolver_1a60df3fd1a13667c294b1519d59a00b87" kindref="member">_scalar_flux</ref>,<sp/></highlight></codeline>
<codeline lineno="1183"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classSolver_1a2e17e8aa8a11d4300e89179984ca4347" kindref="member">_num_FSRs</ref><sp/>*<sp/><ref refid="classSolver_1ab18db0ed64afb0dade6054a7a08ae3c4" kindref="member">_num_groups</ref><sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(FP_PRECISION));</highlight></codeline>
<codeline lineno="1184"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1185"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">catch</highlight><highlight class="normal">(std::exception<sp/>&amp;e)<sp/>{</highlight></codeline>
<codeline lineno="1186"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>log_printf(<ref refid="log_8h_1a5096002e05063d13577205e0bc5f0564a2fd6f336d08340583bd620a7f5694c90" kindref="member">ERROR</ref>,<sp/></highlight><highlight class="stringliteral">&quot;Could<sp/>not<sp/>allocate<sp/>memory<sp/>for<sp/>the<sp/>solver&apos;s<sp/>fluxes<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1187"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;on<sp/>the<sp/>device.<sp/>Backtrace:%s&quot;</highlight><highlight class="normal">,<sp/>e.what());</highlight></codeline>
<codeline lineno="1188"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1189"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1190"><highlight class="normal"></highlight></codeline>
<codeline lineno="1191"><highlight class="normal"></highlight></codeline>
<codeline lineno="1197"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>GPUSolver::initializeSourceArrays()<sp/>{</highlight></codeline>
<codeline lineno="1198"><highlight class="normal"></highlight></codeline>
<codeline lineno="1199"><highlight class="normal"><sp/><sp/><sp/><sp/>log_printf(<ref refid="log_8h_1a5096002e05063d13577205e0bc5f0564a748005382152808a72b1a9177d9dc806" kindref="member">INFO</ref>,<sp/></highlight><highlight class="stringliteral">&quot;Initializing<sp/>source<sp/>arrays<sp/>on<sp/>the<sp/>GPU...&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="1200"><highlight class="normal"></highlight></codeline>
<codeline lineno="1201"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Delete<sp/>old<sp/>sources<sp/>arrays<sp/>if<sp/>they<sp/>exist<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1202"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="classSolver_1a935ab1926ea3d625d0c549c5f8595c07" kindref="member">_source</ref><sp/>!=<sp/>NULL)</highlight></codeline>
<codeline lineno="1203"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaFree(<ref refid="classSolver_1a935ab1926ea3d625d0c549c5f8595c07" kindref="member">_source</ref>);</highlight></codeline>
<codeline lineno="1204"><highlight class="normal"></highlight></codeline>
<codeline lineno="1205"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="classSolver_1ad7d3233142b6798f9aea7330b221754c" kindref="member">_old_source</ref><sp/>!=<sp/>NULL)</highlight></codeline>
<codeline lineno="1206"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaFree(<ref refid="classSolver_1ad7d3233142b6798f9aea7330b221754c" kindref="member">_old_source</ref>);</highlight></codeline>
<codeline lineno="1207"><highlight class="normal"></highlight></codeline>
<codeline lineno="1208"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="classSolver_1aff69bb3f354f5c598e1117e2a3515f1b" kindref="member">_reduced_source</ref><sp/>!=<sp/>NULL)</highlight></codeline>
<codeline lineno="1209"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaFree(<ref refid="classSolver_1aff69bb3f354f5c598e1117e2a3515f1b" kindref="member">_reduced_source</ref>);</highlight></codeline>
<codeline lineno="1210"><highlight class="normal"></highlight></codeline>
<codeline lineno="1211"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Allocate<sp/>memory<sp/>for<sp/>all<sp/>source<sp/>arrays<sp/>on<sp/>the<sp/>device<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1212"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">try</highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="1213"><highlight class="normal"></highlight></codeline>
<codeline lineno="1214"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaMalloc((</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">**)&amp;<ref refid="classSolver_1a935ab1926ea3d625d0c549c5f8595c07" kindref="member">_source</ref>,<sp/></highlight></codeline>
<codeline lineno="1215"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classSolver_1a2e17e8aa8a11d4300e89179984ca4347" kindref="member">_num_FSRs</ref><sp/>*<sp/><ref refid="classSolver_1ab18db0ed64afb0dade6054a7a08ae3c4" kindref="member">_num_groups</ref><sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(FP_PRECISION));</highlight></codeline>
<codeline lineno="1216"><highlight class="normal"></highlight></codeline>
<codeline lineno="1217"><highlight class="normal"><sp/><sp/><sp/><sp/>cudaMalloc((</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">**)&amp;<ref refid="classSolver_1ad7d3233142b6798f9aea7330b221754c" kindref="member">_old_source</ref>,</highlight></codeline>
<codeline lineno="1218"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classSolver_1a2e17e8aa8a11d4300e89179984ca4347" kindref="member">_num_FSRs</ref><sp/>*<sp/><ref refid="classSolver_1ab18db0ed64afb0dade6054a7a08ae3c4" kindref="member">_num_groups</ref><sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(FP_PRECISION));</highlight></codeline>
<codeline lineno="1219"><highlight class="normal"></highlight></codeline>
<codeline lineno="1220"><highlight class="normal"><sp/><sp/><sp/><sp/>cudaMalloc((</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">**)&amp;<ref refid="classSolver_1aff69bb3f354f5c598e1117e2a3515f1b" kindref="member">_reduced_source</ref>,</highlight></codeline>
<codeline lineno="1221"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classSolver_1a2e17e8aa8a11d4300e89179984ca4347" kindref="member">_num_FSRs</ref><sp/>*<sp/><ref refid="classSolver_1ab18db0ed64afb0dade6054a7a08ae3c4" kindref="member">_num_groups</ref><sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(FP_PRECISION));</highlight></codeline>
<codeline lineno="1222"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1223"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">catch</highlight><highlight class="normal">(std::exception<sp/>&amp;e)<sp/>{</highlight></codeline>
<codeline lineno="1224"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>log_printf(<ref refid="log_8h_1a5096002e05063d13577205e0bc5f0564a2fd6f336d08340583bd620a7f5694c90" kindref="member">ERROR</ref>,<sp/></highlight><highlight class="stringliteral">&quot;Could<sp/>not<sp/>allocate<sp/>memory<sp/>for<sp/>the<sp/>solver&apos;s<sp/>flat<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1225"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;source<sp/>region<sp/>sources<sp/>array<sp/>on<sp/>the<sp/>device.<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1226"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;Backtrace:%s&quot;</highlight><highlight class="normal">,<sp/>e.what());</highlight></codeline>
<codeline lineno="1227"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1228"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1229"><highlight class="normal"></highlight></codeline>
<codeline lineno="1230"><highlight class="normal"></highlight></codeline>
<codeline lineno="1235"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>GPUSolver::initializeThrustVectors()<sp/>{</highlight></codeline>
<codeline lineno="1236"><highlight class="normal"></highlight></codeline>
<codeline lineno="1237"><highlight class="normal"><sp/><sp/><sp/><sp/>log_printf(<ref refid="log_8h_1a5096002e05063d13577205e0bc5f0564a748005382152808a72b1a9177d9dc806" kindref="member">INFO</ref>,<sp/></highlight><highlight class="stringliteral">&quot;Initializing<sp/>thrust<sp/>vectors<sp/>on<sp/>the<sp/>GPU...&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="1238"><highlight class="normal"></highlight></codeline>
<codeline lineno="1239"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Delete<sp/>old<sp/>vectors<sp/>if<sp/>they<sp/>exist<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1240"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="classSolver_1a63b1f8d78d02dc5a0f2dc392597cc5af" kindref="member">_fission_sources</ref><sp/>!=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="1241"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classSolver_1a63b1f8d78d02dc5a0f2dc392597cc5af" kindref="member">_fission_sources</ref><sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1242"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_fission_sources_vec.clear();</highlight></codeline>
<codeline lineno="1243"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1244"><highlight class="normal"></highlight></codeline>
<codeline lineno="1245"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(_tot_absorption<sp/>!=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="1246"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_tot_absorption<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1247"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_tot_absorption_vec.clear();</highlight></codeline>
<codeline lineno="1248"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1249"><highlight class="normal"></highlight></codeline>
<codeline lineno="1250"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(_tot_fission<sp/>!=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="1251"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_tot_fission<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1252"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_tot_fission_vec.clear();</highlight></codeline>
<codeline lineno="1253"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1254"><highlight class="normal"></highlight></codeline>
<codeline lineno="1255"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(<ref refid="classSolver_1af2285a2a6361ea1d351e3b8c55858c92" kindref="member">_source_residuals</ref><sp/>!=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="1256"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classSolver_1af2285a2a6361ea1d351e3b8c55858c92" kindref="member">_source_residuals</ref><sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1257"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_source_residuals_vec.clear();</highlight></codeline>
<codeline lineno="1258"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1259"><highlight class="normal"></highlight></codeline>
<codeline lineno="1260"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(_leakage<sp/>!=<sp/>NULL)<sp/>{</highlight></codeline>
<codeline lineno="1261"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_leakage<sp/>=<sp/>NULL;</highlight></codeline>
<codeline lineno="1262"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_leakage_vec.clear();</highlight></codeline>
<codeline lineno="1263"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1264"><highlight class="normal"></highlight></codeline>
<codeline lineno="1265"><highlight class="normal"></highlight></codeline>
<codeline lineno="1266"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Allocate<sp/>memory<sp/>for<sp/>fission,<sp/>absorption<sp/>and<sp/>source<sp/>vectors<sp/>on<sp/>device<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1267"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">try</highlight><highlight class="normal">{</highlight></codeline>
<codeline lineno="1268"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Allocate<sp/>fission<sp/>source<sp/>array<sp/>on<sp/>device<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1269"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_fission_sources_vec.resize(_B<sp/>*<sp/>_T);</highlight></codeline>
<codeline lineno="1270"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classSolver_1a63b1f8d78d02dc5a0f2dc392597cc5af" kindref="member">_fission_sources</ref><sp/>=<sp/>thrust::raw_pointer_cast(&amp;_fission_sources_vec[0]);</highlight></codeline>
<codeline lineno="1271"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1272"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Allocate<sp/>total<sp/>absorption<sp/>reaction<sp/>rate<sp/>array<sp/>on<sp/>device<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1273"><highlight class="normal"><sp/><sp/><sp/><sp/>_tot_absorption_vec.resize(_B<sp/>*<sp/>_T);</highlight></codeline>
<codeline lineno="1274"><highlight class="normal"><sp/><sp/><sp/><sp/>_tot_absorption<sp/>=<sp/>thrust::raw_pointer_cast(&amp;_tot_absorption_vec[0]);</highlight></codeline>
<codeline lineno="1275"><highlight class="normal"></highlight></codeline>
<codeline lineno="1276"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Allocate<sp/>fission<sp/>reaction<sp/>rate<sp/>array<sp/>on<sp/>device<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1277"><highlight class="normal"><sp/><sp/><sp/><sp/>_tot_fission_vec.resize(_B<sp/>*<sp/>_T);</highlight></codeline>
<codeline lineno="1278"><highlight class="normal"><sp/><sp/><sp/><sp/>_tot_fission<sp/>=<sp/>thrust::raw_pointer_cast(&amp;_tot_fission_vec[0]);</highlight></codeline>
<codeline lineno="1279"><highlight class="normal"></highlight></codeline>
<codeline lineno="1280"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Allocate<sp/>source<sp/>residual<sp/>array<sp/>on<sp/>device<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1281"><highlight class="normal"><sp/><sp/><sp/><sp/>_source_residuals_vec.resize(_B<sp/>*<sp/>_T);</highlight></codeline>
<codeline lineno="1282"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classSolver_1af2285a2a6361ea1d351e3b8c55858c92" kindref="member">_source_residuals</ref><sp/>=<sp/>thrust::raw_pointer_cast(&amp;_source_residuals_vec[0]);</highlight></codeline>
<codeline lineno="1283"><highlight class="normal"></highlight></codeline>
<codeline lineno="1284"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Allocate<sp/>leakage<sp/>array<sp/>on<sp/>device<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1285"><highlight class="normal"><sp/><sp/><sp/><sp/>_leakage_vec.resize(_B<sp/>*<sp/>_T);</highlight></codeline>
<codeline lineno="1286"><highlight class="normal"><sp/><sp/><sp/><sp/>_leakage<sp/>=<sp/>thrust::raw_pointer_cast(&amp;_leakage_vec[0]);</highlight></codeline>
<codeline lineno="1287"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1288"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">catch</highlight><highlight class="normal">(std::exception<sp/>&amp;e)<sp/>{</highlight></codeline>
<codeline lineno="1289"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>log_printf(<ref refid="log_8h_1a5096002e05063d13577205e0bc5f0564a2fd6f336d08340583bd620a7f5694c90" kindref="member">ERROR</ref>,<sp/></highlight><highlight class="stringliteral">&quot;Could<sp/>not<sp/>allocate<sp/>memory<sp/>for<sp/>the<sp/>solver&apos;s<sp/>&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1290"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;Thrust<sp/>vectors.Backtrace:%s&quot;</highlight><highlight class="normal">,<sp/>e.what());</highlight></codeline>
<codeline lineno="1291"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1292"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1293"><highlight class="normal"></highlight></codeline>
<codeline lineno="1294"><highlight class="normal"></highlight></codeline>
<codeline lineno="1304"><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>GPUSolver::computeScalarTrackIndex(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>j)<sp/>{</highlight></codeline>
<codeline lineno="1305"><highlight class="normal"></highlight></codeline>
<codeline lineno="1306"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>index<sp/>=0;</highlight></codeline>
<codeline lineno="1307"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>p<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="1308"><highlight class="normal"></highlight></codeline>
<codeline lineno="1309"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Iterate<sp/>over<sp/>each<sp/>azimuthal<sp/>angle<sp/>and<sp/>increment<sp/>index<sp/>by<sp/>the<sp/>number<sp/>of</highlight></codeline>
<codeline lineno="1310"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tracks<sp/>at<sp/>each<sp/>angle<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1311"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(p<sp/>&lt;<sp/>i)<sp/>{</highlight></codeline>
<codeline lineno="1312"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>index<sp/>+=<sp/>_num_tracks[p];</highlight></codeline>
<codeline lineno="1313"><highlight class="normal"><sp/><sp/><sp/><sp/>p++;</highlight></codeline>
<codeline lineno="1314"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1315"><highlight class="normal"></highlight></codeline>
<codeline lineno="1316"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Update<sp/>index<sp/>for<sp/>this<sp/>track<sp/>since<sp/>it<sp/>is<sp/>the<sp/>jth<sp/>track<sp/>at<sp/>angle<sp/>i<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1317"><highlight class="normal"><sp/><sp/><sp/><sp/>index<sp/>+=<sp/>j;</highlight></codeline>
<codeline lineno="1318"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1319"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>index;</highlight></codeline>
<codeline lineno="1320"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1321"><highlight class="normal"></highlight></codeline>
<codeline lineno="1322"><highlight class="normal"></highlight></codeline>
<codeline lineno="1329"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>GPUSolver::precomputePrefactors(){</highlight></codeline>
<codeline lineno="1330"><highlight class="normal"></highlight></codeline>
<codeline lineno="1331"><highlight class="normal"><sp/><sp/><sp/><sp/>log_printf(<ref refid="log_8h_1a5096002e05063d13577205e0bc5f0564a748005382152808a72b1a9177d9dc806" kindref="member">INFO</ref>,<sp/></highlight><highlight class="stringliteral">&quot;Building<sp/>exponential<sp/>prefactor<sp/>hashtable<sp/>on<sp/>device...&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="1332"><highlight class="normal"></highlight></codeline>
<codeline lineno="1333"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Copy<sp/>a<sp/>boolean<sp/>indicating<sp/>whether<sp/>or<sp/>not<sp/>to<sp/>use<sp/>the<sp/>linear<sp/>interpolation</highlight></codeline>
<codeline lineno="1334"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>table<sp/>or<sp/>the<sp/>exp<sp/>intrinsic<sp/>function<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1335"><highlight class="normal"><sp/><sp/><sp/><sp/>cudaMemcpyToSymbol(interpolate_exponential,<sp/></highlight></codeline>
<codeline lineno="1336"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*)&amp;<ref refid="classSolver_1a1263a3948d7fe87874854460a3701d82" kindref="member">_interpolate_exponential</ref>,<sp/></highlight></codeline>
<codeline lineno="1337"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">bool</highlight><highlight class="normal">),<sp/>0,<sp/>cudaMemcpyHostToDevice);</highlight></codeline>
<codeline lineno="1338"><highlight class="normal"></highlight></codeline>
<codeline lineno="1339"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Copy<sp/>the<sp/>sines<sp/>of<sp/>the<sp/>polar<sp/>angles<sp/>which<sp/>is<sp/>needed<sp/>if<sp/>the<sp/>user</highlight></codeline>
<codeline lineno="1340"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>requested<sp/>the<sp/>use<sp/>of<sp/>the<sp/>exp<sp/>intrinsic<sp/>to<sp/>evaluate<sp/>exponentials<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1341"><highlight class="normal"><sp/><sp/><sp/><sp/>cudaMemcpyToSymbol(sinthetas,<sp/>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*)<ref refid="classSolver_1a4cf19c17278e367f44c6e735e437103d" kindref="member">_quad</ref>-&gt;<ref refid="classQuadrature_1a678dfcec6a74deeff5369c42ba7748aa" kindref="member" tooltip="Returns a pointer to the quadrature&amp;#39;s sintheta array.">getSinThetas</ref>(),</highlight></codeline>
<codeline lineno="1342"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_num_polar<sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(FP_PRECISION),<sp/>0,<sp/></highlight></codeline>
<codeline lineno="1343"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaMemcpyHostToDevice);</highlight></codeline>
<codeline lineno="1344"><highlight class="normal"></highlight></codeline>
<codeline lineno="1345"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Set<sp/>size<sp/>of<sp/>prefactor<sp/>array<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1346"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>num_array_values<sp/>=<sp/>10<sp/>*<sp/>sqrt(1.<sp/>/<sp/>(8.<sp/>*<sp/><ref refid="classSolver_1a4aa4d18f980bbb098f839835e5e2f35d" kindref="member">_source_convergence_thresh</ref>));</highlight></codeline>
<codeline lineno="1347"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classSolver_1a354a2964b53e89ffb03d256eaccdeb47" kindref="member">_prefactor_spacing</ref><sp/>=<sp/>10.<sp/>/<sp/>num_array_values;</highlight></codeline>
<codeline lineno="1348"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classSolver_1a4ed58ea28163beec97a5efe1c1874c02" kindref="member">_inverse_prefactor_spacing</ref><sp/>=<sp/>1.0<sp/>/<sp/><ref refid="classSolver_1a354a2964b53e89ffb03d256eaccdeb47" kindref="member">_prefactor_spacing</ref>;</highlight></codeline>
<codeline lineno="1349"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classSolver_1a43ee296db0a4d4cc695be82fea2e2ee5" kindref="member">_prefactor_array_size</ref><sp/>=<sp/><ref refid="classSolver_1a5f9e45e5d2a93bc3b18ca2659b95ac6a" kindref="member">_two_times_num_polar</ref><sp/>*<sp/>num_array_values;</highlight></codeline>
<codeline lineno="1350"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classSolver_1a1a18b47465922034d8669238fedbe176" kindref="member">_prefactor_max_index</ref><sp/>=<sp/><ref refid="classSolver_1a43ee296db0a4d4cc695be82fea2e2ee5" kindref="member">_prefactor_array_size</ref><sp/>-<sp/><ref refid="classSolver_1a5f9e45e5d2a93bc3b18ca2659b95ac6a" kindref="member">_two_times_num_polar</ref><sp/>-<sp/>1;</highlight></codeline>
<codeline lineno="1351"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1352"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>allocate<sp/>arrays<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1353"><highlight class="normal"><sp/><sp/><sp/><sp/>FP_PRECISION*<sp/>prefactor_array<sp/>=<sp/></highlight><highlight class="keyword">new</highlight><highlight class="normal"><sp/>FP_PRECISION[<ref refid="classSolver_1a43ee296db0a4d4cc695be82fea2e2ee5" kindref="member">_prefactor_array_size</ref>];</highlight></codeline>
<codeline lineno="1354"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1355"><highlight class="normal"><sp/><sp/><sp/><sp/>FP_PRECISION<sp/>expon;</highlight></codeline>
<codeline lineno="1356"><highlight class="normal"><sp/><sp/><sp/><sp/>FP_PRECISION<sp/>intercept;</highlight></codeline>
<codeline lineno="1357"><highlight class="normal"><sp/><sp/><sp/><sp/>FP_PRECISION<sp/>slope;</highlight></codeline>
<codeline lineno="1358"><highlight class="normal"></highlight></codeline>
<codeline lineno="1359"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Create<sp/>prefactor<sp/>array<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1360"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>num_array_values;<sp/>i<sp/>++){</highlight></codeline>
<codeline lineno="1361"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>p<sp/>=<sp/>0;<sp/>p<sp/>&lt;<sp/><ref refid="classSolver_1a49cc179a9f47c5ca5f6d19c954d680ad" kindref="member">_num_polar</ref>;<sp/>p++){</highlight></codeline>
<codeline lineno="1362"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>expon<sp/>=<sp/>exp(-<sp/>(i<sp/>*<sp/><ref refid="classSolver_1a354a2964b53e89ffb03d256eaccdeb47" kindref="member">_prefactor_spacing</ref>)<sp/>/<sp/><ref refid="classSolver_1a4cf19c17278e367f44c6e735e437103d" kindref="member">_quad</ref>-&gt;<ref refid="classQuadrature_1a891c96ac4127b45461832bd72cbaf364" kindref="member" tooltip="Returns the  value for a particular polar angle.">getSinTheta</ref>(p));</highlight></codeline>
<codeline lineno="1363"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>slope<sp/>=<sp/>-<sp/>expon<sp/>/<sp/><ref refid="classSolver_1a4cf19c17278e367f44c6e735e437103d" kindref="member">_quad</ref>-&gt;<ref refid="classQuadrature_1a891c96ac4127b45461832bd72cbaf364" kindref="member" tooltip="Returns the  value for a particular polar angle.">getSinTheta</ref>(p);</highlight></codeline>
<codeline lineno="1364"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>intercept<sp/>=<sp/>expon<sp/>*<sp/>(1<sp/>+<sp/>(i<sp/>*<sp/><ref refid="classSolver_1a354a2964b53e89ffb03d256eaccdeb47" kindref="member">_prefactor_spacing</ref>)<sp/>/</highlight></codeline>
<codeline lineno="1365"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classSolver_1a4cf19c17278e367f44c6e735e437103d" kindref="member">_quad</ref>-&gt;<ref refid="classQuadrature_1a891c96ac4127b45461832bd72cbaf364" kindref="member" tooltip="Returns the  value for a particular polar angle.">getSinTheta</ref>(p));</highlight></codeline>
<codeline lineno="1366"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>prefactor_array[_two_times_num_polar<sp/>*<sp/>i<sp/>+<sp/>2<sp/>*<sp/>p]<sp/>=<sp/>slope;</highlight></codeline>
<codeline lineno="1367"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>prefactor_array[_two_times_num_polar<sp/>*<sp/>i<sp/>+<sp/>2<sp/>*<sp/>p<sp/>+<sp/>1]<sp/>=<sp/>intercept;</highlight></codeline>
<codeline lineno="1368"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1369"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="1370"><highlight class="normal"></highlight></codeline>
<codeline lineno="1371"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Allocate<sp/>memory<sp/>for<sp/>the<sp/>prefactor<sp/>array<sp/>on<sp/>the<sp/>device<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1372"><highlight class="normal"><sp/><sp/><sp/><sp/>cudaMalloc((</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">**)&amp;_prefactor_array,<sp/></highlight></codeline>
<codeline lineno="1373"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classSolver_1a43ee296db0a4d4cc695be82fea2e2ee5" kindref="member">_prefactor_array_size</ref><sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(FP_PRECISION));</highlight></codeline>
<codeline lineno="1374"><highlight class="normal"></highlight></codeline>
<codeline lineno="1375"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Copy<sp/>prefactor<sp/>array<sp/>to<sp/>the<sp/>device<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1376"><highlight class="normal"><sp/><sp/><sp/><sp/>cudaMemcpy((</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*)_prefactor_array,<sp/>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*)prefactor_array,<sp/></highlight></codeline>
<codeline lineno="1377"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classSolver_1a43ee296db0a4d4cc695be82fea2e2ee5" kindref="member">_prefactor_array_size</ref><sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(FP_PRECISION),</highlight></codeline>
<codeline lineno="1378"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudaMemcpyHostToDevice);</highlight></codeline>
<codeline lineno="1379"><highlight class="normal"></highlight></codeline>
<codeline lineno="1380"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Copy<sp/>prefactor<sp/>array<sp/>size<sp/>and<sp/>spacing<sp/>to<sp/>constant<sp/>memory<sp/>on<sp/>the<sp/>device<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1381"><highlight class="normal"><sp/><sp/><sp/><sp/>cudaMemcpyToSymbol(prefactor_spacing,<sp/>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*)&amp;<ref refid="classSolver_1a354a2964b53e89ffb03d256eaccdeb47" kindref="member">_prefactor_spacing</ref>,<sp/></highlight></codeline>
<codeline lineno="1382"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(FP_PRECISION),<sp/>0,<sp/>cudaMemcpyHostToDevice);</highlight></codeline>
<codeline lineno="1383"><highlight class="normal"></highlight></codeline>
<codeline lineno="1384"><highlight class="normal"><sp/><sp/><sp/><sp/>cudaMemcpyToSymbol(inverse_prefactor_spacing,<sp/></highlight></codeline>
<codeline lineno="1385"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*)&amp;<ref refid="classSolver_1a4ed58ea28163beec97a5efe1c1874c02" kindref="member">_inverse_prefactor_spacing</ref>,<sp/></highlight></codeline>
<codeline lineno="1386"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(FP_PRECISION),<sp/>0,<sp/>cudaMemcpyHostToDevice);</highlight></codeline>
<codeline lineno="1387"><highlight class="normal"></highlight></codeline>
<codeline lineno="1388"><highlight class="normal"><sp/><sp/><sp/><sp/>cudaMemcpyToSymbol(prefactor_max_index,<sp/>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*)&amp;<ref refid="classSolver_1a1a18b47465922034d8669238fedbe176" kindref="member">_prefactor_max_index</ref>,</highlight></codeline>
<codeline lineno="1389"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">),<sp/>0,<sp/>cudaMemcpyHostToDevice);</highlight></codeline>
<codeline lineno="1390"><highlight class="normal"></highlight></codeline>
<codeline lineno="1391"><highlight class="normal"><sp/><sp/><sp/><sp/>free(prefactor_array);</highlight></codeline>
<codeline lineno="1392"><highlight class="normal"></highlight></codeline>
<codeline lineno="1393"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="1394"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1395"><highlight class="normal"></highlight></codeline>
<codeline lineno="1396"><highlight class="normal"></highlight></codeline>
<codeline lineno="1401"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>GPUSolver::zeroTrackFluxes()<sp/>{</highlight></codeline>
<codeline lineno="1402"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>size<sp/>=<sp/>2<sp/>*<sp/>_tot_num_tracks<sp/>*<sp/>_num_polar<sp/>*<sp/><ref refid="classSolver_1ab18db0ed64afb0dade6054a7a08ae3c4" kindref="member">_num_groups</ref>;</highlight></codeline>
<codeline lineno="1403"><highlight class="normal"><sp/><sp/><sp/><sp/>size<sp/>*=<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(FP_PRECISION);</highlight></codeline>
<codeline lineno="1404"><highlight class="normal"><sp/><sp/><sp/><sp/>cudaMemset(<ref refid="classSolver_1adcfcfe1758affc74780907584fc7beaf" kindref="member">_boundary_flux</ref>,<sp/>0.0,<sp/>size);</highlight></codeline>
<codeline lineno="1405"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="1406"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1407"><highlight class="normal"></highlight></codeline>
<codeline lineno="1408"><highlight class="normal"></highlight></codeline>
<codeline lineno="1414"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>GPUSolver::flattenFSRFluxes(FP_PRECISION<sp/>value)<sp/>{</highlight></codeline>
<codeline lineno="1415"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>size<sp/>=<sp/><ref refid="classSolver_1a2e17e8aa8a11d4300e89179984ca4347" kindref="member">_num_FSRs</ref><sp/>*<sp/><ref refid="classSolver_1ab18db0ed64afb0dade6054a7a08ae3c4" kindref="member">_num_groups</ref><sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(FP_PRECISION);</highlight></codeline>
<codeline lineno="1416"><highlight class="normal"><sp/><sp/><sp/><sp/>cudaMemset(<ref refid="classSolver_1a60df3fd1a13667c294b1519d59a00b87" kindref="member">_scalar_flux</ref>,<sp/>value,<sp/>size);</highlight></codeline>
<codeline lineno="1417"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="1418"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1419"><highlight class="normal"></highlight></codeline>
<codeline lineno="1420"><highlight class="normal"></highlight></codeline>
<codeline lineno="1426"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>GPUSolver::flattenFSRSources(FP_PRECISION<sp/>value)<sp/>{</highlight></codeline>
<codeline lineno="1427"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>size<sp/>=<sp/><ref refid="classSolver_1a2e17e8aa8a11d4300e89179984ca4347" kindref="member">_num_FSRs</ref><sp/>*<sp/><ref refid="classSolver_1ab18db0ed64afb0dade6054a7a08ae3c4" kindref="member">_num_groups</ref><sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(FP_PRECISION);</highlight></codeline>
<codeline lineno="1428"><highlight class="normal"><sp/><sp/><sp/><sp/>cudaMemset(<ref refid="classSolver_1a935ab1926ea3d625d0c549c5f8595c07" kindref="member">_source</ref>,<sp/>value,<sp/>size);</highlight></codeline>
<codeline lineno="1429"><highlight class="normal"><sp/><sp/><sp/><sp/>cudaMemset(<ref refid="classSolver_1ad7d3233142b6798f9aea7330b221754c" kindref="member">_old_source</ref>,<sp/>value,<sp/>size);</highlight></codeline>
<codeline lineno="1430"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="1431"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1432"><highlight class="normal"></highlight></codeline>
<codeline lineno="1433"><highlight class="normal"></highlight></codeline>
<codeline lineno="1438"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>GPUSolver::normalizeFluxes()<sp/>{</highlight></codeline>
<codeline lineno="1439"><highlight class="normal"></highlight></codeline>
<codeline lineno="1440"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>shared_mem<sp/>=<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(FP_PRECISION)<sp/>*<sp/>_T;</highlight></codeline>
<codeline lineno="1441"><highlight class="normal"></highlight></codeline>
<codeline lineno="1442"><highlight class="normal"><sp/><sp/><sp/><sp/>computeFissionSourcesOnDevice&lt;&lt;&lt;_B,<sp/>_T,<sp/>shared_mem&gt;&gt;&gt;(<ref refid="classSolver_1a84372339d7c2b5da3f07bc8b0822f42f" kindref="member">_FSR_volumes</ref>,<sp/></highlight></codeline>
<codeline lineno="1443"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_FSR_materials,</highlight></codeline>
<codeline lineno="1444"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_materials,<sp/></highlight></codeline>
<codeline lineno="1445"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classSolver_1a60df3fd1a13667c294b1519d59a00b87" kindref="member">_scalar_flux</ref>,<sp/></highlight></codeline>
<codeline lineno="1446"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classSolver_1a63b1f8d78d02dc5a0f2dc392597cc5af" kindref="member">_fission_sources</ref>);</highlight></codeline>
<codeline lineno="1447"><highlight class="normal"></highlight></codeline>
<codeline lineno="1448"><highlight class="normal"><sp/><sp/><sp/><sp/>FP_PRECISION<sp/>norm_factor<sp/>=<sp/>1.0<sp/>/<sp/>thrust::reduce(_fission_sources_vec.begin(),</highlight></codeline>
<codeline lineno="1449"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_fission_sources_vec.end());</highlight></codeline>
<codeline lineno="1450"><highlight class="normal"></highlight></codeline>
<codeline lineno="1451"><highlight class="normal"><sp/><sp/><sp/><sp/>normalizeFluxesOnDevice&lt;&lt;&lt;_B,<sp/>_T&gt;&gt;&gt;(<ref refid="classSolver_1a60df3fd1a13667c294b1519d59a00b87" kindref="member">_scalar_flux</ref>,<sp/><ref refid="classSolver_1adcfcfe1758affc74780907584fc7beaf" kindref="member">_boundary_flux</ref>,<sp/></highlight></codeline>
<codeline lineno="1452"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>norm_factor);</highlight></codeline>
<codeline lineno="1453"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1454"><highlight class="normal"></highlight></codeline>
<codeline lineno="1455"><highlight class="normal"></highlight></codeline>
<codeline lineno="1456"><highlight class="normal">FP_PRECISION<sp/>GPUSolver::computeFSRSources()<sp/>{</highlight></codeline>
<codeline lineno="1457"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1458"><highlight class="normal"><sp/><sp/><sp/><sp/>computeFSRSourcesOnDevice&lt;&lt;&lt;_B,<sp/>_T&gt;&gt;&gt;(_FSR_materials,<sp/>_materials,<sp/></highlight></codeline>
<codeline lineno="1459"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classSolver_1a60df3fd1a13667c294b1519d59a00b87" kindref="member">_scalar_flux</ref>,<sp/><ref refid="classSolver_1a935ab1926ea3d625d0c549c5f8595c07" kindref="member">_source</ref>,<sp/></highlight></codeline>
<codeline lineno="1460"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classSolver_1ad7d3233142b6798f9aea7330b221754c" kindref="member">_old_source</ref>,<sp/><ref refid="classSolver_1aff69bb3f354f5c598e1117e2a3515f1b" kindref="member">_reduced_source</ref>,</highlight></codeline>
<codeline lineno="1461"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>1.0<sp/>/<sp/><ref refid="classSolver_1a3c52f5e2ecbe44ebca20e6696a09e447" kindref="member">_k_eff</ref>,<sp/><ref refid="classSolver_1af2285a2a6361ea1d351e3b8c55858c92" kindref="member">_source_residuals</ref>);</highlight></codeline>
<codeline lineno="1462"><highlight class="normal"></highlight></codeline>
<codeline lineno="1463"><highlight class="normal"><sp/><sp/><sp/><sp/>FP_PRECISION<sp/>residual<sp/>=<sp/>thrust::reduce(_source_residuals_vec.begin(),<sp/></highlight></codeline>
<codeline lineno="1464"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_source_residuals_vec.end());</highlight></codeline>
<codeline lineno="1465"><highlight class="normal"><sp/><sp/><sp/><sp/>residual<sp/>=<sp/>sqrt(residual<sp/>/<sp/><ref refid="classSolver_1a2e17e8aa8a11d4300e89179984ca4347" kindref="member">_num_FSRs</ref>);</highlight></codeline>
<codeline lineno="1466"><highlight class="normal"></highlight></codeline>
<codeline lineno="1467"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>residual;</highlight></codeline>
<codeline lineno="1468"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1469"><highlight class="normal"></highlight></codeline>
<codeline lineno="1470"><highlight class="normal"></highlight></codeline>
<codeline lineno="1471"><highlight class="normal"></highlight></codeline>
<codeline lineno="1472"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>GPUSolver::transportSweep()<sp/>{</highlight></codeline>
<codeline lineno="1473"><highlight class="normal"></highlight></codeline>
<codeline lineno="1474"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>shared_mem<sp/>=<sp/>_T<sp/>*<sp/>_two_times_num_polar<sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(FP_PRECISION);</highlight></codeline>
<codeline lineno="1475"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>tid_offset,<sp/>tid_max;</highlight></codeline>
<codeline lineno="1476"><highlight class="normal"></highlight></codeline>
<codeline lineno="1477"><highlight class="normal"><sp/><sp/><sp/><sp/>log_printf(<ref refid="log_8h_1a5096002e05063d13577205e0bc5f0564a0593585da9181e972974c1274d8f2b4f" kindref="member">DEBUG</ref>,<sp/></highlight><highlight class="stringliteral">&quot;Transport<sp/>sweep<sp/>on<sp/>device<sp/>with<sp/>%d<sp/>blocks&quot;</highlight><highlight class="normal"><sp/></highlight></codeline>
<codeline lineno="1478"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;<sp/>and<sp/>%d<sp/>threads&quot;</highlight><highlight class="normal">,<sp/>_B,<sp/>_T);</highlight></codeline>
<codeline lineno="1479"><highlight class="normal"></highlight></codeline>
<codeline lineno="1480"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Initialize<sp/>leakage<sp/>to<sp/>zero<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1481"><highlight class="normal"><sp/><sp/><sp/><sp/>thrust::fill(_leakage_vec.begin(),<sp/>_leakage_vec.end(),<sp/>0.0);</highlight></codeline>
<codeline lineno="1482"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1483"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Initialize<sp/>flux<sp/>in<sp/>each<sp/>region<sp/>to<sp/>zero<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1484"><highlight class="normal"><sp/><sp/><sp/><sp/>flattenFSRFluxes(0.0);</highlight></codeline>
<codeline lineno="1485"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline lineno="1486"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Sweep<sp/>the<sp/>first<sp/>halfspace<sp/>of<sp/>azimuthal<sp/>angle<sp/>space<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1487"><highlight class="normal"><sp/><sp/><sp/><sp/>tid_offset<sp/>=<sp/>0;</highlight></codeline>
<codeline lineno="1488"><highlight class="normal"><sp/><sp/><sp/><sp/>tid_max<sp/>=<sp/>(_tot_num_tracks<sp/>/<sp/>2);</highlight></codeline>
<codeline lineno="1489"><highlight class="normal"></highlight></codeline>
<codeline lineno="1490"><highlight class="normal"><sp/><sp/><sp/><sp/>transportSweepOnDevice&lt;&lt;&lt;_B,<sp/>_T,<sp/>shared_mem&gt;&gt;&gt;(<ref refid="classSolver_1a60df3fd1a13667c294b1519d59a00b87" kindref="member">_scalar_flux</ref>,<sp/></highlight></codeline>
<codeline lineno="1491"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classSolver_1adcfcfe1758affc74780907584fc7beaf" kindref="member">_boundary_flux</ref>,</highlight></codeline>
<codeline lineno="1492"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classSolver_1aff69bb3f354f5c598e1117e2a3515f1b" kindref="member">_reduced_source</ref>,<sp/>_leakage,</highlight></codeline>
<codeline lineno="1493"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_materials,<sp/>_dev_tracks,</highlight></codeline>
<codeline lineno="1494"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classSolver_1a64ce3d9a61c55fa470b91b68497dd9d6" kindref="member">_prefactor_array</ref>,<sp/></highlight></codeline>
<codeline lineno="1495"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tid_offset,<sp/>tid_max);</highlight></codeline>
<codeline lineno="1496"><highlight class="normal"></highlight></codeline>
<codeline lineno="1497"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Sweep<sp/>the<sp/>second<sp/>halfspace<sp/>of<sp/>azimuthal<sp/>angle<sp/>space<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1498"><highlight class="normal"><sp/><sp/><sp/><sp/>tid_offset<sp/>=<sp/>tid_max<sp/>*<sp/><ref refid="classSolver_1ab18db0ed64afb0dade6054a7a08ae3c4" kindref="member">_num_groups</ref>;</highlight></codeline>
<codeline lineno="1499"><highlight class="normal"><sp/><sp/><sp/><sp/>tid_max<sp/>=<sp/><ref refid="classSolver_1a817518832fb051823de9e8855319f02e" kindref="member">_tot_num_tracks</ref>;</highlight></codeline>
<codeline lineno="1500"><highlight class="normal"></highlight></codeline>
<codeline lineno="1501"><highlight class="normal"><sp/><sp/><sp/><sp/>transportSweepOnDevice&lt;&lt;&lt;_B,<sp/>_T,<sp/>shared_mem&gt;&gt;&gt;(<ref refid="classSolver_1a60df3fd1a13667c294b1519d59a00b87" kindref="member">_scalar_flux</ref>,</highlight></codeline>
<codeline lineno="1502"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classSolver_1adcfcfe1758affc74780907584fc7beaf" kindref="member">_boundary_flux</ref>,</highlight></codeline>
<codeline lineno="1503"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classSolver_1aff69bb3f354f5c598e1117e2a3515f1b" kindref="member">_reduced_source</ref>,<sp/>_leakage,</highlight></codeline>
<codeline lineno="1504"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_materials,<sp/>_dev_tracks,</highlight></codeline>
<codeline lineno="1505"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classSolver_1a64ce3d9a61c55fa470b91b68497dd9d6" kindref="member">_prefactor_array</ref>,</highlight></codeline>
<codeline lineno="1506"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tid_offset,<sp/>tid_max);</highlight></codeline>
<codeline lineno="1507"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1508"><highlight class="normal"></highlight></codeline>
<codeline lineno="1509"><highlight class="normal"></highlight></codeline>
<codeline lineno="1514"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>GPUSolver::addSourceToScalarFlux()<sp/>{</highlight></codeline>
<codeline lineno="1515"><highlight class="normal"></highlight></codeline>
<codeline lineno="1516"><highlight class="normal"><sp/><sp/><sp/><sp/>addSourceToScalarFluxOnDevice&lt;&lt;&lt;_B,_T&gt;&gt;&gt;(<ref refid="classSolver_1a60df3fd1a13667c294b1519d59a00b87" kindref="member">_scalar_flux</ref>,<sp/><ref refid="classSolver_1aff69bb3f354f5c598e1117e2a3515f1b" kindref="member">_reduced_source</ref>,</highlight></codeline>
<codeline lineno="1517"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="classSolver_1a84372339d7c2b5da3f07bc8b0822f42f" kindref="member">_FSR_volumes</ref>,<sp/>_FSR_materials,</highlight></codeline>
<codeline lineno="1518"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_materials);</highlight></codeline>
<codeline lineno="1519"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1520"><highlight class="normal"></highlight></codeline>
<codeline lineno="1521"><highlight class="normal"></highlight></codeline>
<codeline lineno="1530"><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>GPUSolver::computeKeff()<sp/>{</highlight></codeline>
<codeline lineno="1531"><highlight class="normal"></highlight></codeline>
<codeline lineno="1532"><highlight class="normal"><sp/><sp/><sp/><sp/>FP_PRECISION<sp/>tot_absorption;</highlight></codeline>
<codeline lineno="1533"><highlight class="normal"><sp/><sp/><sp/><sp/>FP_PRECISION<sp/>tot_fission;</highlight></codeline>
<codeline lineno="1534"><highlight class="normal"><sp/><sp/><sp/><sp/>FP_PRECISION<sp/>tot_leakage;</highlight></codeline>
<codeline lineno="1535"><highlight class="normal"></highlight></codeline>
<codeline lineno="1536"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Compute<sp/>the<sp/>total<sp/>fission<sp/>and<sp/>absorption<sp/>rates<sp/>on<sp/>the<sp/>device.</highlight></codeline>
<codeline lineno="1537"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>This<sp/>kernel<sp/>stores<sp/>partial<sp/>rates<sp/>in<sp/>a<sp/>Thrust<sp/>vector<sp/>with<sp/>as<sp/>many</highlight></codeline>
<codeline lineno="1538"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>entries<sp/>as<sp/>GPU<sp/>threads<sp/>executed<sp/>by<sp/>the<sp/>kernel<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1539"><highlight class="normal"><sp/><sp/><sp/><sp/>computeFissionAndAbsorption&lt;&lt;&lt;_B,<sp/>_T&gt;&gt;&gt;(<ref refid="classSolver_1a84372339d7c2b5da3f07bc8b0822f42f" kindref="member">_FSR_volumes</ref>,<sp/>_FSR_materials,</highlight></codeline>
<codeline lineno="1540"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_materials,<sp/><ref refid="classSolver_1a60df3fd1a13667c294b1519d59a00b87" kindref="member">_scalar_flux</ref>,</highlight></codeline>
<codeline lineno="1541"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_tot_absorption,<sp/>_tot_fission);</highlight></codeline>
<codeline lineno="1542"><highlight class="normal"></highlight></codeline>
<codeline lineno="1543"><highlight class="normal"><sp/><sp/><sp/><sp/>cudaDeviceSynchronize();</highlight></codeline>
<codeline lineno="1544"><highlight class="normal"></highlight></codeline>
<codeline lineno="1545"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Compute<sp/>the<sp/>total<sp/>absorption<sp/>rate<sp/>by<sp/>reducing<sp/>the<sp/>partial<sp/>absorption</highlight></codeline>
<codeline lineno="1546"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>rates<sp/>compiled<sp/>in<sp/>the<sp/>Thrust<sp/>vector<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1547"><highlight class="normal"><sp/><sp/><sp/><sp/>tot_absorption<sp/>=<sp/>thrust::reduce(_tot_absorption_vec.begin(),</highlight></codeline>
<codeline lineno="1548"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_tot_absorption_vec.end());</highlight></codeline>
<codeline lineno="1549"><highlight class="normal"></highlight></codeline>
<codeline lineno="1550"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Compute<sp/>the<sp/>total<sp/>fission<sp/>rate<sp/>by<sp/>reducing<sp/>the<sp/>partial<sp/>fission</highlight></codeline>
<codeline lineno="1551"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>rates<sp/>compiled<sp/>in<sp/>the<sp/>Thrust<sp/>vector<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1552"><highlight class="normal"><sp/><sp/><sp/><sp/>tot_fission<sp/>=<sp/>thrust::reduce(_tot_fission_vec.begin(),</highlight></codeline>
<codeline lineno="1553"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_tot_fission_vec.end());</highlight></codeline>
<codeline lineno="1554"><highlight class="normal"></highlight></codeline>
<codeline lineno="1555"><highlight class="normal"><sp/><sp/><sp/><sp/>cudaMemcpy((</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*)&amp;tot_fission,<sp/>(</highlight><highlight class="keywordtype">void</highlight><highlight class="normal">*)_tot_fission,<sp/></highlight></codeline>
<codeline lineno="1556"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_B<sp/>*<sp/>_T<sp/>*<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(FP_PRECISION),<sp/>cudaMemcpyHostToDevice);</highlight></codeline>
<codeline lineno="1557"><highlight class="normal"></highlight></codeline>
<codeline lineno="1558"><highlight class="normal"></highlight></codeline>
<codeline lineno="1559"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Compute<sp/>the<sp/>total<sp/>leakage<sp/>by<sp/>reducing<sp/>the<sp/>partial<sp/>leakage</highlight></codeline>
<codeline lineno="1560"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/>*<sp/>rates<sp/>compiled<sp/>in<sp/>the<sp/>Thrust<sp/>vector<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1561"><highlight class="normal"><sp/><sp/><sp/><sp/>tot_leakage<sp/>=<sp/>0.5<sp/>*<sp/>thrust::reduce(_leakage_vec.begin(),</highlight></codeline>
<codeline lineno="1562"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>_leakage_vec.end());</highlight></codeline>
<codeline lineno="1563"><highlight class="normal"></highlight></codeline>
<codeline lineno="1564"><highlight class="normal"></highlight></codeline>
<codeline lineno="1565"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Compute<sp/>the<sp/>new<sp/>keff<sp/>from<sp/>the<sp/>fission<sp/>and<sp/>absorption<sp/>rates<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="1566"><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classSolver_1a3c52f5e2ecbe44ebca20e6696a09e447" kindref="member">_k_eff</ref><sp/>=<sp/>tot_fission<sp/>/<sp/>(tot_absorption<sp/>+<sp/>tot_leakage);</highlight></codeline>
<codeline lineno="1567"><highlight class="normal"></highlight></codeline>
<codeline lineno="1568"><highlight class="normal"><sp/><sp/><sp/><sp/>log_printf(<ref refid="log_8h_1a5096002e05063d13577205e0bc5f0564a0593585da9181e972974c1274d8f2b4f" kindref="member">DEBUG</ref>,<sp/></highlight><highlight class="stringliteral">&quot;abs<sp/>=<sp/>%f,<sp/>fiss<sp/>=<sp/>%f,<sp/>leak<sp/>=<sp/>%f,<sp/>keff<sp/>=<sp/>%f&quot;</highlight><highlight class="normal">,<sp/></highlight></codeline>
<codeline lineno="1569"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>tot_absorption,<sp/>tot_fission,<sp/>tot_leakage,<sp/>_k_eff);</highlight></codeline>
<codeline lineno="1570"><highlight class="normal">}</highlight></codeline>
<codeline lineno="1571"><highlight class="normal"></highlight></codeline>
<codeline lineno="1572"><highlight class="normal"></highlight></codeline>
<codeline lineno="1573"><highlight class="normal"></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="classGPUSolver_1a15e83034faeaa5f781c79eeb99388619" kindref="member" tooltip="Compute the fission rates in each flat source region and stores them in an array indexed by flat sour...">GPUSolver::computePinPowers</ref>()<sp/>{</highlight></codeline>
<codeline lineno="1574"><highlight class="normal"><sp/><sp/><sp/><sp/>log_printf(<ref refid="log_8h_1a5096002e05063d13577205e0bc5f0564a2fd6f336d08340583bd620a7f5694c90" kindref="member">ERROR</ref>,<sp/></highlight><highlight class="stringliteral">&quot;Pin<sp/>power<sp/>computation<sp/>on<sp/>the<sp/>GPU<sp/>is<sp/>not<sp/>implemented!&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="1575"><highlight class="normal">}</highlight></codeline>
    </programlisting>
    <location file="/home/wbinventor/NSE-CRPG-Codes/OpenMOC/src/dev/gpu/GPUSolver.cu"/>
  </compounddef>
</doxygen>
