<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>7. Coarse Mesh Finite Difference Acceleration &mdash; OpenMOC Documentation</title>
    
    <link rel="stylesheet" href="../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.1.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="OpenMOC Documentation" href="../index.html" />
    <link rel="up" title="Theory and Methodology" href="index.html" />
    <link rel="next" title="User’s Guide" href="../usersguide/index.html" />
    <link rel="prev" title="6. Parallelization" href="parallelization.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../usersguide/index.html" title="User’s Guide"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="parallelization.html" title="6. Parallelization"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">OpenMOC Documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">Theory and Methodology</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="coarse-mesh-finite-difference-acceleration">
<span id="cmfd"></span><h1>7. Coarse Mesh Finite Difference Acceleration<a class="headerlink" href="#coarse-mesh-finite-difference-acceleration" title="Permalink to this headline">¶</a></h1>
<p>While MOC offers many benefits including treatment of complex geometries and amenability to parallelization, it suffers from slow convergence which necessitates the use of acceleration methods. Numerous acceleration schemes have been proposed for MOC such as CMFD <a class="footnote-reference" href="#id7" id="id1">[1]</a>, coarse mesh rebalance (CMR) [<a class="reference internal" href="#id8">2</a>, <a class="reference internal" href="#id9">3</a>], and low order transport operator acceleration <a class="footnote-reference" href="#id10" id="id2">[4]</a> with CMFD being the most widely adopted due to its simplicity and acceleration performance. OpenMOC uses the CMFD nonlinear diffusion acceleration (NDA) scheme to reduce the number of iterations required to converge the neutron transport problem. Acceleration schemes, such as NDA, are necessary when solving full-core problems which require thousands of power iterations due to a high dominance ratio. CMFD was first proposed by Smith <a class="footnote-reference" href="#id7" id="id3">[1]</a> and has been widely used in accelerating neutron diffusion and transport problems for many years [<a class="reference internal" href="#id11">5</a>, <a class="reference internal" href="#id12">6</a>]. In particular, it has been shown that CMFD acceleration gives &gt;100x speedups on large LWR problems <a class="footnote-reference" href="#id13" id="id4">[7]</a>.</p>
<p>CMFD acceleration functions by using the solution of a coarse mesh diffusion problem to accelerate the convergence of a fine mesh transport problem. It is implemented by overlaying a 2D rectangular mesh over a structured or unstructured FSR mesh. <a class="reference internal" href="#figure-fsr-mesh-regions"><em>Figure 1</em></a> gives an illustration of the FSR mesh layout and coarse mesh layout used for solving a 17 x 17 PWR assembly problem.</p>
<div class="align-center figure" id="figure-fsr-mesh-regions">
<a class="reference internal image-reference" href="../_images/fig-fsr-mesh-regions.png"><img alt="../_images/fig-fsr-mesh-regions.png" src="../_images/fig-fsr-mesh-regions.png" style="width: 700px;" /></a>
<p class="caption"><strong>Figure 1</strong>: Flat source region (left) and CMFD (right) mesh layout for a 17 x 17 PWR assembly where each colored cell denotes a different region.</p>
</div>
<p>To derive the CMFD equations, we begin with the 2D, steady state multi-group neutron diffusion equation:</p>
<div class="math" id="equation-dif-eqn">
<p><span class="eqno">(1)</span><img src="../_images/math/59a1ae1850d6a399c9f4de605e0e630d4253b106.png" alt="- \nabla \cdot D_g (x,y) \nabla \phi_g (x,y) + \varSigma^A_{g} (x,y) \phi_g (x,y) + \sum_{\substack{g \prime = 1 \\ g \prime \neq g}}^G \varSigma^S_{g \rightarrow g \prime} (x,y) \phi_g (x,y) = \frac{\chi_g (x,y)}{k_{eff}} \sum_{g \prime = 1}^G \nu \varSigma^F_{g \prime} (x,y) \phi_{g \prime} (x,y) + \sum_{\substack{g \prime = 1 \\ g \prime \neq g}}^G \varSigma^S_{g \prime \rightarrow g} (x,y) \phi_{g \prime} (x,y)"/></p>
</div><p>Where the terms in equation <a href="#equation-dif-eqn">(1)</a> are defined as:</p>
<table border="1" class="docutils" id="table-dif-eqn-terms">
<colgroup>
<col width="20%" />
<col width="30%" />
<col width="20%" />
<col width="30%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Variable</th>
<th class="head">Description</th>
<th class="head">Variable</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><img class="math" src="../_images/math/9dfa31437b58c0473299320aa638151cd88cf61b.png" alt="D"/></td>
<td>Diffusion coefficient</td>
<td><img class="math" src="../_images/math/10e009bdb83f96c5f47c58b34d5d4b12ef268d5b.png" alt="\phi"/></td>
<td>Scalar flux on coarse mesh</td>
</tr>
<tr class="row-odd"><td><img class="math" src="../_images/math/bd9112158ef2f3a6f94c69c418c681591c40a3f7.png" alt="\varSigma^A"/></td>
<td>Coarse mesh absorption XS</td>
<td><img class="math" src="../_images/math/f632c791f693410fc1bf07ad7cb02c6fcfef9aed.png" alt="\chi"/></td>
<td>Fission spectrum</td>
</tr>
<tr class="row-even"><td><img class="math" src="../_images/math/f0c3ec77792d1240ac94e42e7ca3ec67c1770efa.png" alt="\varSigma^S"/></td>
<td>Coarse mesh scattering XS</td>
<td><img class="math" src="../_images/math/e45162800d593c2dee55555d800d84157e75ae00.png" alt="k_{eff}"/></td>
<td>Neutron multiplication factor</td>
</tr>
<tr class="row-odd"><td><img class="math" src="../_images/math/438fa0e26ae0c692474c4b83c923fdf4d9947038.png" alt="\varSigma^F"/></td>
<td>Coarse mesh fission XS</td>
<td><img class="math" src="../_images/math/d67fb61cfffca2cc069e083d76cb6220b4ca14c8.png" alt="\nu"/></td>
<td>Neutrons per fission</td>
</tr>
<tr class="row-even"><td><img class="math" src="../_images/math/f626d48dea6c37509677973183bacecdadde0091.png" alt="g, g \prime"/></td>
<td>Energy group index</td>
<td><img class="math" src="../_images/math/4bee6c8143f58f4fe181c0845298f4bd28cc61e1.png" alt="x, y"/></td>
<td>Position variable</td>
</tr>
</tbody>
</table>
<div class="section" id="cross-section-generation">
<h2>7.1. Cross Section Generation<a class="headerlink" href="#cross-section-generation" title="Permalink to this headline">¶</a></h2>
<p>The cross sections for the CMFD diffusion equation are generated by energy-condensation and area-averaging of the cross sections from the fine mesh as shown in equation <a href="#equation-xs-condensation">(2)</a>. The energy group structure of the CMFD diffusion equations does not necessarily have to be the same as the energy group structure used in MOC. For example, <a class="reference internal" href="#figure-coarse-group-cmfd"><em>Figure 2</em></a> shows the various ways to formulate the CMFD group structure to accelerate a three group MOC problem. When the CMFD group structure differs from the MOC group structure, we rename it coarse group coarse mesh finite difference (CGCMFD).</p>
<div class="align-center figure" id="figure-coarse-group-cmfd">
<a class="reference internal image-reference" href="../_images/cmfd-gs.png"><img alt="../_images/cmfd-gs.png" src="../_images/cmfd-gs.png" style="width: 700px;" /></a>
<p class="caption"><strong>Figure 2</strong>: Schemes for condensing the energy group structure in forming the CMFD diffusion equations.</p>
</div>
<p><strong>Cross section condensation equations</strong></p>
<div class="math" id="equation-xs-condensation">
<p><span class="eqno">(2)</span><img src="../_images/math/0a05d20fcead9043958804480a33d80f8f518376.png" alt="\varSigma^{A,i,j}_g = \frac{\displaystyle\sum\limits_{r \in (i,j)} \Sigma^{A}_{r,g} \Phi_{r,g} A_r}{\displaystyle\sum\limits_{r \in (i,j)} \Phi_{r,g} A_r}"/></p>
</div><div class="math">
<p><img src="../_images/math/3c9fa1d48a6e06375508508b24f3f365107f44e5.png" alt="\varSigma^{F,i,j}_g = \frac{\displaystyle\sum\limits_{r \in (i,j)} \Sigma^{F}_{r,g} \Phi_{r,g} A_r}{\displaystyle\sum\limits_{r \in (i,j)} \Phi_{r,g} A_r}"/></p>
</div><div class="math">
<p><img src="../_images/math/b7f147389937578ccb687ca6149d538e731b646e.png" alt="\nu \varSigma^{F,i,j}_g = \frac{\displaystyle\sum\limits_{r \in (i,j)} \nu \Sigma^{F}_{r,g} \Phi_{r,g} A_r}{\displaystyle\sum\limits_{r \in (i,j)} \Phi_{r,g} A_r}"/></p>
</div><div class="math">
<p><img src="../_images/math/59327e96099b19499554a9cc0a508cb8579298a4.png" alt="\varSigma^{S,i,j}_{g \rightarrow g \prime} = \frac{\displaystyle\sum\limits_{r \in (i,j)} \Sigma^S_{r,g \rightarrow g \prime} \Phi_{r,g} A_r}{\displaystyle\sum\limits_{r \in (i,j)} \Phi_{r,g} A_r}"/></p>
</div><div class="math">
<p><img src="../_images/math/ee90c57d6560d1cc11a2f0ed0ab989bfc4ebcb2c.png" alt="D_g^{i,j} = \frac{\displaystyle\sum\limits_{r \in (i,j)} \frac{1}{3 \Sigma^T_{r,g}} \Phi_{r,g} A_r}{\displaystyle\sum\limits_{r \in (i,j)} \Phi_{r,g} A_r}"/></p>
</div><div class="math">
<p><img src="../_images/math/f27cc8d1b40b1a65e820e590311f3b9710d71f80.png" alt="\chi_g^{i,j} = \frac{\displaystyle\sum\limits_{r \in (i,j)} \displaystyle\sum\limits_{g \prime = 1}^G \chi_{r,g} \nu \Sigma^T_{r,g \prime} \Phi_{r,g \prime} A_r}{\displaystyle\sum\limits_{r \in (i,j)} \displaystyle\sum\limits_{g \prime = 1}^G \displaystyle\sum\limits_{g \prime \prime = 1}^G \chi_{r,g \prime \prime} \nu \Sigma^{F}_{r,g \prime} \Phi_{r,g \prime} A_r}"/></p>
</div><div class="math">
<p><img src="../_images/math/f2a2dd5e9e4844a41f486eb6a083aa49e2a751f9.png" alt="\phi_g^{i,j} = \frac{\displaystyle\sum\limits_{r \in (i,j)} \Phi_{r,g} A_r}{\displaystyle\sum\limits_{r \in (i,j)} A_r}"/></p>
</div><p>Where <img class="math" src="../_images/math/a581f053bbfa5115f42c13094857cdd12a37ec49.png" alt="i"/> and <img class="math" src="../_images/math/d32c78b759903e3f4bd4fd2ce0b86358f7500c5d.png" alt="j"/> denote the mesh cell indices in the x and y directions, respectively. By condensing the cross sections in this way, we require reaction rates to be conserved. In our derivation of MOC we have assumed isotropic scattering in the lab system which makes the total cross section, <img class="math" src="../_images/math/f72a06c6803fc8b8bfdac22e7c00617f68f55968.png" alt="\Sigma^T"/>, equal to the transport cross section, <img class="math" src="../_images/math/e4f789b8c3630e900063b56078d32b55a7acb8fd.png" alt="\Sigma^{tr}"/>. This allows us to approximate the diffusion coefficient on the fine mesh as <img class="math" src="../_images/math/60d8bbcbe12c0287653c7f2052b7d62d373fca6c.png" alt="\frac{1}{3 \Sigma^T}"/> instead of its&#8217; defined value of <img class="math" src="../_images/math/bb5b00fcbec44cab0ce62afb4f684d498371db06.png" alt="\frac{1}{3 \Sigma^{tr}}"/>. Approximating the diffusion coefficient in this manner works well for optically thin regions, but induces significant error where the width of a region is much greater than the neutron mean free path (i.e. the region is optically thick). Modifications to the diffusion coefficient for optically thick regions will be discussed in <a class="reference internal" href="#optically-thick"><em>Section 7.1</em></a>.</p>
</div>
<div class="section" id="applying-the-finite-difference-approximation">
<span id="section-fd-approx"></span><h2>7.2. Applying the Finite Difference Approximation<a class="headerlink" href="#applying-the-finite-difference-approximation" title="Permalink to this headline">¶</a></h2>
<p>The diffusion operator in <a href="#equation-dif-eqn">(1)</a> can be expanded to yield:</p>
<div class="math" id="equation-dif-eqn-expand-1">
<p><span class="eqno">(3)</span><img src="../_images/math/4f9304083261bd0bf08d14220d9af6034a7240df.png" alt="- \frac{\partial}{\partial x} D_g (x,y) \frac{\partial}{\partial x} \phi_g (x,y) - \frac{\partial}{\partial y} D_g (x,y) \frac{\partial}{\partial y} \phi_g (x,y) + \varSigma^A_{g} \phi_g (x,y) + \sum_{\substack{g \prime = 1 \\ g \prime \neq g}}^G \varSigma^S_{s,g \rightarrow g \prime} (x,y) \phi_g (x,y) = \frac{\chi_g (x,y)}{k_{eff}} \sum_{g \prime = 1}^G \nu \varSigma^F_{g \prime} (x,y) \phi_{g \prime} (x,y) + \sum_{\substack{g \prime = 1 \\ g \prime \neq g}}^G \varSigma^S_{g \prime \rightarrow g} (x,y) \phi_{g \prime} (x,y)"/></p>
</div><p>We can integrate <a href="#equation-dif-eqn-expand-1">(3)</a> over a mesh cell to get the neutron balance in that cell. Performing the integration on cell <img class="math" src="../_images/math/0de78069ab15c688f6d8c6f59d5c5805bc969595.png" alt="(i,j)"/> and simplifying we get:</p>
<div class="math">
<p><img src="../_images/math/fbf8213b47fa3d14553fd1429c45f266954e246e.png" alt="- \int_{i-\frac{1}{2}}^{i+\frac{1}{2}} \int_{j-\frac{1}{2}}^{j+\frac{1}{2}} \frac{\partial}{\partial x} D_g^{i,j} \frac{\partial}{\partial x} \phi_g^{i,j} dx dy - \int_{i-\frac{1}{2}}^{i+\frac{1}{2}} \int_{j-\frac{1}{2}}^{j+\frac{1}{2}} \frac{\partial}{\partial y} D_g^{i,j} \frac{\partial}{\partial y} \phi_g^{i,j} dx dy + \Delta x^{i,j} \Delta y^{i,j} \varSigma_{g}^{A,i,j} \phi_g^{i,j} + \Delta x^{i,j} \Delta y^{i,j} \sum_{\substack{g \prime = 1 \\ g \prime \neq g}}^G \varSigma_{g \rightarrow g \prime}^{S,i,j} \phi_g^{i,j} = \Delta x^{i,j} \Delta y^{i,j} \frac{\chi_g^{i,j}}{k_{eff}} \sum_{g \prime = 1}^G \nu \varSigma_{g \prime}^{F,i,j} \phi_{g \prime}^{i,j} + \Delta x^{i,j} \Delta y^{i,j} \sum_{\substack{g \prime = 1 \\ g \prime \neq g}}^G \varSigma_{g \prime \rightarrow g}^{S,i,j} \phi_{g \prime}^{i,j}"/></p>
</div><p>Where <img class="math" src="../_images/math/d93d931755f8b8a8cd9535c1052422412b741fa3.png" alt="\Delta x^{i,j}"/> and <img class="math" src="../_images/math/e8db0b47139b43380e6d002f4eac0f38ec80da32.png" alt="\Delta y^{i,j}"/> denote the width and height of cell (i,j), respectively. Using the Divergence Theorem, we can reduce the volume integrals of the streaming terms to surface integrals over the bounding surfaces of a cell. The surface integrals will then represent currents across the surfaces of a cell. Using streaming in the x-direction as an example, we can rewrite the volume integral of the streaming term in the x-direction as:</p>
<div class="math">
<p><img src="../_images/math/23542e25c97a6879022acbf098998baa3197d602.png" alt="- \int_{i-\frac{1}{2}}^{i+\frac{1}{2}} \int_{j-\frac{1}{2}}^{j+\frac{1}{2}} \frac{\partial}{\partial x} D_g^{i,j} \frac{\partial}{\partial x} \phi_g^{i,j} dx dy = - \Delta y^{i,j} (J_g^{i+\frac{1}{2},j} - J_g^{i-\frac{1}{2},j})"/></p>
</div><p>Where <img class="math" src="../_images/math/5767e0b748f61e847e83f1a341d20a00273c6a5e.png" alt="J_g^{i+\frac{1}{2},j}"/> and <img class="math" src="../_images/math/bd5efdb20a934a54c62ce7b4fe138dc170b8c711.png" alt="J_g^{i-\frac{1}{2},j}"/> represent the surface-averaged net current across the right surface and across the left surface, respectively. An analogous equation can be written for streaming in the y direction.</p>
<p>As an example, we will now solve for the currents on the right surface of a cell <img class="math" src="../_images/math/0de78069ab15c688f6d8c6f59d5c5805bc969595.png" alt="(i,j)"/> with neighboring cell <img class="math" src="../_images/math/9f8dce9725827ec79490b0b811a8d2994ee44214.png" alt="(i, j + 1)"/> as illustrated in <a class="reference internal" href="#figure-cmfd-example"><em>Figure 3</em></a>.</p>
<div class="align-center figure" id="figure-cmfd-example">
<a class="reference internal image-reference" href="../_images/cmfd-example.png"><img alt="../_images/cmfd-example.png" src="../_images/cmfd-example.png" style="width: 400px;" /></a>
<p class="caption"><strong>Figure 3</strong>: Illustration of terms required to solve for streaming of neutrons from cell :math`(i,j)` to <img class="math" src="../_images/math/5c499abe720985595fb76028f9130ee1b944e0c4.png" alt="(i+1,j)"/> in CMFD diffusion.</p>
</div>
<p>To solve for the current at cell boundaries, we can perform finite difference approximations of the flux at a surface using the flux in the adjacent cells:</p>
<div class="math">
<p><img src="../_images/math/c7bd12ce12d0028b144ce36e843670abf76d55b6.png" alt="J_{g}^{i+\frac{1}{2},j,+} = \left. - D_g^{i+1,j} \frac{d \phi_g^{i+\frac{1}{2},j}}{d x} \right|_{x^{i+\frac{1}{2},j,+}} = - D_g^{i+\frac{1}{2},j} \frac{\phi_g^{i+1,j} - \phi_g^{i+\frac{1}{2},j}}{\frac{\Delta x^{i+1,j}}{2}}\\ \nonumber
J_{g}^{i+\frac{1}{2},j,-} = \left. - D_g^{i,j} \frac{d \phi_g^{i+\frac{1}{2},j}}{d x} \right|_{x^{i+\frac{1}{2},j,-}} = - D_g^{i,j} \frac{\phi_g^{i+\frac{1}{2},j} - \phi_g^{i,j}}{\frac{\Delta x^{i,j}}{2}}"/></p>
</div><p>Where <img class="math" src="../_images/math/895ec90449977bb7f3679c16e10345eda0854a18.png" alt="J_{g}^{i+\frac{1}{2},j,+}"/> and <img class="math" src="../_images/math/925b33c25ca12c467e07eaf201641a13adfcf638.png" alt="J_{g}^{i+\frac{1}{2},j,-}"/> are the surface-averaged partial currents as approximated using a backward difference approximation from the cell at :math`(i,j)` and a forward difference approximation from the cell at <img class="math" src="../_images/math/5c499abe720985595fb76028f9130ee1b944e0c4.png" alt="(i+1,j)"/>, respectively. Equating these representations of the current we can solve for the flux at the surface:</p>
<div class="math">
<p><img src="../_images/math/413001c55ab4e25a3f3ffb2506e441c386ef5412.png" alt="\phi_g^{i+\frac{1}{2},j} = \frac{D_g^{i,j} \phi_g^{i,j} \Delta x^{i+1,j} + D_g^{i+1,j} \phi_g^{i+1,j} \Delta x^{i,j}}{D_g^{i,j}\Delta x^{i+1,j} + D_g^{i+1,j} \Delta x^{i,j}}"/></p>
</div><p>The net current across the surface at <img class="math" src="../_images/math/d7117315315c369332791ae00b5697f78695e6e7.png" alt="(i+\frac{1}{2},j)"/> is then:</p>
<div class="math" id="equation-eqn-alg-net-current">
<p><span class="eqno">(4)</span><img src="../_images/math/d400291e613e38406520b007c14c744e94b3e362.png" alt="J_{g}^{i+\frac{1}{2},j} = - \hat{D}^{i+\frac{1}{2},j} (\phi^{i+1,j} - \phi^{i,j})"/></p>
</div><p>Where:</p>
<div class="math" id="equation-eqn-surf-dif-coef">
<p><span class="eqno">(5)</span><img src="../_images/math/aa7bc9a62476bd26e6c5ece55cc910614a2a08c5.png" alt="\hat{D}_g^{i+\frac{1}{2},j} = \frac{2 D_g^{i,j} D_g^{i+1,j}}{D_g^i\Delta x^{i+1,j} + D_g^{i+1,j} \Delta x^{i,j}}"/></p>
</div><p>The neutron balance equation in a cell then becomes:</p>
<div class="math" id="equation-eqn-dif-eqn-simple">
<p><span class="eqno">(6)</span><img src="../_images/math/db20b731aca1e079e1eb55ab88889f469bc450fe.png" alt="- \Delta y^{i,j} (J_g^{i+\frac{1}{2},j} - J_g^{i-\frac{1}{2},j}) - \Delta x^{i,j} (J_g^{i,j+\frac{1}{2}} - J_g^{i,j-\frac{1}{2}}) + \Delta x^{i,j} \Delta y^{i,j} \varSigma_{g}^{A,i,j} \phi_g^{i,j} + \Delta x^{i,j} \Delta y^{i,j} \sum_{\substack{g \prime = 1 \\ g \prime \neq g}}^G \varSigma_{g \rightarrow g \prime}^{S,i,j} \phi_g^{i,j} = \Delta x^{i,j} \Delta y^{i,j} \frac{\chi_g^{i,j}}{k_{eff}} \sum_{g \prime = 1}^G \nu \varSigma_{g \prime}^{F,i,j} \phi_{g \prime}^{i,j} + \Delta x^{i,j} \Delta y^{i,j} \sum_{\substack{g \prime = 1 \\ g \prime \neq g}}^G \varSigma_{g \prime \rightarrow g}^{S,i,j} \phi_{g \prime}^{i,j}"/></p>
</div><p>Note that <a href="#equation-eqn-alg-net-current">(4)</a> is the algebraic net current based on the finite difference approximation being applied across the surface of two neighboring cells and not the actual net current in the MOC problem. The actual current from the MOC problem is computed by accumulating the current contribution from every segment that crosses a surface as will be shown in the <em class="xref std std-ref">Section 7.3</em>.</p>
</div>
<div class="section" id="nonlinear-diffusion-correction-factors">
<h2>7.3. Nonlinear Diffusion Correction Factors<a class="headerlink" href="#nonlinear-diffusion-correction-factors" title="Permalink to this headline">¶</a></h2>
<p>In order to conserve neutron balance between the CMFD and MOC problems, the net currents across the coarse mesh cell surfaces must be equal. The surface diffusion coefficient expression in <a href="#equation-eqn-surf-dif-coef">(5)</a> results in a neutron current close to the actual current produced via the MOC solve, but there is no guarantee the currents will be equal. To compute the currents from MOC, the net currents are tallied during a transport sweep by summing the current contributions from each track that intersects a surface. For example, <a href="#equation-eqn-surf-avg-tallied-current">(7)</a> represents the net current tally expression for surface <img class="math" src="../_images/math/5bc814abd4e538491b79d9ce6c673bdd43c98ea3.png" alt="(i + \frac{1}{2}, j)"/>.</p>
<div class="math" id="equation-eqn-surf-avg-tallied-current">
<p><span class="eqno">(7)</span><img src="../_images/math/dd7a4b14df28d1408bc94bd9f9fbab62f41e08de.png" alt="\tilde{J}_g^{i + \frac{1}{2}, j} = \sum_{k \cap (i+\frac{1}{2},j)} \Psi_{k,g,p} \frac{\omega_p \tilde{\omega}_k}{2 \pi} \sin \theta_p \cdot \hat{n}"/></p>
</div><p>Where <img class="math" src="../_images/math/976c654a0f1ab8febd8371ae77e428960e8b4506.png" alt="\hat{n}"/> is the unit surface normal and <img class="math" src="../_images/math/9821160ac96e2802ee6011ed5b20462d5a4d7b5c.png" alt="\tilde{\omega}_k"/> is the length of surface crossed by the track, as illustrated in <a class="reference internal" href="#figure-current-tally"><em>Figure 4</em></a>.</p>
<div class="align-center figure" id="figure-current-tally">
<a class="reference internal image-reference" href="../_images/current-tally.png"><img alt="../_images/current-tally.png" src="../_images/current-tally.png" style="width: 400px;" /></a>
<p class="caption"><strong>Figure 4</strong>: Angular flux from track <img class="math" src="../_images/math/e9203da50e1059455123460d4e716c9c7f440cc3.png" alt="k"/> with energy group <img class="math" src="../_images/math/67f4714f065d485540ad40829e0717bf75e9dd85.png" alt="g"/> and polar angle <img class="math" src="../_images/math/3eca8557203e86160952e1c0f735f7417f3285b1.png" alt="p"/> crossing surface <img class="math" src="../_images/math/bf9b1af4e59cb134363f04db675709ea357c2d69.png" alt="(i+\frac{1}{2}, j)"/>.</p>
</div>
<p>The length of surface crossed by the track is defined as:</p>
<div class="math" id="equation-eqn-surf-len-track">
<p><span class="eqno">(8)</span><img src="../_images/math/181daa53627472bfa95888f9d3923da97328e293.png" alt="\tilde{\omega}_k = \frac{\omega_k}{\cos \theta_k}"/></p>
</div><p>Inserting <a href="#equation-eqn-surf-len-track">(8)</a> into <a href="#equation-eqn-surf-avg-tallied-current">(7)</a> gives us:</p>
<div class="math" id="equation-eqn-surf-avg-tallied-current-2">
<p><span class="eqno">(9)</span><img src="../_images/math/543db900e5bef24b346ea182fa9670237e0be8f8.png" alt="\tilde{J}_g^{i + \frac{1}{2}, j} = \sum_{k \cap (i+\frac{1}{2},j)} \Psi_{k,g,p} \frac{\omega_p \omega_k}{2 \pi \cos \theta_k} \sin \theta_p \cdot \hat{n}"/></p>
</div><p>When we dot the track azimuthal angle with the unit surface normal of the track, we get <img class="math" src="../_images/math/7377c92a8a44fc33492f92ff79389af59ece2a14.png" alt="\cos \theta_k"/>, which reduces <a href="#equation-eqn-surf-avg-tallied-current-2">(9)</a> to:</p>
<div class="math" id="equation-eqn-surf-avg-tallied-current-3">
<p><span class="eqno">(10)</span><img src="../_images/math/90253fb24abf8a05a9dca88bf3b7140acce76b07.png" alt="\tilde{J}_g^{i + \frac{1}{2}, j} = \sum_{k \cap (i+\frac{1}{2},j)} \Psi_{k,g,p} \frac{\omega_p \omega_k}{2 \pi} \sin \theta_p"/></p>
</div><p>In order for the tallied net currents to equal the net current expression, a nonlinear diffusion coefficient term is added to <a href="#equation-eqn-alg-net-current">(4)</a>:</p>
<div class="math" id="equation-eqn-alg-net-current-cor">
<p><span class="eqno">(11)</span><img src="../_images/math/bdadeebf8834bbfc999d5c002015f8e58d053e2c.png" alt="\frac{\tilde{J}_{g}^{i+\frac{1}{2},j}}{\Delta y^{i,j}} = - \hat{D}^{i+\frac{1}{2},j} (\phi^{i+1,j} - \phi^{i,j}) - \tilde{D}^{i+\frac{1}{2},j} (\phi^{i+1,j} + \phi^{i,j})"/></p>
</div><p>Where <img class="math" src="../_images/math/a3d4cc4582dd91209821872a6202bdc448c2b21a.png" alt="\tilde{D}"/> is the nonlinear diffusion coefficient correction factor. Note that current expression computes the surface-averaged net current whereas the current tallied from MOC has not been averaged over the surface; therefore, in <a href="#equation-eqn-alg-net-current-cor">(11)</a> the net current tallied from MOC has been divided by the length of the surface that is being crossed. <img class="math" src="../_images/math/a3d4cc4582dd91209821872a6202bdc448c2b21a.png" alt="\tilde{D}"/> is computed to make <a href="#equation-eqn-alg-net-current-cor">(11)</a> valid for the tallied net surface current in MOC for the most recent transport sweep:</p>
<div class="math" id="equation-eqn-dif-cor-factor">
<p><span class="eqno">(12)</span><img src="../_images/math/b4d59dd805ab9ed699df09b7feeace19ab40a113.png" alt="\tilde{D}^{i+\frac{1}{2},j} = \frac{- \hat{D}^{i+\frac{1}{2},j} (\phi^{i+1,j} - \phi^{i,j}) - \frac{\tilde{J}_{g}^{i+\frac{1}{2},j}}{\Delta y^{i,j}}}{(\phi^{i+1,j} + \phi^{i,j})}"/></p>
</div></div>
<div class="section" id="coarse-mesh-cell-corner-crossings">
<h2>7.4. Coarse Mesh Cell Corner Crossings<a class="headerlink" href="#coarse-mesh-cell-corner-crossings" title="Permalink to this headline">¶</a></h2>
<p>In the CMFD formalism introduced in the previous sections, we only treat transport to adjacent cells. However, MOC produces tracks that intersect mesh cell corners as shown in <a class="reference internal" href="#figure-corner-crossing"><em>Figure 5</em></a>. Corner crossings can result from either direct intersections where the track exactly intersects a corner or partial intersections where, when we consider a track has a finite width, the track sweeps across the corner.</p>
<div class="align-center figure" id="figure-corner-crossing">
<a class="reference internal image-reference" href="../_images/corner-crossing.png"><img alt="../_images/corner-crossing.png" src="../_images/corner-crossing.png" style="width: 600px;" /></a>
<p class="caption"><strong>Figure 5</strong>: Illustration of track crossing directly through the corner of a cell. The two main approximations for treating currents are denoted textbf{1} and textbf{2} and described below.</p>
</div>
<p>There are three main approximations to treat corner crossings:</p>
<ol class="arabic simple">
<li>Consistently tallying the current from tracks through specific corners to only one of the surfaces. This approximation effectively moves the track far enough to one side such that the entire segment crosses a single surface.</li>
<li>Split the current evenly among the surfaces. This approximation effectively splits the track into two partially-weighted segments and moves them to either side of the corner such that each new partially-weighted track only sweeps across one surface.</li>
<li>A hybrid of approximations 1 and 2 where tracks that directly cross through a corner are treated with approximation 2 and tracks the directly cross through one surface but sweep through a corner are treated with approximation 1.</li>
</ol>
<p>Note that tracks are not physically moved in any of these cases; rather, we make the assumption that they are moved when we tally the surface currents. In OpenMOC we have implemented approximation 3 where only tracks that directly intersect a corner are split among the surfaces. The partial weight given to each new track is half the original weight, regardless of track angle. While applying approximation 2 for all tracks would be more accurate, this would require additional computational costs when the tracks are generated, which can be a signficant portion of computational time for large geometries. The tallies for a track that crosses from cell <img class="math" src="../_images/math/0de78069ab15c688f6d8c6f59d5c5805bc969595.png" alt="(i,j)"/> to <img class="math" src="../_images/math/90c8f351a989246ad7aaf6359ae26115467a3983.png" alt="(i+1,j+1)"/> for this approximation are given in <a href="#equation-eqn-corner-crossing">(13)</a>.</p>
<div class="math" id="equation-eqn-corner-crossing">
<p><span class="eqno">(13)</span><img src="../_images/math/bb36cc8539bb3616dfd2ae3be875f79a48a649a4.png" alt="\tilde{J}_g^{i + \frac{1}{2},j} = \frac{1}{2} \sum_{k \cap (i+\frac{1}{2},j+\frac{1}{2})} \Psi_{k,g,p} \frac{\omega_p \omega_k}{2 \pi} \sin \theta_p \\
\tilde{J}_g^{i,j + \frac{1}{2}} = \frac{1}{2} \sum_{k \cap (i+\frac{1}{2},j+\frac{1}{2})} \Psi_{k,g,p} \frac{\omega_p \omega_k}{2 \pi} \sin \theta_p \\
\tilde{J}_g^{i + 1, j + \frac{1}{2}} = \frac{1}{2} \sum_{k \cap (i+\frac{1}{2},j+\frac{1}{2})} \Psi_{k,g,p} \frac{\omega_p \omega_k}{2 \pi} \sin \theta_p \\
\tilde{J}_g^{i + \frac{1}{2}, j + 1} = \frac{1}{2} \sum_{k \cap (i+\frac{1}{2},j+\frac{1}{2})} \Psi_{k,g,p} \frac{\omega_p \omega_k}{2 \pi} \sin \theta_p"/></p>
</div><p>Where the summation is over the tracks that cross a specific corner denoted <img class="math" src="../_images/math/608d43f1d812fd12eba33413fd65dbd68f48883d.png" alt="(i + \frac{1}{2}, j + \frac{1}{2})"/>. Note that the current is tallied on both the surfaces that bound cell <img class="math" src="../_images/math/0de78069ab15c688f6d8c6f59d5c5805bc969595.png" alt="(i,j)"/> <em>and</em> on surfaces <img class="math" src="../_images/math/bb1c2275bc11cfa41c73c62c5599c219c7cb44c8.png" alt="(i+\frac{1}{2},j+1)"/> and <img class="math" src="../_images/math/7d174f3bae94a6f25c2053969b62996bc676ed8b.png" alt="(i+1,j+\frac{1}{2})"/> in order to preserve neutron balance between all four cells.</p>
</div>
<div class="section" id="optically-thick-regions">
<span id="optically-thick"></span><h2>7.5. Optically Thick Regions<a class="headerlink" href="#optically-thick-regions" title="Permalink to this headline">¶</a></h2>
<p>As shown in <a class="reference internal" href="#figure-fsr-mesh-regions"><em>Figure 1</em></a> the CMFD mesh is often applied at the pin cell level with cells on the order of 1-2 cm. For some problems, such was BWR bundles with large water pins, the rectilinear pin cell lattice might not be maintained, requiring the CMFD mesh to be coarsened to the assembly level. By conserving reaction and leaking rates within cells, CMFD guarantees to preserve the area-averaged scalar fluxes and net surface currents from the MOC transport sweep if the CMFD equations can be converged. However, when the coarse mesh cell size becomes significantly larger than the neutron mean free path in that cell, the step characteristics no longer preserve the linear infinite medium solution to the transport equation <a class="footnote-reference" href="#id14" id="id5">[8]</a>. Using the appoximation of the diffusion coefficient as <img class="math" src="../_images/math/4c5900cc40e4b83ec85cab6430dc2c3de2e44f1b.png" alt="\frac{1}{3 \Sigma^{T}}"/> results is an unphysically large diffusion coefficient. Put in other words, the large diffusion coefficient suggests that the region is optically thin when it is actually optically thick. Due to this inconsistency in approximating the diffusion coefficient for optically thick cells, an &#8220;effective&#8221; diffusion coefficient was derived in <a class="footnote-reference" href="#id14" id="id6">[8]</a>. The effective diffusion coefficient in the x-direction for cell <img class="math" src="../_images/math/0de78069ab15c688f6d8c6f59d5c5805bc969595.png" alt="(i,j)"/> can be expressed as:</p>
<div class="math" id="equation-eqn-optic-thick-d">
<p><span class="eqno">(14)</span><img src="../_images/math/e060d55cbeed0e879306baa6a4c51309e05c8380.png" alt="D_g^{i,j,eff,x} = D_g^{i,j} \bigg(1 + \frac{\Delta x^{i,j} \rho_g^{i,j,x}}{2 D_g^{i,j}} \bigg) \\
\rho_g^{i,j,x} = \frac{\displaystyle\sum\limits_{k = 1}^K \omega_p \omega_{m(k)} \alpha_{g,k}^{i,j,x}}{\displaystyle\sum\limits_{k = 1}^{K} \omega_{m(k)}} \\
\alpha_{g,k}^{i,j,x} = \left( \frac{1 + e^{-\frac{\Delta x^{i,j}}{3 D_g^{i,j} \omega_{m(k)}}}}{1 - e^{-\frac{\Delta x^{i,j}}{3 D_g^{i,j} \omega_{m(k)}}}} \right) - \frac{2 \omega_{m(k)}}{\Delta x^{i,j}}"/></p>
</div><p>Note that the effective diffusion coefficient depends on the width of the cell and is therefore directional in a 2D mesh. Equation <a href="#equation-eqn-optic-thick-d">(14)</a> can also be used to computed the effective diffusion coefficient in the y-direction, which will differ from the effective diffusion coefficient in the x-direction if the cell if the cell is not a square. As the size of the cell approaches zero and the optical thickness of the cell approaches the optically thin limit, the effective diffusion coefficient will approach the material diffusion coefficient. For simplicity, we continue to use the surface diffusion coefficient terms in the rest of this description without the &#8220;eff&#8221; superscript.</p>
</div>
<div class="section" id="matrix-equations">
<span id="cmfd-matrix-form"></span><h2>7.6. Matrix Equations<a class="headerlink" href="#matrix-equations" title="Permalink to this headline">¶</a></h2>
<p>Going back to <a href="#equation-eqn-dif-eqn-simple">(6)</a> and inserting the nonlinear diffusion coefficients from <a href="#equation-eqn:dif-cor-factor">(?)</a>, the finite difference form of the diffusion equation over a mesh cell becomes:</p>
<div class="math">
<p><img src="../_images/math/6db4135e6d17c21ddbb610ae911131d14ef1c589.png" alt="\Delta y^{i,j} (\hat{D}_g^{i-\frac{1}{2},j} [\phi_g^{i,j} - \phi_g^{i-1,j}] + \tilde{D}_g^{i-\frac{1}{2},j} [\phi_g^{i,j} + \phi_g^{i-1,j}]) - \Delta y^{i,j} (\hat{D}_g^{i+\frac{1}{2},j} [\phi_g^{i+1,j} - \phi_g^{i,j}] + \tilde{D}_g^{i+\frac{1}{2},j} [\phi_g^{i+1,j} - \phi_g^{i,j}]) + \Delta x^{i,j} (\hat{D}_g^{i,j-\frac{1}{2}} [\phi_g^{i,j} - \phi_g^{i,j-1}] + \tilde{D}_g^{i,j-\frac{1}{2}} [\phi_g^{i,j} + \phi_g^{i,j-1}]) \\
- \Delta x^{i,j} (\hat{D}_g^{i,j-\frac{1}{2}} [\phi_g^{i,j+1} - \phi_g^{i,j}] + \tilde{D}_g^{i,j-\frac{1}{2}} [\phi_g^{i,j+1} + \phi_g^{i,j}]) + \Delta x^{i,j} \Delta y^{i,j} \varSigma_{g}^{A,i,j} \phi_g^{i,j} + \Delta x^{i,j} \Delta y^{i,j} \sum_{\substack{g \prime = 1 \\ g \prime \neq g}}^G \varSigma_{g \rightarrow g \prime}^{S,i,j} \phi_g^{i,j} = \Delta x^{i,j} \Delta y^{i,j} \frac{\chi_g^{i,j}}{k_{eff}} \sum_{g \prime = 1}^G \nu \varSigma_{g \prime}^{F,i,j} \phi_{g \prime}^{i,j} + \Delta x^{i,j} \Delta y^{i,j} \sum_{\substack{g \prime = 1 \\ g \prime \neq g}}^G \varSigma_{g \prime \rightarrow g}^{S,i,j} \phi_{g \prime}^{i,j}"/></p>
</div><p>We can collapse the spatial dependence and write this equation in matrix form as:</p>
<div class="math">
<p><img src="../_images/math/ec946c0cfb8203b2b1e848670ddd2d79aec68592.png" alt="A_{streaming} \phi + A_{removal} \phi = \frac{1}{k_{eff}} M \phi + A_{gain} \phi"/></p>
</div><p>Where:</p>
<table border="1" class="docutils" id="table-dif-mat-terms">
<colgroup>
<col width="24%" />
<col width="76%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Variable</th>
<th class="head">Description</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><img class="math" src="../_images/math/3204c171e1aaa8c61ad2074b315d3bce19fbcb29.png" alt="A_{streaming}"/></td>
<td>NG x NG matrix with 4 diagonals for cell to cell transport</td>
</tr>
<tr class="row-odd"><td><img class="math" src="../_images/math/2735c450f6092135d3931a105debc17a474cb2bb.png" alt="A_{removal}"/></td>
<td>NG x NG matrix with G diagonals for absorption and outscattering</td>
</tr>
<tr class="row-even"><td><img class="math" src="../_images/math/2de38926392ba23abeac75effc66c37a5f5be5fd.png" alt="M"/></td>
<td>NG x NG matrix with G diagonals for generation by fission</td>
</tr>
<tr class="row-odd"><td><img class="math" src="../_images/math/9285194617ec52c5ae75b0b8a4eb101f6f4bea11.png" alt="A_{gain}"/></td>
<td>NG x NG matrix with G diagonals for inscattering</td>
</tr>
<tr class="row-even"><td><img class="math" src="../_images/math/10e009bdb83f96c5f47c58b34d5d4b12ef268d5b.png" alt="\phi"/></td>
<td>NG length vector for the flux</td>
</tr>
<tr class="row-odd"><td><img class="math" src="../_images/math/75e27f04188974063be3230dca208cd495b77ce1.png" alt="N"/></td>
<td>The numbert of coarse mesh cells, I x J</td>
</tr>
<tr class="row-even"><td><img class="math" src="../_images/math/b92c09a649305a0aef3239729d93cdf941e0e5cf.png" alt="G"/></td>
<td>The numbert of energy groups</td>
</tr>
<tr class="row-odd"><td><img class="math" src="../_images/math/e45162800d593c2dee55555d800d84157e75ae00.png" alt="k_{eff}"/></td>
<td>Multiplication factor</td>
</tr>
</tbody>
</table>
<p>We can combine the difference <img class="math" src="../_images/math/0acafa529182e79b4f56165ec677554fba7fcf98.png" alt="A"/> matrices to get the more recognizable CMFD diffusion eigenvalue equation:</p>
<div class="math" id="equation-eqn-diffusion-matrix-form">
<p><span class="eqno">(15)</span><img src="../_images/math/48859c3fdb8c55075671d7bcf92ce8166cad4bc7.png" alt="A \phi = \frac{1}{k_{eff}} M \phi"/></p>
</div><p>In <a class="reference internal" href="#cmfd-accel-moc"><em>Section 7.4</em></a> we discuss how this matrix equation will be solved and used to accelerate the solution of the MOC solve.</p>
</div>
<div class="section" id="cmfd-accelerated-moc-algorithm">
<span id="cmfd-accel-moc"></span><h2>7.7. CMFD Accelerated MOC Algorithm<a class="headerlink" href="#cmfd-accelerated-moc-algorithm" title="Permalink to this headline">¶</a></h2>
<p>The general flowchart for CMFD accelerated MOC in <a class="reference internal" href="#figure-cmfd-accel-moc"><em>Figure 6</em></a>.</p>
<div class="align-center figure" id="figure-cmfd-accel-moc">
<a class="reference internal image-reference" href="../_images/cmfd-accel-moc.png"><img alt="../_images/cmfd-accel-moc.png" src="../_images/cmfd-accel-moc.png" style="width: 800px;" /></a>
<p class="caption"><strong>Figure 6</strong>: The solution procedure for CMFD accelerated MOC.</p>
</div>
<p>CMFD acceleration is implemented in OpenMOC by overlaying a Cartesian coarse mesh on top of the unstructured flat source region mesh as shown in <em class="xref std std-ref">Figure 1</em>. During a MOC transport sweep, OpenMOC tallies the net currents across the surfaces of each mesh cell. The transport sweep algorithm then becomes <em class="xref std std-ref">Figure 7</em>.</p>
<div class="align-center figure" id="alg-cmfd-accel-moc">
<a class="reference internal image-reference" href="../_images/alg-transport-sweep-CMFD.png"><img alt="../_images/alg-transport-sweep-CMFD.png" src="../_images/alg-transport-sweep-CMFD.png" style="width: 800px;" /></a>
<p class="caption"><strong>Figure 7</strong>: The solution procedure for CMFD accelerated MOC.</p>
</div>
<p>At the end of the transport sweep, OpenMOC proceeds to condense the cross sections, flux, and diffusion coefficients according to <a href="#equation-xs-condensation">(2)</a>. The diffusion coefficient coupling terms that link neighboring cells, <img class="math" src="../_images/math/c94b09a31653be0f157d4c79bc366d78cbf39c0b.png" alt="\hat{D}"/> and <img class="math" src="../_images/math/a3d4cc4582dd91209821872a6202bdc448c2b21a.png" alt="\tilde{D}"/>, are then computed using <a href="#equation-eqn-surf-dif-coef">(5)</a> and <a href="#equation-eqn-dif-cor-factor">(12)</a>. There are two subtle points in computing the nonlinear coupling coefficients <img class="math" src="../_images/math/a3d4cc4582dd91209821872a6202bdc448c2b21a.png" alt="\tilde{D}"/>. First, the condition <img class="math" src="../_images/math/35f948ef723530b30d8568ee978a2b816f7ee610.png" alt="|\tilde{D}| &lt; |\hat{D}|"/> must be met in order to guarantee the diagonal dominance in the destruction matrix, A. If this condition is not met, the surface diffusion coefficients will be re-computed such that they are equal in magnitude and satisfy <a href="#equation-eqn-alg-net-current-cor">(11)</a>. Secondly, under-relaxation of the nonlinear correction factor is used to accelerate and maintain stability of the eigenvalue convergence rate for large, heterogeneous geometries. OpenMOC does so by applying a fixed damping factor on the <img class="math" src="../_images/math/a3d4cc4582dd91209821872a6202bdc448c2b21a.png" alt="\tilde{D}"/> terms. The nonlinear diffusion coefficients are initially set to zero and modified according to <a href="#equation-eqn-nldif-damp">(16)</a>.</p>
<div class="math" id="equation-eqn-nldif-damp">
<p><span class="eqno">(16)</span><img src="../_images/math/c4d34c4416c94725ad6b7ade3380e1e83048cdb5.png" alt="\tilde{D}^{i+\frac{1}{2},j,(n)}_g = (1 - \omega_d) \tilde{D}^{i+\frac{1}{2},j,(n-1)}_g + \omega_d \frac{- \hat{D}^{i+\frac{1}{2},j,(n)}_g (\phi^{i+1,j,(n)}_g - \phi^{i,j,(n)}_g) - \frac{\tilde{J}_{g}^{i+\frac{1}{2},j,(n)}}{\Delta y^{i,j}}}{(\phi_g^{i+1,j,(n)} + \phi^{i,j,(n)}_g)}"/></p>
</div><p>Where <img class="math" src="../_images/math/4a6ac24dcdc06a617f0c4c875f4e56743b97c9aa.png" alt="\omega_d"/> is the under-relaxation dampening factor and <img class="math" src="../_images/math/e677529e38c70ecf5282bd82ea06669c913e8a5a.png" alt="(n)"/> is the transport sweep iteration. Within each CMFD iteration, OpenMOC uses power iterations to solve the generalized non-Hermitian eigenvalue problem as shown in <a class="reference internal" href="#alg-cmfd-solve"><em>Figure 8</em></a>. In each power iteration, the linear system is solved using a parallel (red-black) implementation of the successive over-relaxation method as shown in <a class="reference internal" href="#alg-sor-solve"><em>Figure 9</em></a>. Upon convergence of the CMFD diffusion problem, OpenMOC performs prolongation by multiplying each FSR&#8217;s scalar flux by the ratio of the converged coarse mesh scalar flux to the initial coarse mesh scalar flux in the acceleration step:</p>
<div class="math" id="equation-eqn-cmfd-prolongation">
<p><span class="eqno">(17)</span><img src="../_images/math/d78afd8810aebe5ac7808e3d1926b305f75b62e4.png" alt="\Phi_{r,g} = \Phi_{r,g} \frac{\phi^{i,j,new}_{g}}{\phi^{i,j,old}_{g}}  \qquad \forall \quad r \in (i,j)"/></p>
</div><p>where <img class="math" src="../_images/math/2db19f2c175bdc031fbb4923c882dddc7ca88438.png" alt="\phi^{i,j,old}_{g}"/> is the coarse mesh scalar flux computed using equation <a href="#equation-xs-condensation">(2)</a> and <img class="math" src="../_images/math/f866d8de554364b176bf740d6ebcb349afadff6d.png" alt="\phi^{i,j,new}_{g}"/> is the converged CMFD coarse mesh scalar flux.</p>
<div class="align-center figure" id="alg-cmfd-solve">
<a class="reference internal image-reference" href="../_images/alg-cmfd-solve.png"><img alt="../_images/alg-cmfd-solve.png" src="../_images/alg-cmfd-solve.png" style="width: 800px;" /></a>
<p class="caption"><strong>Figure 8</strong>: Power Iteration Outer Loop Source Iteration.</p>
</div>
<p>Instead of splitting the corner currents during the MOC transport sweep, OpenMOC tallies the corner currents as independent surfaces and then splits the corner currents between their neighboring surfaces in step 2 of <a class="reference internal" href="#alg-cmfd-solve"><em>Figure 8</em></a>. With the corner currents accounted for, the surface diffusion coefficients are then computed just prior to the power method eigenvalue solve. The first step in the power method inner loop iteration is to solve a linear fixed fission source problem. The SOR method is used to solve the linear system with the SOR relaxation factor denoted as <img class="math" src="../_images/math/2a06d898b7c944be04bb32b7dc3a6ca1fb1473e4.png" alt="\omega_r"/> as described by <a class="reference internal" href="#alg-sor-solve"><em>Figure 9</em></a>. While more computationally efficient methods exist for solving generalized non-Hermitian eigenvalue problems like Krylov-subspace methods, we chose the power method for its simplicity and stability. Additionally, more computationally efficient methods exist for solving the linear system like Generalized Minimum Residual (GMRES) and stabilized biconjugate gradient (BiCGStab), but these methods are conceptually more challenging and difficult to implement. As we will shown in the timing results in Chapter 5, the power method with SOR performs sufficiently well for the problems we are studying.</p>
<div class="align-center figure" id="alg-sor-solve">
<a class="reference internal image-reference" href="../_images/alg-SOR-solve.png"><img alt="../_images/alg-SOR-solve.png" src="../_images/alg-SOR-solve.png" style="width: 800px;" /></a>
<p class="caption"><strong>Figure 9</strong>: Successive over-relaxation numerical flux inversion.</p>
</div>
</div>
<div class="section" id="references">
<h2>7.8. References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[1]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id3">2</a>)</em> <ol class="last upperalpha simple" start="11">
<li>Smith, &#8220;Nodal Method Storage Reduction by Non-linear Iteration.&#8221; <em>Transactions of the American Nuclear Society</em>, <strong>44</strong>, (1983).</li>
</ol>
</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><ol class="first last upperalpha simple">
<li>Yamamoto, &#8220;Generalized Coarse-Mesh Rebalance Method for Acceleration of Neutron Transport Calculations.&#8221; <em>Journal of Nuclear Science and Engineering</em>, <strong>151</strong>, pp. 274-281 (2005).</li>
</ol>
</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td><ol class="first last upperalpha simple" start="5">
<li>Lewis and W. Miller, Jr., &#8220;Computational Methods of Neutron Transport.&#8221; <em>John Wiley &amp; Sons</em> (1984).</li>
</ol>
</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[4]</a></td><td><ol class="first last upperalpha simple" start="12">
<li>Li, &#8220;A Low Order Acceleration Scheme for Solving the Neutron Transport Equation.&#8221; M.S. Thesis, Massachusetts Institute of Technology (2013).</li>
</ol>
</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[5]</td><td><ol class="first last upperalpha simple">
<li>Yamamoto, &#8220;Cell Based CMFD Formulation for Acceleration of Whole-Core Method of Characteristics Calculations.&#8221; <em>Journal of the Korean Nuclear Society</em>, <strong>34</strong>, pp. 250-258 (2002).</li>
</ol>
</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[6]</td><td><ol class="first last upperalpha simple">
<li>Yamamoto, &#8220;Implementation of Two-Level Coarse Mesh Finite Difference Acceleration in an Arbitrary Geometry, Two-Dimensional Discrete Ordinates Transport Method.&#8221; <em>Journal of Nuclear Science and Engineering</em>, <strong>158</strong>, pp. 289-298 (2008).</li>
</ol>
</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[7]</a></td><td><ol class="first last upperalpha simple" start="11">
<li>Smith and J. D. Rhodes, &#8220;Full-Core, 2-D, LWR Core Calculations with CASMO-4E.&#8221; <em>Proceedings of PHYSOR</em>, Seoul, South Korea (2002).</li>
</ol>
</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id14" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[8]</td><td><em>(<a class="fn-backref" href="#id5">1</a>, <a class="fn-backref" href="#id6">2</a>)</em> <ol class="last upperalpha simple" start="5">
<li>Larsen, &#8220;Infinite Medium Solutions to the Transport Equation, $S_n$ Discretization Schemes, and the Diffusion Approximation. &#8221; <em>Proceedings of the Joint International Topical Meeting on Mathematics and Computation and Supercomputing in Nuclear Applications</em>, Salt Lake City, UT, USA (2001).</li>
</ol>
</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/openmoc-logo-sphinx.png" alt="Logo"/>
            </a></p>
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">7. Coarse Mesh Finite Difference Acceleration</a><ul>
<li><a class="reference internal" href="#cross-section-generation">7.1. Cross Section Generation</a></li>
<li><a class="reference internal" href="#applying-the-finite-difference-approximation">7.2. Applying the Finite Difference Approximation</a></li>
<li><a class="reference internal" href="#nonlinear-diffusion-correction-factors">7.3. Nonlinear Diffusion Correction Factors</a></li>
<li><a class="reference internal" href="#coarse-mesh-cell-corner-crossings">7.4. Coarse Mesh Cell Corner Crossings</a></li>
<li><a class="reference internal" href="#optically-thick-regions">7.5. Optically Thick Regions</a></li>
<li><a class="reference internal" href="#matrix-equations">7.6. Matrix Equations</a></li>
<li><a class="reference internal" href="#cmfd-accelerated-moc-algorithm">7.7. CMFD Accelerated MOC Algorithm</a></li>
<li><a class="reference internal" href="#references">7.8. References</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="parallelization.html"
                        title="previous chapter">6. Parallelization</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="../usersguide/index.html"
                        title="next chapter">User&#8217;s Guide</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/methods/cmfd.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../usersguide/index.html" title="User’s Guide"
             >next</a> |</li>
        <li class="right" >
          <a href="parallelization.html" title="6. Parallelization"
             >previous</a> |</li>
        <li><a href="../index.html">OpenMOC Documentation</a> &raquo;</li>
          <li><a href="index.html" >Theory and Methodology</a> &raquo;</li> 
      </ul>
    </div>

    <div class="footer">
        &copy; Copyright 2012-2013, Massachusetts Institute of Technology.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.1.
    </div>
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-30411614-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

  </body>
</html>